<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyber Blackjack</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
        --card-back-color: #222; /* Default card back color */
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Orbitron', monospace;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
      color: #00ffff;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0,255,255,0.15) 0%, transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(255,0,255,0.15) 0%, transparent 40%);
      pointer-events: none;
      z-index: -1;
    }

    .dealer-room-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        transition: background-image 0.5s ease-in-out;
        z-index: -2;
        /* Default futuristic background when no dealer is selected */
        background-image: url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB');
    }

    /* General Layout */
    .container {
      width: 90%;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      position: relative;
      z-index: 1;
      animation: neon-border-pulse 3s infinite alternate;
    }

    @keyframes neon-border-pulse {
      from { border-color: #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.3); }
      to { border-color: #ff00ff; box-shadow: 0 0 30px rgba(255, 0, 255, 0.7), inset 0 0 15px rgba(255, 0, 255, 0.5); }
    }

    h1, h2 {
      text-align: center;
      margin-bottom: 20px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.7);
    }

    /* .hidden class is kept for reference but no longer applied to screens for always-visible mode */
    .hidden {
      display: none !important;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding: 10px 0;
      border-bottom: 1px dashed #00ffff;
    }

    .header-left, .header-right {
      display: flex;
      align-items: center;
    }

    .header-info {
      margin-left: 15px;
      font-size: 1.1rem;
      color: #00ffdd;
    }
    
    .xp-bar {
      width: 150px;
      height: 15px;
      background-color: #333;
      border: 1px solid #00ffff;
      border-radius: 5px;
      overflow: hidden;
      margin-left: 10px;
      position: relative;
    }

    .xp-bar-fill {
      height: 100%;
      background-color: #00ff88;
      width: 0%;
      transition: width 0.5s ease-out;
      border-radius: 3px;
    }

    .xp-text {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        color: #000;
        text-shadow: 0 0 2px #00ffff;
    }

    /* Weekly Pass Indicator */
    .pass-indicator {
        margin-left: 15px;
        font-size: 0.9rem;
        color: #ffd700;
        background: rgba(255, 215, 0, 0.1);
        padding: 5px 10px;
        border-radius: 5px;
        border: 1px solid #ffd700;
        animation: neon-glow-small 1.5s infinite alternate;
    }

    @keyframes neon-glow-small {
        from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.7); }
        to { box-shadow: 0 0 8px rgba(255, 215, 0, 0.9); }
    }


    /* Main Menu */
    .main-menu, .campaign-section, .powerups-section, .shop-screen, .stats-screen, .pvp-lobby {
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
      justify-content: center;
    }

    .menu-button, .bet-button, .game-button, .shop-button, .back-button, .powerup-button {
      background: #00aaff;
      color: #fff;
      border: 2px solid #00ffff;
      padding: 12px 25px;
      font-family: 'Orbitron', monospace;
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      text-shadow: 0 0 5px rgba(255,255,255,0.5);
      box-shadow: 0 0 10px rgba(0, 170, 255, 0.7);
    }

    .menu-button:hover, .bet-button:hover, .game-button:hover, .shop-button:hover, .back-button:hover, .powerup-button:hover {
      background: #00ffff;
      color: #000;
      border-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.9);
      transform: translateY(-2px);
    }

    .menu-button:disabled, .game-button:disabled, .powerup-button:disabled {
      background: #555;
      border-color: #777;
      color: #bbb;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* Betting Section */
    .betting-section, .game-area {
      text-align: center;
    }

    .bet-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 8px;
      font-family: 'Orbitron', monospace;
      font-size: 1rem;
      border-radius: 5px;
      margin-bottom: 20px;
      width: 150px;
    }

    .bet-options {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
    }

    /* Game Area */
    .game-board {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-top: 20px;
    }

    .player-section, .dealer-section {
      width: 100%;
      text-align: center;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #00ffff;
      box-shadow: inset 0 0 5px #00ffff;
    }

    .hand-display {
      display: flex;
      justify-content: center;
      min-height: 120px; /* To prevent layout shift */
      gap: 10px;
      flex-wrap: wrap;
    }

    .card {
      width: 80px;
      height: 110px;
      background-color: #fff;
      border: 2px solid #00aaff;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0, 170, 255, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
      position: relative;
      transition: transform 0.5s;
      transform-style: preserve-3d;
      perspective: 1000px;
    }
    
    .card-inner {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.5s;
    }

    .card.flipped .card-inner {
      transform: rotateY(180deg);
    }

    .card-front, .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }

    .card-front {
      background-color: #fff;
      color: #000;
      border: 1px solid #00aaff;
    }

    .card-front span {
      font-size: 1.2rem;
      line-height: 1;
    }

    .card-front span:first-child { align-self: flex-start; }
    .card-front span:last-child { align-self: flex-end; }
    .card-front span:nth-child(2) { font-size: 2rem; } /* Suit symbol */

    .card-front.red { color: #ff0000; }
    .card-front.black { color: #000000; }


    .card-back {
      background-color: var(--card-back-color); /* Dynamic color */
      transform: rotateY(180deg);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 0.8rem;
      text-shadow: 0 0 5px rgba(255,255,255,0.5);
      border: 1px solid #00ffff;
      box-shadow: inset 0 0 5px rgba(0,255,255,0.7);
    }
    
    .game-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    .message {
      margin-top: 20px;
      font-size: 1.3rem;
      font-weight: bold;
      padding: 10px;
      border-radius: 5px;
      animation: pulse 1s infinite alternate;
    }

    .message.win {
        color: #00ff00;
        text-shadow: 0 0 8px #00ff00;
        border: 1px solid #00ff00;
    }
    .message.lose {
        color: #ff0000;
        text-shadow: 0 0 8px #ff0000;
        border: 1px solid #ff0000;
    }
    .message.tie {
        color: #ffff00;
        text-shadow: 0 0 8px #ffff00;
        border: 1px solid #ffff00;
    }

    @keyframes pulse {
      from { transform: scale(1); opacity: 1; }
      to { transform: scale(1.02); opacity: 0.9; }
    }

    .post-game-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
    }

    .risk-game-section {
        margin-top: 20px;
        border-top: 1px dashed #00ffff;
        padding-top: 15px;
        text-align: center;
    }

    .risk-game-section button {
        background-color: #ffaa00;
        border-color: #ffff00;
        color: #333;
    }
    .risk-game-section button:hover {
        background-color: #ffff00;
        border-color: #ffaa00;
        color: #000;
    }

    /* Campaign Section */
    .dealers-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }

    .dealer-card {
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid; /* Color set by JS */
        border-radius: 10px;
        padding: 15px;
        text-align: center;
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .dealer-card:hover:not(.locked) {
        transform: translateY(-5px);
        box-shadow: 0 0 15px currentColor; /* Uses border color */
    }

    .dealer-card.locked {
        opacity: 0.5;
        cursor: not-allowed;
        filter: grayscale(100%);
    }

    .dealer-card .locked-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #ff0000;
        font-weight: bold;
        text-shadow: 0 0 5px #ff0000;
        font-size: 1.2rem;
        gap: 5px;
    }

    /* --- Modified for images --- */
    .dealer-avatar {
        margin-bottom: 10px;
        border-radius: 50%;
        border: 3px solid; /* Color set by JS */
        width: 80px;
        height: 80px;
        margin: 0 auto 10px;
        overflow: hidden; /* Ensures image respects border-radius */
    }

    .dealer-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Ensures the image covers the area without distortion */
        border-radius: 50%; /* Make the image circular */
    }
    /* --- End Modified for images --- */

    .dealer-name {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 5px;
    }

    .boss-dealer-name {
        animation: boss-neon-pulse 2s infinite alternate;
    }

    @keyframes boss-neon-pulse {
        from { color: #ffd700; text-shadow: 0 0 10px #ffd700; }
        to { color: #ff00ff; text-shadow: 0 0 15px #ff00ff; }
    }

    .dealer-type {
        font-size: 0.9rem;
        opacity: 0.8;
        margin-bottom: 10px;
    }

    .dealer-description {
        font-size: 0.9rem;
        margin-bottom: 15px;
    }

    .dealer-stats {
        display: flex;
        justify-content: space-around;
        font-size: 0.85rem;
        border-top: 1px dashed rgba(0, 255, 255, 0.5);
        padding-top: 10px;
    }

    .dealer-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .dealer-stat-label {
        font-weight: bold;
        color: #00ff88;
    }
    .dealer-stat-value {
        margin-top: 3px;
        color: #00ffff;
    }

    .current-dealer-info {
        display: flex;
        align-items: center;
        gap: 15px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        padding: 10px 20px;
        border-radius: 8px;
        margin-top: 15px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    .current-dealer-info .current-dealer-avatar {
        font-size: 2.5rem;
        border-radius: 50%;
        border: 2px solid;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden; /* Ensure image respects border-radius */
    }
    .current-dealer-info .current-dealer-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 50%;
    }


    /* Shop Screen */
    .shop-section {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .shop-category {
        margin-bottom: 20px;
    }

    .shop-category h3 {
        text-align: center;
        color: #ff00ff;
        text-shadow: 0 0 8px #ff00ff;
        margin-bottom: 15px;
        border-bottom: 1px dashed #ff00ff;
        padding-bottom: 5px;
    }

    .shop-items-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
    }

    .shop-item {
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        font-family: 'Orbitron', monospace;
        color: #00ffff;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .shop-item:hover:not(.purchased):not(.active-skin):not(.pass-active) {
        background: rgba(0, 170, 255, 0.3);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    .shop-item.purchased {
        border-color: #00ff00;
        color: #00ff00;
        opacity: 0.8;
        cursor: default;
    }

    .shop-item.active-skin, .shop-item.pass-active {
        border-color: #ff00ff;
        color: #ff00ff;
        box-shadow: 0 0 15px #ff00ff;
        font-weight: bold;
    }

    .shop-item span {
        font-size: 0.8rem;
        color: #aaa;
        display: block;
        margin-top: 5px;
    }

    /* Power-up Controls in Game Area */
    .powerup-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
    }
    .powerup-controls .powerup-button {
        background-color: #ff6600;
        border-color: #ff9900;
        color: #eee;
    }
    .powerup-controls .powerup-button:hover {
        background-color: #ff9900;
        border-color: #ff6600;
        color: #000;
    }

    /* Brawl Mode HUD */
    .brawl-hud {
        display: flex;
        justify-content: space-around;
        margin-top: 20px;
        width: 100%;
    }

    .hp-bar-container {
        width: 45%;
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        box-shadow: inset 0 0 5px #00ffff;
    }

    .hp-bar-label {
        font-size: 1rem;
        margin-bottom: 5px;
    }

    .hp-bar {
        width: 100%;
        height: 20px;
        background-color: #333;
        border: 1px solid #00ff00;
        border-radius: 5px;
        overflow: hidden;
    }

    .hp-bar-fill {
        height: 100%;
        background-color: #00ff00; /* Green for player */
        width: 100%;
        transition: width 0.3s ease-out, background-color 0.3s ease-out;
    }

    .hp-bar-fill.dealer {
        background-color: #00aaff; /* Blue for dealer */
    }

    .hp-text-display {
        font-size: 1.1rem;
        font-weight: bold;
        margin-top: 5px;
    }

    .brawl-special-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
    }

    .charge-bar-container {
        width: 150px;
        height: 15px;
        background-color: #333;
        border: 1px solid #ff00ff;
        border-radius: 5px;
        overflow: hidden;
        margin-left: 10px;
        position: relative;
    }

    .charge-bar-fill {
        height: 100%;
        background-color: #ff00ff;
        width: 0%;
        transition: width 0.5s ease-out;
        border-radius: 3px;
    }

    .charge-text {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        color: #000;
        text-shadow: 0 0 2px #ff00ff;
    }
    
    #special-attack-btn {
        background-color: #ff00ff;
        border-color: #ff00ff;
        color: #000;
    }
    #special-attack-btn:hover {
        background-color: #00ffff;
        border-color: #ff00ff;
        color: #000;
    }
    #ultimate-btn {
        background-color: #ff0000;
        border-color: #ff5500;
        color: #fff;
    }
    #ultimate-btn:hover {
        background-color: #ff5500;
        border-color: #ff0000;
        color: #000;
    }

    /* Stats Screen */
    .stats-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
    }
    .stats-item {
        font-size: 1.1rem;
        padding: 8px;
        border: 1px dashed #00ffff;
        border-radius: 5px;
        width: 100%;
        max-width: 400px;
        text-align: center;
    }
    .stats-item span {
        color: #00ff88;
        font-weight: bold;
        margin-left: 10px;
    }
    .leaderboard-list {
        list-style: none;
        padding: 0;
        margin-top: 20px;
        width: 100%;
        max-width: 500px;
    }
    .leaderboard-list li {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid #ff00ff;
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    /* PvP Lobby */
    .pvp-lobby {
        text-align: center;
    }
    .pvp-status {
        font-size: 1.2rem;
        margin-bottom: 20px;
        color: #00ff88;
    }

    /* Game Deck for animations */
    .game-deck {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 110px;
        background-color: var(--card-back-color);
        border: 2px solid #00ffff;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        z-index: 0; /* Behind other elements */
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 0.8rem;
        opacity: 0.8;
    }

    .game-deck.shuffle-animation {
        animation: shuffle-deck 0.5s ease-out;
    }

    @keyframes shuffle-deck {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        25% { transform: translate(-55%, -50%) rotate(5deg); }
        50% { transform: translate(-50%, -50%) rotate(0deg); }
        75% { transform: translate(-45%, -50%) rotate(-5deg); }
        100% { transform: translate(-50%, -50%) rotate(0deg); }
    }

    /* Screen Shake Effect */
    body.screen-shake {
        animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both;
        transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        perspective: 1000px;
    }

    @keyframes shake {
        10%, 90% { transform: translate3d(-1px, 0, 0); }
        20%, 80% { transform: translate3d(2px, 0, 0); }
        30%, 70% { transform: translate3d(-4px, 0, 0); }
        40%, 60% { transform: translate3d(4px, 0, 0); }
        50% { transform: translate3d(-4px, 0, 0); }
    }

    /* Particle Effects (for JS generated elements) */
    .particle {
        position: fixed;
        background-color: #fff; /* Default, overridden by JS */
        border-radius: 50%;
        animation: fadeOut 1.5s forwards; /* Increased duration */
        pointer-events: none;
        z-index: 9999;
    }

    @keyframes fadeOut {
        from { opacity: 1; transform: scale(1); }
        to { opacity: 0; transform: scale(0); }
    }

    .rogue-mode-card {
        border-color: #FF00FF !important;
        box-shadow: 0 0 15px rgba(255, 0, 255, 0.7) !important;
    }

    .rogue-mode-card .dealer-name {
        animation: boss-neon-pulse 1.5s infinite alternate;
    }
  </style>
</head>
<body>
  <div class="dealer-room-bg" id="dealer-room-bg"></div>
  <audio id="dealer-music" loop preload="auto"></audio>

  <!-- Audio elements for sound effects -->
  <audio id="sfx-hit" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" preload="auto"></audio> <!-- Replace with actual hit sound -->
  <audio id="sfx-stand" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" preload="auto"></audio> <!-- Replace with actual stand sound -->
  <audio id="sfx-doubledown" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" preload="auto"></audio> <!-- Replace with actual double down sound -->
  <audio id="sfx-win" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3" preload="auto"></audio> <!-- Replace with actual win sound -->
  <audio id="sfx-lose" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3" preload="auto"></audio> <!-- Replace with actual lose sound -->
  <audio id="sfx-tie" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3" preload="auto"></audio> <!-- Replace with actual tie sound -->
  <audio id="sfx-powerup-extraCard" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-7.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-peekDealer" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3" preload="auto"></audio> <!-- Corrected path for sfx-powerup-peekDealer -->
  <audio id="sfx-powerup-shieldLoss" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-9.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-bomb" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-freeze" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-11.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-doubleXP" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-12.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-specialAttack" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3" preload="auto"></audio> <!-- Replace with actual special attack sound -->
  <audio id="sfx-ultimate" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-14.mp3" preload="auto"></audio> <!-- Replace with actual ultimate attack sound -->
  <audio id="sfx-levelUp" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3" preload="auto"></audio> <!-- Replace with actual level up sound -->
  <audio id="sfx-purchase" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3" preload="auto"></audio> <!-- Replace with actual purchase sound -->

  <div class="container">
    <div class="header">
      <div class="header-left">
        <div class="header-info">Credits: <span id="credits">1000</span></div>
        <div class="header-info">Level: <span id="player-level">1</span></div>
        <div class="xp-bar">
          <div class="xp-bar-fill" id="xp-bar-fill"></div>
          <span class="xp-text" id="xp-text"><span id="player-xp">0</span>/<span id="xp-to-next">100</span> XP</span>
        </div>
        <div id="weekly-pass-indicator" class="pass-indicator hidden">Cyber Nexus Pass: <span id="pass-time-remaining"></span></div>
      </div>
      <div class="header-right">
        <div class="header-info">Wins: <span id="wins">0</span></div>
        <div class="header-info">Games: <span id="games">0</span></div>
      </div>
    </div>

    <!-- Main menu screen -->
    <div id="main-menu" class="main-menu screen"> 
      <h2>Cyber Blackjack</h2>
      <button class="menu-button" onclick="game.showQuickPlay()">Quick Play</button>
      <button class="menu-button" onclick="game.showCampaign()">Campaign Mode</button>
      <button class="menu-button" onclick="game.startBrawlMode()">Brawl Mode</button>
      <button class="menu-button" onclick="game.openShopScreen()">Shop</button>
      <button class="menu-button" onclick="game.openStatsScreen()">Stats</button>
      <button class="menu-button" onclick="game.startPvP()">PvP Online</button>
      <button class="menu-button" onclick="game.resetAllDataConfirmation()">Reset Game Data</button>
    </div>
    <!--betting section-->
    <div id="betting-section" class="screen"> <h2>Place Your Bet</h2>
    <div id="current-dealer-info" class="current-dealer-info hidden"></div>

    <input type="number" id="bet-amount" class="bet-input" value="50" min="10" step="10">
    
    <div class="bet-options">
        <button class="bet-button" onclick="game.adjustBet(-100)">-100</button>
        <button class="bet-button" onclick="game.adjustBet(-10)">-10</button>
        <button class="bet-button" onclick="game.adjustBet(10)">+10</button>
        <button class="bet-button" onclick="game.adjustBet(100)">+100</button>
        <button class="bet-button" onclick="game.betMax()">Max Bet</button>
    </div>

    <button id="place-bet-and-deal-btn" class="game-button" onclick="game.startGame()">Deal Cards</button> 
    <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
</div>
    <!-- Campaign section screen - initially hidden -->
    <div id="campaign-section" class="campaign-section screen hidden">
        <h2>Choose Your Dealer</h2>
        <div id="dealers-grid" class="dealers-grid">
        </div>
        <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- Game area screen - initially hidden -->
    <div id="game-area" class="game-area screen hidden">
      <div class="game-board">
        <div id="dealer-section" class="dealer-section">
          <h3>Dealer (<span id="dealer-total">Total: 0</span>)</h3>
          <div id="dealer-cards" class="hand-display"></div>
        </div>

        <div id="brawl-hud" class="brawl-hud hidden">
            <div class="hp-bar-container player-hp-container">
                <div class="hp-bar-label">Player HP</div>
                <div class="hp-bar">
                    <div id="player-hp-bar" class="hp-bar-fill"></div>
                </div>
                <div id="player-hp" class="hp-text-display">100</div>
            </div>
            <div class="hp-bar-container dealer-hp-container">
                <div class="hp-bar-label">Dealer HP</div>
                <div class="hp-bar">
                    <div id="dealer-hp-bar" class="hp-bar-fill dealer"></div>
                </div>
                <div id="dealer-hp" class="hp-text-display">100</div>
            </div>
        </div>

        <div id="player-section" class="player-section">
          <h3>Player (<span id="player-total">Total: 0</span>)</h3>
          <div id="player-cards" class="hand-display"></div>
        </div>
      </div>

      <div id="powerup-controls" class="powerup-controls hidden">
        <button id="use-extraCard" class="powerup-button" onclick="game.usePowerUp('extraCard', event)">Extra Card (<span id="extraCard-count">0</span>)</button>
        <button id="use-peekDealer" class="powerup-button" onclick="game.usePowerUp('peekDealer', event)">Peek Dealer (<span id="peekDealer-count">0</span>)</button>
        <button id="use-shieldLoss" class="powerup-button" onclick="game.usePowerUp('shieldLoss', event)">Shield (<span id="shieldLoss-count">0</span>)</button>
        <button id="use-bomb" class="powerup-button" onclick="game.usePowerUp('bomb', event)">Bomb (<span id="bomb-count">0</span>)</button>
        <button id="use-freeze" class="powerup-button" onclick="game.usePowerUp('freeze', event)">Freeze (<span id="freeze-count">0</span>)</button>
        <button id="use-doubleXP" class="powerup-button" onclick="game.usePowerUp('doubleXP', event)">2x XP (<span id="doubleXP-count">0</span>)</button>
      </div>

      <div id="message-area" class="message hidden"></div>

      <div id="game-controls" class="game-controls">
        <button id="hit-btn" class="game-button" onclick="game.hit()">Hit</button>
        <button id="stand-btn" class="game-button" onclick="game.stand()">Stand</button>
        <button id="double-btn" class="game-button" onclick="game.doubleDown()">Double Down</button>
      </div>

      <div id="brawl-special-controls" class="brawl-special-controls hidden">
        <div class="charge-bar-container">
            <div class="charge-bar-fill" id="special-charge-bar-fill" style="background-color: #ff00ff;"></div>
            <span class="charge-text" id="special-charge">0% Special</span>
        </div>
        <button id="special-attack-btn" class="game-button" onclick="game.useSpecialAttack(event)">Special Attack</button>
        <div class="charge-bar-container">
            <div class="charge-bar-fill" id="ultimate-charge-bar-fill" style="background-color: #ff0000;"></div>
            <span class="charge-text" id="ultimate-charge">0% Ultimate</span>
        </div>
        <button id="ultimate-btn" class="game-button" onclick="game.useUltimatePower(event)">Ultimate Power</button>
      </div>

      <div id="post-game-controls" class="post-game-controls hidden">
        <button class="menu-button" onclick="game.startGame()">New Round</button>
        <button id="risk-button" class="game-button risk-game-section" onclick="game.startRiskGame()">Risk Game (Double or Nothing)</button>
        <div id="risk-result" class="message"></div>
        <button class="back-button" onclick="game.backToMenu()">Back to Menu</button>
      </div>
    </div>

    <!-- Shop screen - initially hidden -->
    <div id="shop-screen" class="shop-screen screen hidden"> 
      <h2>Cyber Shop</h2>
      <p>Your Credits: <span id="shop-credits">1000</span></p>
      <div class="shop-section">
        <!-- New Category for Weekly Pass -->
        <div class="shop-category">
          <h3>Cyber Nexus Pass</h3>
          <div id="weekly-pass-grid" class="shop-items-grid">
            <!-- Pass item will be dynamically inserted here -->
          </div>
        </div>
        <div class="shop-category">
          <h3>Card Skins</h3>
          <div id="card-skins" class="shop-items-grid">
          </div>
        </div>
        <div class="shop-category">
          <h3>Power-Up Packs</h3>
          <div id="powerup-packs" class="shop-items-grid">
            <!-- These buttons will be dynamically updated with prices in setupShop -->
            <button class="shop-item" onclick="game.buyPowerPack(1, 300)">
              Small Pack<br><span>(1 Random Power-up)</span><br><span>300 Credits</span>
            </button>
            <button class="shop-item" onclick="game.buyPowerPack(3, 750)">
              Medium Pack<br><span>(3 Random Power-ups)</span><br><span>750 Credits</span>
            </button>
          </div>
        </div>
      </div>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- Stats screen - initially hidden -->
    <div id="stats-screen" class="stats-screen screen hidden"> 
      <h2>Player Statistics</h2>
      <div class="stats-container">
        <div class="stats-item">Games Played: <span id="stats-games">0</span></div>
        <div class="stats-item">Games Won: <span id="stats-wins">0</span></div>
        <div class="stats-item">Win Rate: <span id="stats-rate">0%</span></div>
        <div class="stats-item">Most Used Power-Up: <span id="stats-powerup">N/A</span></div>
        <div class="stats-item">Total Blackjacks: <span id="stats-blackjacks">0</span></div>
        <div class="stats-item">Total Busts: <span id="stats-busts">0</span></div>
      </div>
      <h3>Leaderboard (Campaign Streaks)</h3>
      <ul id="leaderboard" class="leaderboard-list">
      </ul>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- PvP lobby screen - initially hidden -->
    <div id="pvp-lobby" class="pvp-lobby screen hidden"> 
      <h2>PvP Online</h2>
      <p class="pvp-status" id="pvp-status">Connecting to server...!?!</p>
      <button class="menu-button" onclick="game.cancelPvP()">Cancel Search</button>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>
  </div>

  <div id="game-deck" class="game-deck hidden">Deck</div>

  <script>
    // Global utility functions (can be moved into game object if preferred, but useful globally for effects)
    function triggerScreenShake() {
      document.body.classList.add('screen-shake');
      setTimeout(() => {
        document.body.classList.remove('screen-shake');
      }, 200); // Duration of the shake animation
    }

    /**
     * Spawns multiple particles with customizable color, size, and duration.
     * Particles will originate near the mouse click or screen center and spread.
     * @param {number} count - Number of particles to spawn.
     * @param {string} color - CSS color string for particles (e.g., '#FF00FF').
     * @param {number} [maxSize=5] - Maximum size of particles in pixels.
     * @param {number} [duration=1000] - Duration of particle animation in milliseconds.
     * @param {Event} [event=null] - Optional event object to spawn particles at cursor position.
     */
    function spawnParticles(count, color, maxSize = 5, duration = 1500, event = null) {
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            particle.style.backgroundColor = color;
            // Larger and more varied size
            const size = Math.random() * (maxSize - 5) + 5 + 'px'; // Min size 5px for better visibility
            particle.style.width = size;
            particle.style.height = size;

            // Start from center of the screen or event position if available
            const startX = event ? event.clientX : window.innerWidth / 2;
            const startY = event ? event.clientY : window.innerHeight / 2;
            
            // Randomize starting position slightly around the central point
            const offsetX = (Math.random() - 0.5) * 50; // -25 to +25 pixels
            const offsetY = (Math.random() - 0.5) * 50; // -25 to +25 pixels

            particle.style.left = (startX + offsetX) + 'px';
            particle.style.top = (startY + offsetY) + 'px';

            // Increase speed/distance for wider spread
            const angle = Math.random() * Math.PI * 2; // Full 360-degree spread
            const distance = Math.random() * 300 + 150; // Spread from 150 to 450 pixels away
            const endX = startX + distance * Math.cos(angle);
            const endY = startY + distance * Math.sin(angle);

            particle.style.transition = `transform ${duration / 1000}s ease-out, opacity ${duration / 1000}s forwards`;
            setTimeout(() => {
                // Ensure the transform translates from the initial position relative to the viewport
                particle.style.transform = `translate(${endX - (startX + offsetX)}px, ${endY - (startY + offsetY)}px)`;
                particle.style.opacity = 0;
            }, 10);
            document.body.appendChild(particle);
            particle.addEventListener('transitionend', () => {
                particle.remove();
            });
        }
    }


    // Main Game Object
    const game = {
      playerCredits: 1000,
      wins: 0,
      games: 0,
      playerLevel: 1,
      playerXP: 0,
      xpToNextLevel: 100,
      playerHand: [],
      dealerHand: [],
      deck: [],
      isGameActive: false,
      currentBet: 0,
      isBrawl: false,
      playerHP: 100,
      dealerHP: 100,
      specialCharge: 0,
      ultimateCharge: 0,
      powerUps: {
        extraCard: 0,
        peekDealer: 0,
        shieldLoss: 0,
        bomb: 0,
        freeze: 0,
        doubleXP: 0
      },

      purchasedSkins: ['default'],
      activeCardSkin: 'default',
      // --- MODIFIED DEALERS ARRAY WITH IMAGE PATHS AND COLORS ---
      // Changed avatarSrc to point to the new assets/images folder
      dealers: [
        { id: 'novice', name: 'Cypher-Bot 7', type: 'Novice', description: 'A basic AI. Prone to errors, easy to beat.', avatarSrc: 'assets/images/bot-7.png', color: '#00ff80', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-17.mp3', unlocksAtLevel: 1, betMultiplier: 1, xpMultiplier: 1, strategy: 'conservative', hp: 100,
        isBoss: false, uniqueAbility: { id: 'novice_ability', name: 'RESERVE CARD', description: 'ONCE PER GAME, IF THE DEALER BUSTS, THEY CAN DISCARD ONE OF THEIR CARDS AND DRAW A NEW ONE, BUT THE TOTAL VALUE CANNOT EXCEED 21. SLIGHT CHANCE OF DEALER DRAWING AN ACE AS THEIR NEW CARD.', usedThisGame: false }, roomImage: 'assets/images/bot-7.png',
        credits_drop: 100,
        },
        { id: 'conservative', name: 'Data-Samurai', type: 'Conservative', description: 'Plays it safe, rarely takes risks.', avatarSrc: 'assets/images/data-samurai.png', color: '#00ff800', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-18.mp3', unlocksAtLevel: 3, betMultiplier: 1.2, xpMultiplier: 1.2, strategy: 'conservative', hp: 120,
         uniqueAbility: { id: 'conservative_ability', name: 'FOCUSED DRAW', description: 'LOW CHANCE AT THE START OF DEALER\'S TURN IF CURRENT HAND IS 12-16. DEALER DRAWS THE NEXT CARD IN THE DECK (INSTEAD OF SHUFFLING) IF IT IMPROVES THEIR HAND WITHOUT BUSTING.', usedThisGame: false }, roomImage: 'assets/images/data-samurai.png',
         credits_drop: 150,
        },
        { id: 'aggressive', name: 'Neon Nighthawk', type: 'Aggressive', description: 'High risk, high reward. Loves to hit!', avatarSrc: 'assets/images/neon-nighthawk.png', color: '#ff4500', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-19.mp3', unlocksAtLevel: 5, betMultiplier: 1.5, xpMultiplier: 1.5, strategy: 'aggressive', hp: 150,
        uniqueAbility: { id: 'aggressive_ability', name: 'AGGRESSIVE BET', description: 'SMALL CHANCE AT THE START OF ANY ROUND. FORCES THE PLAYER\'S CURRENT BET TO DOUBLE (IF PLAYER HAS ENOUGH CREDITS).', usedThisGame: false },  roomImage: 'assets/images/neon-nighthawk.png',
        credits_drop: 200,
        },
        { id: 'calculating', name: 'The Quantum Quasar', type: 'Calculating', description: 'Analyzes odds, exploits weaknesses.', avatarSrc: 'assets/images/quantum.png', color: '#9370db', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-20.mp3', unlocksAtLevel: 8, betMultiplier: 1.8, xpMultiplier: 1.8, strategy: 'advanced', hp: 180,
         uniqueAbility: { id: 'calculating_ability', name: 'CARD PREDICTION', description: 'LOW CHANCE AT THE START OF DEALER\'S TURN IF DEALER HAND IS 14-16. DEALER "PREDICTS" THE NEXT CARD. IF IT HELPS REACH 17-21, THEY TAKE IT. IF NOT, THEY RESHUFFLE THE TOP FEW CARDS.', usedThisGame: false }, secondaryAbility:{ id: 'temporal_flux', 
        name: 'temporal flux', 
        description: 'A small chance, if the player\'s hand reaches 20 or 21 on the initial deal, to rewind time, forcing the player to discard one of their initial cards and draw a new one.', 
        usedThisGame: false }, roomImage: 'assets/images/quantum.png',
         credits_drop: 250,
        },
        { id: 'master', name: 'Zenith', type: 'Master', description: 'The ultimate challenge. Only for true champions.', avatarSrc: 'assets/images/zenith.png', color: '#ffd700', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-21.mp3', unlocksAtLevel: 10, betMultiplier: 2.0, xpMultiplier: 2.0, strategy: 'optimal', hp: 250,
         uniqueAbility: { id: 'master_ability', name: 'ADAPTIVE STRATEGY', description: 'Medium chance if dealer is losing or has a weak hand. Temporarily switches their strategy to be more optimal or risky for the current hand.', usedThisGame: false }, secondaryAbility: { id: 'entropy_cascade', name: 'Entropy Cascade', description: 'Randomizes player card values for the current round.', usedThisGame: false }, roomImage: 'assets/images/zenith.png',
          credits_drop: 400,
        },
        { id: 'expert', name: 'Shadow Weaver', type: 'Expert', description: 'Strikes from the shadows, unpredictable moves.', avatarSrc: 'assets/images/shadow-weaver.jpg', color: '#8A2BE2', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-22.mp3', unlocksAtLevel: 12, betMultiplier: 2.2, xpMultiplier: 2.2, strategy: 'unpredictable', hp: 300,
          uniqueAbility: { id: 'expert_ability', name: 'HIDDEN CARD SWAP', description: 'Very low chance after initial deal or after dealer hits, secretly swaps one of their face-down cards with a favorable card from the bottom of the deck.', usedThisGame: false }, secondaryAbility: { id: 'phantom_echo', name: 'Phantom Echo', description: 'Adds a phantom card to the player\'s hand, with a positive or negative value.', usedThisGame: false }, roomImage: 'assets/images/shadow-weaver.jpg',credits_drop: 450,
          
        },
        { id: 'unbeatable', name: 'OMEGA', type: 'Unbeatable', description: 'The final boss. Prepare for your end.', avatarSrc: 'assets/images/omega.jpg', color: '#FF1493', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-14.mp3', unlocksAtLevel: 15, betMultiplier: 2.5, xpMultiplier: 2.5, strategy: 'perfect', hp: 350, isBoss: true,
          uniqueAbility: { id: 'system_override', name: 'SYSTEM OVERRIDE', description: 'Extreme low chance, only if player has a very strong hand and dealer has a weak hand. Forces a re-deal of a single card for both player and dealer.', usedThisGame: false }, secondaryAbility: { id: 'credit_lockdown', name: 'CREDIT LOCKDOWN', description: 'Restricts player bet size and temporarily quarantines won credits for a few rounds.', usedThisGame: false }, roomImage: 'assets/images/omega.jpg', credits_drop: 500,
        },
        
        { id: 'glitch', name: 'The Glitch', type: 'Erratic', description: 'Randomly alters game conditions.', avatarSrc: 'https://placehold.co/80x80/00FFFF/000000?text=ðŸ‘¾', color: '#00FFFF', music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-23.mp3', unlocksAtLevel: 7, betMultiplier: 1.6, xpMultiplier: 1.6, strategy: 'erratic', hp: 160,
          roomImage: 'https://placehold.co/1920x1080/003333/00FFFF?text=GLITCH+DIMENSION',
          uniqueAbility: {
            name: 'DATA CORRUPTION',
            description: 'SMALL CHANCE AT THE START OF DEALER\'S TURN. TEMPORARILY SCRAMBLES THE DISPLAYED VALUES OF DEALER\'S CARDS.',
            id: 'glitch_ability',
            usedThisGame: false
          }
        }
      ],
      // Removed the dealerAbilities array as abilities are now embedded in the dealer objects directly
      currentDealer: null,
      currentDealerId: null, 
      campaignProgress: {
        currentLevel: 0,
        unlockedDealers: ['novice'],
        streaks: { quickPlay: 0, campaign: 0 },
        bestStreak: 0,
        totalBlackjacks: 0,
        totalBusts: 0,
        totalSplits: 0,
        dealerWins: {}, // New: Track wins against each specific dealer
        rogueModeUnlocked: false // New: Flag for rogue mode unlock
      },
      REQUIRED_WINS_FOR_ROGUE_MODE: 23, // New: Constant for unlock condition

      // Properties for Rogue Dealers
      isRogueModeActive: false, // Tracks if we are currently in rogue mode session
      rogueDealers: [], // Stores the 7 generated rogue dealers for the current session
      availableRogueAbilities: [], // Pool of unique abilities for rogue dealers

      cardSkins: [
        { id: 'default', name: 'Standard Cyber', color: '#222', price: 0 },
        { id: 'neon-matrix', name: 'Neon Matrix', color: '#00ffff', price: 500 },
        { id: 'lava-burst', name: 'Lava Burst', color: '#ff4500', price: 750 },
        { id: 'royal-purple', name: 'Royal Purple', color: '#8A2BE2', price: 1000 } 
      ],
      powerUpItems: {
        extraCard: { name: 'Extra Card', description: 'Draw an additional card.', price: 200 },
        peekDealer: { name: 'Peek Dealer Card', description: 'Reveal dealer\'s hidden card.', price: 300 },
        shieldLoss: { name: 'Shield of Resilience', description: 'Prevents one HP loss in Brawl.', price: 400 },
        bomb: { name: 'Brawl Bomb', description: 'Deals direct damage in Brawl.', price: 350 },
        freeze: { name: 'Dealer Freeze', description: 'Dealer skips next hit.', price: 500 },
        doubleXP: { name: 'XP Booster', description: 'Double XP for next round.', price: 600 }
      },
      DECK_RELOAD_THRESHOLD: 15, 

      // New: Brawl Mode Specific properties
      activeBrawlRule: null, // Stores the currently active random rule
      brawlRules: [
        {
          id: 'lowVisibility',
          name: 'LOW VISIBILITY',
          message: 'LOW VISIBILITY PROTOCOL ACTIVATED! Cards are hidden!',
          apply: function() {
            // Logic for dealing cards face down, handled in dealInitialCards and createCardElement
          },
          revert: function() {
            // Logic to reveal dealer's second card
            const faceDownCard = game.dealerHand.find(card => card.isFaceDown);
            if (faceDownCard) {
                faceDownCard.isFaceDown = false;
                game.updateHandsDisplay();
            }
          }
        },
        {
          id: 'powerSurge',
          name: 'POWER SURGE',
          message: 'POWER SURGE DETECTED! Power-ups are 50% more effective!',
          apply: function() { /* Effect applied directly in usePowerUp */ },
          revert: function() { /* No direct revert needed, effect is for one round */ }
        },
        {
          id: 'glitchInMatrix',
          name: 'GLITCH IN THE MATRIX',
          message: 'GLITCH IN THE MATRIX! Card values are scrambling!',
          apply: function() { game.applyGlitchEffect(); },
          revert: function() { game.revertGlitchEffect(); }
        },
        // NEW: Environmental Hazards
        {
          id: 'systemOverload',
          name: 'SYSTEM OVERLOAD',
          message: 'SYSTEM OVERLOAD DETECTED! Both combatants take damage!',
          apply: function() { game.applySystemOverload(); },
          revert: function() { /* Damage is permanent, no revert needed */ }
        },
        {
          id: 'empBurst',
          name: 'EMP BURST',
          message: 'EMP BURST! Power-ups temporarily disabled!',
          apply: function() { game.applyEmpBurst(); },
          revert: function() { game.revertEmpBurst(); }
        },
        {
          id: 'limitBarriers',
          name: 'LIMIT BARRIERS',
          message: 'LIMIT BARRIERS ENGAGED! Only one hit allowed per hand!',
          apply: function() { game.applyLimitBarriers(); },
          revert: function() { game.revertLimitBarriers(); }
        }
      ],

      // NEW: State for Limit Barriers hazard
      playerHitsThisRound: 0,
      dealerHitsThisRound: 0,
      isLimitBarrierActive: false,

      // NEW: Cyber Nexus Pass properties
      cyberNexusPass: {
        active: false,
        expiryDate: null, // Timestamp for when the pass expires
        weeklyCosmeticClaimed: false, // Track if this week's cosmetic has been claimed
        lastLoginDate: null, // Track last login for daily bonuses
        consecutiveWeeks: 0, // For loyalty streak
        currentWeeklyCosmetic: null // Stores the ID of the current weekly cosmetic
      },
      // Define pass details, including dollar price and "worth" for psychological framing
      cyberNexusPassDetails: {
          id: 'cyberNexusPass',
          name: 'Cyber Nexus Pass',
          priceUSD: 4.99, // Charm pricing
          worthUSD: 15.00, // Anchoring effect
          description: 'Access the Nexus: Accelerate XP, boost credits, get exclusive weekly cosmetics, and more!',
          xpBonus: 0.25, // +25% XP
          creditBonus: 0.15, // +15% Credits
          shopDiscount: 0.10, // 10% discount on other shop items
          dailyCreditBonus: 50, // Daily bonus credits for pass holders
          powerUpEffectivenessBonus: 0.05 // +5% chance for power-up resonance
      },
      weeklyCosmeticsPool: [
          { id: 'nexus-card-back-01', name: 'Nexus Flux Cardback', type: 'card-back' },
          { id: 'glowing-avatar-frame-01', name: 'Quantum Glow Frame', type: 'avatar-frame' },
          { id: 'win-particle-effect-01', name: 'Victory Glitch Effect', type: 'win-particle' }
          // Add more unique weekly cosmetic items here
      ],


      // UI Elements (cached for performance)
      elements: {},

       init:function() {
        this.cacheElements();
        this.loadGameData();
        // --- NEW CODE STARTS HERE ---
        // Ensure player starts with 1000 credits if loadGameData didn't set a higher value
        // or if playerCredits is currently 0 (e.g., first time playing or reset)
        if (this.playerCredits === 0 || this.playerCredits === undefined || this.playerCredits === null) {
            this.playerCredits = 1000;
            console.log("Player credits initialized to 1000."); // For debugging
        }
        // --- NEW CODE ENDS HERE ---
        this.populateAvailableRogueAbilities(); // Populate the abilities pool once
        this.updateUI();
        this.showScreen('main-menu'); 
        this.setupDealers(); 
        this.setupShop(); 
        this.updatePowerUpButtons();
        this.checkRogueModeUnlockConditions(); // Check on init
        this.checkCyberNexusPassStatus(); // Check pass status on init
        setInterval(() => this.updateCyberNexusPassUI(), 1000); // Update pass UI every second
      },

     cacheElements: function() {
        this.elements = {
          mainMenu: document.getElementById('main-menu'),
          bettingSection: document.getElementById('betting-section'),
          campaignSection: document.getElementById('campaign-section'),
          //powerUpsSection: document.getElementById('powerups-section'), // This ID does not exist in HTML
          pvpLobby: document.getElementById('pvp-lobby'),
          gameArea: document.getElementById('game-area'),
          statsScreen: document.getElementById('stats-screen'),
          shopScreen: document.getElementById('shop-screen'),
          creditsDisplay: document.getElementById('credits'),
          winsDisplay: document.getElementById('wins'),
          gamesDisplay: document.getElementById('games'),
          playerLevelDisplay: document.getElementById('player-level'),
          xpBarFill: document.getElementById('xp-bar-fill'),
          playerXPSpan: document.getElementById('player-xp'),
          xpToNextSpan: document.getElementById('xp-to-next'),
          betAmountInput: document.getElementById('bet-amount'),
          dealerCardsDiv: document.getElementById('dealer-cards'),
          playerCardsDiv: document.getElementById('player-cards'),
          dealerTotalDisplay: document.getElementById('dealer-total'),
          playerTotalDisplay: document.getElementById('player-total'),
          hitBtn: document.getElementById('hit-btn'),
          standBtn: document.getElementById('stand-btn'),
          doubleBtn: document.getElementById('double-btn'),
          messageArea: document.getElementById('message-area'),
          postGameControls: document.getElementById('post-game-controls'),
          riskButton: document.getElementById('risk-button'),
          riskResult: document.getElementById('risk-result'),
          dealersGrid: document.getElementById('dealers-grid'),
          powerUpsGrid: document.getElementById('powerup-packs'),
          shopCredits: document.getElementById('shop-credits'),
          cardSkinsGrid: document.getElementById('card-skins'),
          playerHpBar: document.getElementById('player-hp-bar'),
          dealerHpBar: document.getElementById('dealer-hp-bar'),
          playerHpText: document.getElementById('player-hp'),
          dealerHpText: document.getElementById('dealer-hp'),
          brawlHud: document.getElementById('brawl-hud'),
          placeBetBtn: document.getElementById('place-bet-btn'),
          dealBtn: document.getElementById('place-bet-and-deal-btn'),
          specialChargeBarFill: document.getElementById('special-charge-bar-fill'),
          specialChargeText: document.getElementById('special-charge'),
          ultimateChargeBarFill: document.getElementById('ultimate-charge-bar-fill'),
          ultimateChargeText: document.getElementById('ultimate-charge'),
          specialAttackBtn: document.getElementById('special-attack-btn'),
          ultimateBtn: document.getElementById('ultimate-btn'),
          brawlSpecialControls: document.getElementById('brawl-special-controls'),
          statsGames: document.getElementById('stats-games'),
          statsWins: document.getElementById('stats-wins'),
          statsRate: document.getElementById('stats-rate'),
          statsPowerup: document.getElementById('stats-powerup'),
          statsBlackjacks: document.getElementById('stats-blackjacks'),
          statsBusts: document.getElementById('stats-busts'),
          leaderboard: document.getElementById('leaderboard'),
          pvpStatus: document.getElementById('pvp-status'),
          dealerRoomBg: document.getElementById('dealer-room-bg'),
          dealerMusic: document.getElementById('dealer-music'),
          currentDealerInfo: document.getElementById('current-dealer-info'),
          currentDealerAvatar: null,
          currentDealerName: null,
          powerupControls: document.getElementById('powerup-controls'),
          gameControls: document.getElementById('game-controls'),
          gameDeck: document.getElementById('game-deck'),
          weeklyPassGrid: document.getElementById('weekly-pass-grid'), // NEW
          weeklyPassIndicator: document.getElementById('weekly-pass-indicator'), // NEW
          passTimeRemaining: document.getElementById('pass-time-remaining'), // NEW
          // New audio elements
          sfxHit: document.getElementById('sfx-hit'),
          sfxStand: document.getElementById('sfx-stand'),
          sfxDoubledown: document.getElementById('sfx-doubledown'),
          sfxWin: document.getElementById('sfx-win'),
          sfxLose: document.getElementById('sfx-lose'),
          sfxTie: document.getElementById('sfx-tie'),
          sfxPowerupExtraCard: document.getElementById('sfx-powerup-extraCard'),
          sfxPowerupPeekDealer: document.getElementById('sfx-powerup-peekDealer'),
          sfxPowerupShieldLoss: document.getElementById('sfx-powerup-shieldLoss'),
          sfxPowerupBomb: document.getElementById('sfx-powerup-bomb'),
          sfxPowerupFreeze: document.getElementById('sfx-powerup-freeze'),
          sfxPowerupDoubleXP: document.getElementById('sfx-powerup-doubleXP'),
          sfxSpecialAttack: document.getElementById('sfx-specialAttack'),
          sfxUltimate: document.getElementById('sfx-ultimate'),
          sfxLevelUp: document.getElementById('sfx-levelUp'),
          sfxPurchase: document.getElementById('sfx-purchase')
        };
      },
      /**
       * Plays a sound effect by its ID.
       * @param {string} soundId - The ID of the audio element to play (e.g., 'sfx-hit').
       */
      playSFX: function(soundId) {
        const audio = this.elements[soundId];
        if (audio) {
          audio.currentTime = 0; // Rewind to start
          audio.play().catch(e => {
            console.warn(`Failed to play sound '${soundId}':`, e);
          });
        } else {
          console.warn(`Sound element with ID '${soundId}' not found.`);
        }
      },

      loadGameData: function() {
        const savedData = JSON.parse(localStorage.getItem('cyberBlackjackGameData'));
        if (savedData) {
          this.playerCredits = savedData.playerCredits;
          this.wins = savedData.wins;
          this.games = savedData.games;
          this.playerLevel = savedData.playerLevel || 1;
          this.playerXP = savedData.playerXP || 0;
          this.xpToNextLevel = savedData.xpToNextLevel || 100;
          this.powerUps = savedData.powerUps || { extraCard: 0, peekDealer: 0, shieldLoss: 0, bomb: 0, freeze: 0, doubleXP: 0 };
          this.purchasedSkins = savedData.purchasedSkins || ['default'];
          this.activeCardSkin = savedData.activeCardSkin || 'default';
          this.campaignProgress = savedData.campaignProgress || {
            currentLevel: 0,
            unlockedDealers: ['novice'],
            streaks: { quickPlay: 0, campaign: 0 },
            bestStreak: 0,
            totalBlackjacks: 0,
            totalBusts: 0,
            totalSplits: 0,
            dealerWins: {}, // Initialize if not present
            rogueModeUnlocked: false // Initialize if not present
          };
          // Initialize dealerWins for all dealers if not present
          this.dealers.forEach(dealer => {
            if (!this.campaignProgress.dealerWins[dealer.id]) {
              this.campaignProgress.dealerWins[dealer.id] = 0;
            }
          });
          
          // Load Cyber Nexus Pass data (NEW)
          if (savedData.cyberNexusPass) {
              this.cyberNexusPass = savedData.cyberNexusPass;
              // Convert expiryDate back to Date object if it was stored as string
              if (typeof this.cyberNexusPass.expiryDate === 'string') {
                  this.cyberNexusPass.expiryDate = new Date(this.cyberNexusPass.expiryDate);
              }
              if (typeof this.cyberNexusPass.lastLoginDate === 'string') {
                  this.cyberNexusPass.lastLoginDate = new Date(this.cyberNexusPass.lastLoginDate);
              }
          }

          // NEW: LOAD ABILITY USAGE FROM SAVED DATA IF AVAILABLE
          if (savedData.dealerAbilities) { 
              // Iterate over the `dealers` array which is the source of truth for dealer objects
              this.dealers.forEach(dealer => { 
                  // Check if the current dealer has a unique ability AND if there's saved data for it
                  if (dealer.uniqueAbility && savedData.dealerAbilities[dealer.id]) { 
                      // Update the `usedThisGame` flag from the saved data
                      dealer.uniqueAbility.usedThisGame = savedData.dealerAbilities[dealer.id].usedThisGame; 
                  }
                   // ADD THIS NEW BLOCK:
                if (dealer.secondaryAbility && savedData.dealerAbilities[dealer.id] && savedData.dealerAbilities[dealer.id].secondaryUsedThisGame !== undefined) {
                    dealer.secondaryAbility.usedThisGame = savedData.dealerAbilities[dealer.id].secondaryUsedThisGame;
                }
              });
          }
        } else {
            // If no saved data, ensure dealerWins is initialized for all base dealers
            this.dealers.forEach(dealer => {
                this.campaignProgress.dealerWins[dealer.id] = 0;
            });
        }
      },

      saveGameData: function() {
        // NEW: PREPARE ABILITY USAGE DATA TO SAVE
        const abilityUsageData = {}; 
        // Iterate over the `dealers` array to get the current state of unique abilities
        this.dealers.forEach(dealer => { 
            if (dealer.uniqueAbility) { 
                // Store only the `usedThisGame` flag for each dealer's unique ability
                abilityUsageData[dealer.id] = {
                    usedThisGame: dealer.uniqueAbility.usedThisGame 
                };
            }
             // ADD THIS BLOCK FOR SECONDARY ABILITY DATA:
            if (dealer.secondaryAbility) {
                // Ensure the dealer's entry in abilityUsageData exists.
                // It might already exist from uniqueAbility, or need to be created.
                if (!abilityUsageData[dealer.id]) {
                    abilityUsageData[dealer.id] = {};
                }
                // Store secondary ability status under a distinct key
                abilityUsageData[dealer.id].secondaryUsedThisGame = dealer.secondaryAbility.usedThisGame;
            }
        // END OF BLOCK TO ADD
        });
        const gameData = { 
          playerCredits: this.playerCredits,
          wins: this.wins,
          games: this.games,
          playerLevel: this.playerLevel,
          playerXP: this.playerXP,
          xpToNextLevel: this.xpToNextLevel,
          powerUps: this.powerUps,
          purchasedSkins: this.purchasedSkins,
          activeCardSkin: this.activeCardSkin,
          campaignProgress: this.campaignProgress,
          dealerAbilities: abilityUsageData,
          cyberNexusPass: { // Save Cyber Nexus Pass data (NEW)
              active: this.cyberNexusPass.active,
              expiryDate: this.cyberNexusPass.expiryDate ? this.cyberNexusPass.expiryDate.toISOString() : null,
              weeklyCosmeticClaimed: this.cyberNexusPass.weeklyCosmeticClaimed,
              lastLoginDate: this.cyberNexusPass.lastLoginDate ? this.cyberNexusPass.lastLoginDate.toISOString() : null,
              consecutiveWeeks: this.cyberNexusPass.consecutiveWeeks,
              currentWeeklyCosmetic: this.cyberNexusPass.currentWeeklyCosmetic
          }
        };
        localStorage.setItem('cyberBlackjackGameData', JSON.stringify(gameData));
      },

      updateUI: function() {
        this.elements.creditsDisplay.textContent = this.playerCredits;
        this.elements.winsDisplay.textContent = this.wins;
        this.elements.gamesDisplay.textContent = this.games;
        this.elements.playerLevelDisplay.textContent = this.playerLevel;
        this.elements.xpBarFill.style.width = (this.playerXP / this.xpToNextLevel) * 100 + '%';
        
        if (this.elements.playerXPSpan) {
            this.elements.playerXPSpan.textContent = this.playerXP;
        } else {
            console.error("player-xp span not found!");
        }
        if (this.elements.xpToNextSpan) {
            this.elements.xpToNextSpan.textContent = this.xpToNextLevel;
        } else {
            console.error("xp-to-next span not found!");
        }

        this.updatePowerUpButtons();
        this.updateCardSkin();
        this.updateStatsScreen();
        this.updateLeaderboard();
        this.updateCyberNexusPassUI(); // Update pass UI
      },

      updateCardSkin: function() {
        // Ensure activeCardSkin is a valid ID before trying to find it
        const activeSkin = this.cardSkins.find(skin => skin.id === this.activeCardSkin);
        if (activeSkin) {
            document.documentElement.style.setProperty('--card-back-color', activeSkin.color);
        } else {
            // Fallback to default if active skin is not found (e.g., after data corruption)
            document.documentElement.style.setProperty('--card-back-color', this.cardSkins.find(skin => skin.id === 'default').color);
            this.activeCardSkin = 'default';
        }
      },

      levelUp: function() {
        this.playerLevel++;
        this.playerXP = 0;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5); 
        this.playerCredits += 500; 
        this.showGameMessage(`LEVEL UP! You are now Level ${this.playerLevel}! +500 Credits!`, 'win');
        this.playSFX('sfx-levelUp'); // Play level up sound
        this.saveGameData();
        this.updateUI();
        this.setupDealers(); // Re-render dealers to show newly unlocked ones
        this.checkRogueModeUnlockConditions(); // Check unlock conditions on level up
      },

      addXP: function(amount) {
        let xpGained = amount;
        if (this.powerUps.doubleXP > 0) {
            xpGained *= 2;
            this.powerUps.doubleXP--; 
            this.updatePowerUpButtons();
            this.showGameMessage('2x XP Booster activated!', 'win');
        }
        // Apply Cyber Nexus Pass XP bonus (NEW)
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            xpGained *= (1 + this.cyberNexusPassDetails.xpBonus);
            this.showGameMessage(`Cyber Nexus Pass XP Bonus: +${(this.cyberNexusPassDetails.xpBonus * 100).toFixed(0)}% XP!`, 'win');
        }

        this.playerXP += xpGained;
        if (this.playerXP >= this.xpToNextLevel) {
          this.levelUp();
        }
        this.updateUI();
      },

      showGameMessage: function(message, type = '') {
        this.elements.messageArea.textContent = message;
        this.elements.messageArea.className = `message ${type}`; 
        this.elements.messageArea.classList.remove('hidden');
      },
      // PLACE THE activateAbility FUNCTION IMMEDIATELY AFTER THE showGameMessage FUNCTION:
     activateAbility: function(abilityObj) { // Corrected parameter name to abilityObj
        if (!abilityObj) {
            console.warn('Attempted to activate a null or undefined ability object.');
            return;
        }
        // Check if the ability has already been used this game
        if (abilityObj.usedThisGame) {
            console.log(`Ability ${abilityObj.name} (ID: ${abilityObj.id}) already used this game.`);
            return;
        }

        const playerTotal = this.getHandValue(this.playerHand);
        const dealerTotal = this.getHandValue(this.dealerHand);

        switch(abilityObj.id) { // Use abilityObj.id for the switch
            case 'aggressive_ability': // Neon Nighthawk's aggressive bet logic
                const forcedBetAmount = this.currentBet * 2;
                if (this.playerCredits >= forcedBetAmount) {
                    // Deduct the *additional* amount for the double bet from player credits
                    this.playerCredits -= this.currentBet; 
                    this.currentBet = forcedBetAmount; // Update the current bet to the doubled amount
                    this.showGameMessage('NEON NIGHTHAWK FORCES AN AGGRESSIVE BET! YOUR BET DOUBLED!', 'lose');
                    this.elements.betAmountInput.value = this.currentBet; // Update bet input visually
                } else {
                    this.showGameMessage('NEON NIGHTHAWK FAILED TO FORCE BET! Not enough credits!', 'win'); // Player "wins" by avoiding it
                    abilityObj.usedThisGame = false; // Don't mark as used if it couldn't apply
                    this.saveGameData(); // Save the state
                    return; // Exit without marking as used
                }
                break;
                case 'temporal_flux': // THE QUANTUM QUASAR: TEMPORAL FLUX
                const playerHandValue = this.getHandValue(this.playerHand);
                // This ability is typically triggered only if player's initial hand is 20 or 21.
                // The check for 20/21 would be in the calling context (e.g., startGame).
                // Here, we just execute the effect.
                if (this.playerHand.length > 1) { // Ensure player has at least two cards to discard one
                    const cardToDiscardIndex = Math.floor(Math.random() * this.playerHand.length); // Pick a random card to discard
                    const discardedCard = this.playerHand.splice(cardToDiscardIndex, 1)[0]; // Remove the card
                    const newCard = this.dealCard(); // Draw a new card
                    
                    // If low visibility is active, keep the new card face down
                    if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
                        newCard.isFaceDown = true;
                    }
                    
                    this.playerHand.push(newCard); // Add the new card

                    this.showGameMessage(`THE QUANTUM QUASAR INITIATES TEMPORAL FLUX! You discarded a ${discardedCard.rank} and drew a new card!`, 'lose');
                    this.updateHandsDisplay(); // Update display with the new hand
                    triggerScreenShake(); // Add a visual effect
                } else {
                    // This scenario should ideally not happen if triggered correctly after initial deal,
                    // but it's a safeguard.
                    this.showGameMessage('Temporal Flux failed to apply (player had too few cards).', 'win');
                    abilityObj.usedThisGame = false; // Don't mark as used if it couldn't apply
                    return; // Exit without marking as used
                }
                break;

            case 'entropy_cascade': // ZENITH'S ENTROPY CASCADE IMPLEMENTATION
                this.playerHand.forEach(card => {
                    if (card.rank !== 'A') { // Don't scramble Aces for simplicity
                        card.originalValue = card.value; // Store original value (CRUCIAL for reversion)
                        card.value = Math.floor(Math.random() * 10) + 1; // Assign a random value 1-10
                    }
                });
                this.isPlayerCardsScrambled = true; // Set a flag to indicate the effect is active (CRUCIAL for reversion)
                this.showGameMessage('ZENITH ACTIVATES ENTROPY CASCADE! YOUR CARD VALUES ARE SCRAMBLED!', 'special');
                this.updateHandsDisplay(); // Update display to reflect scrambled values
                break;

            case 'phantom_echo': // SHADOW WEAVER'S PHANTOM ECHO IMPLEMENTATION
                const phantomValue = (Math.random() < 1.0) ? -5 : 5; // 50% chance for -5 or +5
                const phantomCard = {
                    rank: 'PHANTOM',
                    suit: 'ECHO',
                    value: phantomValue,
                    isPhantom: true // Custom property to identify it
                };
                this.playerHand.push(phantomCard);
                this.showGameMessage(`SHADOW WEAVER SUMMONS A PHANTOM ECHO! YOU GAINED ${phantomValue} VALUE!`, 'special');
                this.updateHandsDisplay(); // Update display to show the new card
                break;

            case 'credit_lockdown': // OMEGA'S CREDIT LOCKDOWN IMPLEMENTATION
                const lockdownAmount = Math.floor(this.playerCredits * 0.2); // Lock 20% of credits
                this.playerCreditsLocked = lockdownAmount; // Store the amount locked (CRUCIAL for reversion)
                this.playerCredits -= lockdownAmount; // Deduct from active credits (adjust based on your 'playerCredits' definition)
                this.showGameMessage(`OMEGA INITIATES CREDIT LOCKDOWN! ${lockdownAmount} CREDITS LOCKED!`, 'lose');
                this.updateUI(); // Update UI to show new credit balance
                break;

            case 'system_override': // OMEGA'S SYSTEM OVERRIDE
                this.showGameMessage('OMEGA INITIATES SYSTEM OVERRIDE!', 'lose');
                triggerScreenShake(); // Assuming triggerScreenShake() is defined globally or within game object

                // Replace a random player card
                const playerCardToRemoveIndex = this.playerHand.length > 1 ? Math.floor(Math.random() * this.playerHand.length) : 0;
                if (this.playerHand.length > 0) {
                    this.playerHand.splice(playerCardToRemoveIndex, 1);
                    this.playerHand.push(this.dealCard());
                } else {
                    this.playerHand.push(this.dealCard());
                }

                // Replace a random dealer card
                const dealerCardToRemoveIndex = this.dealerHand.length > 1 ? Math.floor(Math.random() * this.dealerHand.length) : 0;
                if (this.dealerHand.length > 0) {
                    this.dealerHand.splice(dealerCardToRemoveIndex, 1);
                    this.dealerHand.push(this.dealCard());
                } else {
                    this.dealerHand.push(this.dealCard());
                }

                this.updateHandsDisplay();
                break;

            case 'master_ability': // ZENITH: ADAPTIVE STRATEGY
                const originalStrategy = this.currentDealer.strategy;
                // Temporarily set a more aggressive or optimal strategy
                if (dealerTotal < 17 && playerTotal > dealerTotal) {
                    this.currentDealer.strategy = 'optimal'; // Aim for 21 if behind
                } else {
                    this.currentDealer.strategy = 'aggressive'; // Take more risks
                }
                this.showGameMessage(`ZENITH ACTIVATES ADAPTIVE STRATEGY! Dealer strategy is now ${this.currentDealer.strategy}!`, 'special');
                // This ability will be reverted in `dealerTurn` once the turn concludes.
                break;

            case 'glitch_ability': // THE GLITCH: DATA CORRUPTION
                this.showGameMessage('THE GLITCH CORRUPTS DATA! DEALER\'S CARD VALUES SCRAMBLED!', 'tie');
                this.dealerHand.forEach(card => {
                    if (card.originalValue === undefined) {
                        card.originalValue = card.value;
                    }
                    card.glitchedValue = Math.floor(Math.random() * 11) + 1; // Assign random glitched value
                });
                this.updateHandsDisplay(); // Update display to show '??' or glitched values
                break;

            case 'novice_ability': // CYPHER-BOT 7: RESERVE CARD
                // This ability is checked and applied within dealerTurn
                break;
            case 'conservative_ability': // DATA-SAMURAI: FOCUSED DRAW
                // This ability is checked and applied within dealerTurn
                break;
            case 'calculating_ability': // THE QUANTUM QUASAR: CARD PREDICTION
                // This ability is checked and applied within dealerTurn
                break;
            case 'expert_ability': // SHADOW WEAVER: HIDDEN CARD SWAP
                // This ability is checked and applied within dealerTurn
                break;

            default:
                console.warn('Unknown ability ID or no specific logic for:', abilityObj.id);
                break;
        }
        abilityObj.usedThisGame = true; // Mark as used for this game
        this.saveGameData();
        this.updateUI();     // Ensure UI is updated after ability
    },
      hideGameMessage: function() {
        this.elements.messageArea.classList.add('hidden');
      },

      showScreen: function(screenId) {
        console.log(`Attempting to show screen: ${screenId}`);
        document.querySelectorAll('.screen').forEach(screen => {
          screen.classList.add('hidden');
        });
        const targetScreen = document.getElementById(screenId);
        if (targetScreen) {
          targetScreen.classList.remove('hidden');
          // Determine display style based on screenId or its CSS class
          if (['main-menu', 'campaign-section', 'shop-screen', 'stats-screen', 'pvp-lobby'].includes(screenId)) {
              targetScreen.style.display = 'flex';
          } else if (screenId === 'betting-section' || screenId === 'game-area') {
              targetScreen.style.display = 'block'; // Betting and Game area typically block or flex-column
          } else {
              targetScreen.style.display = ''; // Default or fall back
          }
          console.log(`Screen '${screenId}' display style set to: ${targetScreen.style.display}`);
        } else {
          console.error(`Error: Screen with ID '${screenId}' not found!`);
        }
        // --- NEW CODE STARTS HERE: Setting this.isBrawl based on screenId ---
        if (screenId === 'pvp-lobby' || (screenId === 'game-area' && this.isBrawl)) { // Keep isBrawl true if already set for game-area
            this.isBrawl = true;
            console.log(`[showScreen] isBrawl set to TRUE for screen: ${screenId}`);
        }
        else if (['main-menu', 'campaign-section', 'shop-screen', 'stats-screen'].includes(screenId)) {
            this.isBrawl = false;
            console.log(`[showScreen] isBrawl set to FALSE for screen: ${screenId}`);
        }
        else if (screenId === 'betting-section') {
            // isBrawl should have been set by startBrawlMode or showQuickPlay/selectCampaignDealer before this.
            // If it's betting-section, maintain the previous isBrawl state.
            console.log(`[showScreen] isBrawl maintained for betting-section: ${this.isBrawl}`);
        }
        // --- NEW CODE ENDS HERE ---
        console.log(`[showScreen] Final this.isBrawl state before HUD logic: ${this.isBrawl} (for screen: ${screenId})`);

        if (screenId === 'betting-section' && this.currentDealer) {
            this.updateCurrentDealerInfo();
            document.getElementById('current-dealer-info').classList.remove('hidden');
        } else {
            document.getElementById('current-dealer-info').classList.add('hidden');
        }

       // Controls visibility of Brawl Mode HUD elements based on whether game is in Brawl Mode
        if (!this.isBrawl) { // Only hide if not in brawl mode at all
            this.elements.brawlHud.classList.add('hidden');
            this.elements.brawlSpecialControls.classList.add('hidden'); // Corrected from 'shown' to 'hidden'
            console.log(`[showScreen] Hiding Brawl HUD/Controls because not in Brawl Mode. screenId: ${screenId}, isBrawl: ${this.isBrawl}`);
        } else { // If in brawl mode, ensure they are visible
            this.elements.brawlHud.classList.remove('hidden');
            this.elements.brawlSpecialControls.classList.remove('hidden');
            console.log(`[showScreen] Showing Brawl HUD/Controls because in Brawl Mode. screenId: ${screenId}, isBrawl: ${this.isBrawl}`);
        }

        if (screenId !== 'game-area') {
            this.elements.postGameControls.classList.add('hidden');
            this.elements.riskResult.classList.add('hidden');
        }
      },

      // Navigation functions
      showQuickPlay: function() {
        this.isBrawl = false;
        this.currentDealer = null; 
        this.currentDealerId = null; 
        this.isRogueModeActive = false; // Ensure rogue mode is off
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.resetDeck(); 
        this.showScreen('betting-section');
        // Reset background to default for quick play
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB')`;
        // Stop dealer music if playing
        if (this.elements.dealerMusic) {
            this.elements.dealerMusic.pause();
            this.elements.dealerMusic.currentTime = 0;
        }
      },

      showCampaign: function() {
        console.log("Entering showCampaign function.");
        this.isBrawl = false;
        this.isRogueModeActive = false; // Ensure rogue mode is off for regular campaign
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.setupDealers(); // Render regular dealers and rogue mode button
        this.showScreen('campaign-section');
        // Reset background to default for campaign selection
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CAMPAIGN+SELECT')`;
        // Stop dealer music if playing
        if (this.elements.dealerMusic) {
            this.elements.dealerMusic.pause();
            this.elements.dealerMusic.currentTime = 0;
        }
      },

      selectCampaignDealer: function(dealerId) {
        // If in rogue mode, select from rogueDealers, else from regular dealers
        let dealerList = this.isRogueModeActive ? this.rogueDealers : this.dealers;
        this.currentDealer = dealerList.find(d => d.id === dealerId);
        this.currentDealerId = dealerId; 

        if (this.currentDealer && this.currentDealer.unlocksAtLevel > this.playerLevel && !this.isRogueModeActive) { // Regular campaign unlock check
            this.showGameMessage(`You need to be Level ${this.currentDealer.unlocksAtLevel} to challenge ${this.currentDealer.name}!`, 'lose');
            return;
        }
        
        if (!this.currentDealer) {
            console.error(`Dealer with ID ${dealerId} not found.`);
            this.showGameMessage('Error: Dealer not found. Please try again.', 'lose');
            return;
        }


        this.isBrawl = false; 
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.resetDeck(); 
        this.showScreen('betting-section');
        this.updateCurrentDealerInfo();
        // Play dealer music
        if (this.elements.dealerMusic) {
            // Check if music exists before setting src
            if (this.currentDealer.music) {
                this.elements.dealerMusic.src = this.currentDealer.music; 
                try {
                    this.elements.dealerMusic.play().catch(e => {
                        console.error("Failed to play dealer music:", e);
                    });
                } catch (e) {
                    console.error("Error attempting to play dealer music:", e);
                }
            } else {
                console.warn(`No music defined for dealer ${this.currentDealer.name}.`);
                this.elements.dealerMusic.pause();
                this.elements.dealerMusic.currentTime = 0;
            }
        } else {
            console.warn("Dealer music element not found.");
        }
        
        // Update dealer room background
        if (this.currentDealer.roomImage) {
            this.elements.dealerRoomBg.style.backgroundImage = `url('${this.currentDealer.roomImage}')`;  this.elements.dealerRoomBg.style.backgroundSize = 'cover';
            this.elements.dealerRoomBg.style.backgroundPosition = 'center center';
            this.elements.dealerRoomBg.style.backgroundRepeat = 'no-repeat';
        } else {
            console.warn(`No room image defined for dealer ${this.currentDealer.name}. Using default background.`);
            this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB')`;
        }
      },

      updateCurrentDealerInfo: function() {
        if (!this.currentDealer) {
            this.elements.currentDealerInfo.classList.add('hidden');
            return;
        }
        // Ensure elements exist before trying to append or update them
        if (!this.elements.currentDealerAvatarContainer) { // Use a new container to differentiate
            this.elements.currentDealerAvatarContainer = document.createElement('div');
            this.elements.currentDealerAvatarContainer.classList.add('current-dealer-avatar');
            this.elements.currentDealerAvatar = document.createElement('img'); // Create img element
            this.elements.currentDealerAvatar.alt = "Dealer Avatar";
            this.elements.currentDealerAvatarContainer.appendChild(this.elements.currentDealerAvatar);
            
            this.elements.currentDealerName = document.createElement('span');
            
            this.elements.currentDealerInfo.appendChild(this.elements.currentDealerAvatarContainer);
            this.elements.currentDealerInfo.appendChild(this.elements.currentDealerName);
        }
        // --- MODIFIED TO USE IMG TAG FOR CURRENT DEALER INFO ---
        // Added onerror to handle cases where the image path is broken
        this.elements.currentDealerAvatar.src = this.currentDealer.avatarSrc;
        this.elements.currentDealerAvatar.onerror = function() {
            this.onerror = null; // Prevents infinite loop if fallback also fails
            this.src = 'https://placehold.co/80x80/333/666?text=X'; 
            console.error(`Failed to load ${this.currentDealer.avatarSrc}`);
        };
        this.elements.currentDealerAvatarContainer.style.borderColor = this.currentDealer.color;
        // --- END MODIFIED FOR CURRENT DEALER INFO ---
        this.elements.currentDealerName.textContent = this.currentDealer.name;
        this.elements.currentDealerInfo.classList.remove('hidden');
      },

      startBrawlMode: function() {
        this.isBrawl = true;
        this.isRogueModeActive = false; // Brawl is a distinct mode, not rogue mode
        this.playerHP = 100;
        this.specialCharge = 0;
        this.ultimateCharge = 0; 
        
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.resetDeck(); 
         // --- CORRECTED LOGIC STARTS HERE ---
        if (this.dealers && this.dealers.length > 0) {
            // In brawl mode, automatically select a random dealer
            this.currentDealer = this.dealers[Math.floor(Math.random() * this.dealers.length)];
            this.currentDealerId = this.currentDealer.id;

            // ENSURE DEALER HP IS SET FROM THE SELECTED DEALER'S STATS
            this.dealerHP = this.currentDealer.hp;

            // ADD A CONSOLE LOG FOR DEBUGGING TO CONFIRM DEALER SELECTION
            console.log("BRAWL MODE: SELECTED DEALER:", this.currentDealer.name, "with HP:", this.dealerHP);

            // CALL UPDATEBRAWLHUD *AFTER* DEALER HP IS CORRECTLY SET
            this.updateBrawlHUD();

            this.showScreen('betting-section'); // Go to betting section with the selected dealer
            this.updateCurrentDealerInfo(); // Update dealer info for brawl as well

            // Update dealer room background for brawl
            if (this.currentDealer.roomImage) {
                this.elements.dealerRoomBg.style.backgroundImage = `url('${this.currentDealer.roomImage}')`;
                this.elements.dealerRoomBg.style.backgroundSize = 'cover';
                this.elements.dealerRoomBg.style.backgroundPosition = 'center center';
                this.elements.dealerRoomBg.style.backgroundRepeat = 'no-repeat';
            }
            // Play dealer music for brawl
            if (this.elements.dealerMusic && this.currentDealer.music) {
                this.elements.dealerMusic.src = this.currentDealer.music;
                try {
                    this.elements.dealerMusic.play().catch(e => {
                        console.error("Failed to play dealer music in brawl:", e);
                    });
                } catch (e) {
                    console.error("Error attempting to play dealer music in brawl:", e);
                }
            }
        } else {
            console.error("NO DEALERS AVAILABLE FOR BRAWL MODE!");
            this.showGameMessage("ERROR: NO DEALERS AVAILABLE FOR BRAWL MODE. RETURNING TO MENU.", "lose");
            this.backToMenu(); // ASSUMING YOU HAVE A BACKTOMENU FUNCTION
            return; // EXIT THE FUNCTION IF NO DEALERS
        }
    // --- CORRECTED LOGIC ENDS HERE ---

}, // End of startBrawlMode function

      updateBrawlHUD: function() {
        this.elements.brawlHud.classList.remove('hidden');
        this.elements.brawlSpecialControls.classList.remove('hidden');
        this.elements.playerHpBar.style.width = Math.max(0, this.playerHP) + '%';
        this.elements.dealerHpBar.style.width = Math.max(0, this.dealerHP) + '%';
        this.elements.playerHpText.textContent = this.playerHP;
        this.elements.dealerHpText.textContent = this.dealerHP;
        this.elements.specialChargeBarFill.style.width = this.specialCharge + '%';
        this.elements.specialChargeText.textContent = `${this.specialCharge}% Special`;
        this.elements.ultimateChargeBarFill.style.width = this.ultimateCharge + '%';
        this.elements.ultimateChargeText.textContent = `${this.ultimateCharge}% Ultimate`;

        this.elements.specialAttackBtn.disabled = this.specialCharge < 100;
        this.elements.ultimateBtn.disabled = this.ultimateCharge < 100;
      },

      openShopScreen: function() {
        this.elements.shopCredits.textContent = this.playerCredits;
        this.setupShop(); 
        this.showScreen('shop-screen');
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/000000/ff69b4?text=CYBER+SHOP')`;
        // Stop dealer music if playing
        if (this.elements.dealerMusic) {
            this.elements.dealerMusic.pause();
            this.elements.dealerMusic.currentTime = 0;
        }
      },

      openStatsScreen: function() {
        this.updateStatsScreen();
        this.updateLeaderboard();
        this.showScreen('stats-screen');
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffdd?text=PLAYER+STATS')`;
        // Stop dealer music if playing
        if (this.elements.dealerMusic) {
            this.elements.dealerMusic.pause();
            this.elements.dealerMusic.currentTime = 0;
        }
      },

     startPvP: function() {
    console.log('Entering PvP Online lobby...');
    this.showScreen('pvp-lobby');
    this.elements.pvpStatus.textContent = 'Searching for opponent...';

    // This line connects to your Socket.IO server.
    // When deploying, you'll need to specify your server's URL here if it's not on the same host/port.
    this.socket = io('http://localhost:3000'); 

    // This line sends a request to the server to find a match.
    this.socket.emit('requestMatch');

    // This block listens for a 'matchFound' event from the server.
    this.socket.on('matchFound', (opponentId) => {
        this.elements.pvpStatus.textContent = `Match found! Opponent: ${opponentId}. Starting game...`;
        setTimeout(() => {
            this.isPvPMode = true;
            this.opponentId = opponentId;
            this.startGame(true);
            this.hideGameMessage();
        }, 2000);
    });

    // This block listens for a 'noMatch' event from the server.
    this.socket.on('noMatch', () => {
        this.elements.pvpStatus.textContent = 'No opponent found. Try again later.';
    });

    // This block will receive real-time game state updates from the server.
    this.socket.on('pvpGameUpdate', (data) => {
        console.log('Received PvP game update:', data);
         // This is where you will implement logic to update the local game state
        // based on the opponent's actions received from the server.
          // START_OF_PVPGAMEUPDATE_LOGIC

        // 1. Update Game State Variables
        if (data.playerState) {
            this.playerHand = data.playerState.hand;
            this.playerTotal = data.playerState.score;
            this.renderCards(this.playerHand, this.elements.playerHand);
            this.elements.playerTotal.textContent = `Score: ${this.playerTotal}`;
        }

        if (data.opponentState) {
            this.opponentHand = data.opponentState.hand;
            this.opponentTotal = data.opponentState.score;
            // Assuming you have an elements.opponentHand element
            this.renderCards(this.opponentHand, this.elements.opponentHand, data.opponentState.hideFirstCard);
            this.elements.opponentTotal.textContent = `Opponent Score: ${this.opponentTotal}`;
        }

        if (data.dealerState) {
            this.dealerHand = data.dealerState.hand;
            this.dealerTotal = data.dealerState.score;
            this.renderCards(this.dealerHand, this.elements.dealerHand, data.dealerState.hideSecondCard);
            this.elements.dealerTotal.textContent = `Score: ${this.dealerTotal}`;
        }

        // 2. Manage Player Controls (Hit, Stand, Double Down, Power-ups)
        // Assuming 'this.playerId' is set on connection and 'data.currentTurn' comes from server
        if (data.currentTurn === this.playerId) {
            this.enablePlayerActions(); // You'll need to implement this function
            this.showGameMessage('Your turn!', 'info');
        } else {
            this.disablePlayerActions(); // You'll need to implement this function
            this.showGameMessage(`Opponent's turn!`, 'info');
        }

        // 3. Display Game Messages
        if (data.message) {
            this.showGameMessage(data.message, data.messageType || 'info');
        } // ALL_CAPS_START_NEW_VISUAL_FEEDBACK_LOGIC

    // Prioritize displaying whose turn it is first
    if (data.currentTurn === this.playerId) {
        this.showGameMessage('Your turn!', 'info');
    } else if (data.currentTurn === this.opponentId) {
        // Assuming 'this.opponentId' is set when a match is found
        this.showGameMessage("Opponent's turn...", 'info');
    } else if (data.currentTurn === 'dealer') { // If your server sends 'dealer' for dealer's turn
        this.showGameMessage("Dealer's turn...", 'info');
    }

    // Then, display specific action messages sent by the server.
    // This helps differentiate between a turn change and an action like 'Opponent hits'.
    if (data.message && this.elements.gameMessage.textContent !== data.message) {
        // The condition `this.elements.gameMessage.textContent !== data.message`
        // prevents showing the same message repeatedly if the server sends it on every update.
        this.showGameMessage(data.message, data.messageType || 'info');
    }

    // ALL_CAPS_END_NEW_VISUAL_FEEDBACK_LOGIC


        // 4. Handle End of Round/Game State
        if (data.gameOver) {
            this.showGameMessage(data.gameOverMessage, data.gameOverType);
            this.disablePlayerActions(); // Ensure actions are disabled after game over
        }

        // 5. Update other UI elements as needed (e.g., bets, chips, power-up states)
        if (data.playerChips !== undefined) {
            this.elements.chipsDisplay.textContent = `Chips: ${data.playerChips}`;
        }
        // You might also update power-up displays here based on data.playerState.powerUps

        // END_OF_PVPGAMEUPDATE_LOGIC
      });

    // This block listens for a 'pvpGameOver' event from the server.
    this.socket.on('pvpGameOver', (data) => {
        this.showGameMessage(data.message, data.type);
        this.isPvPMode = false;
        this.opponentId = null;
        this.socket.disconnect();
    });     
},
      // ALL_CAPS_START_NEW_PLAYER_ACTION_METHODS_INSERTION

    // This function enables all player action buttons.
    enablePlayerActions: function() {
        if (this.elements.hitButton) {
            this.elements.hitButton.disabled = false;
        }
        if (this.elements.standButton) {
            this.elements.standButton.disabled = false;
        }
        if (this.elements.doubleDownButton) {
            this.elements.doubleDownButton.disabled = false;
        }
        // Assuming your power-up button or buttons are accessible via this.elements
        // You might need to add specific IDs to your power-up buttons in HTML
        // For example, if you have a button with id="player-power-up-btn"
        if (this.elements.usePowerUpButton) { 
            this.elements.usePowerUpButton.disabled = false;
        }
        // Add any other action buttons you have here that need enabling/disabling
    },

    // This function disables all player action buttons.
    disablePlayerActions: function() {
        if (this.elements.hitButton) {
            this.elements.hitButton.disabled = true;
        }
        if (this.elements.standButton) {
            this.elements.standButton.disabled = true;
        }
        if (this.elements.doubleDownButton) {
            this.elements.doubleDownButton.disabled = true;
        }
        // Assuming your power-up button or buttons are accessible via this.elements
        if (this.elements.usePowerUpButton) {
            this.elements.usePowerUpButton.disabled = true;
        }
        // Add any other action buttons you have here that need enabling/disabling
    }, // ALL_CAPS_START_NEW_USER_EXPERIENCE_ENHANCEMENT_CODE

    // This function allows a player to cancel out of PvP matchmaking.
    cancelPvPMatchmaking: function() {
        console.log('Cancelling PvP matchmaking...');
        if (this.socket) {
            // Inform the server that this client is canceling matchmaking.
            // Your server will need to listen for a 'cancelMatchmaking' event
            // and remove the player from any matchmaking queues.
            this.socket.emit('cancelMatchmaking');
            
            // Disconnect the socket as the player is leaving the PvP lobby.
            this.socket.disconnect();
        }
        // Return the user to the main menu screen.
        this.showScreen('main-menu');
        this.showGameMessage('Matchmaking cancelled.', 'info');
        // Clear any lingering PvP status messages.
        this.elements.pvpStatus.textContent = '';
    },

    // ALL_CAPS_END_NEW_USER_EXPERIENCE_ENHANCEMENT_CODE

// ALL_CAPS_END_NEW_PLAYER_ACTION_METHODS_INSERTION
      cancelPvP: function() {
        this.showGameMessage('PvP search cancelled.', '');
        this.backToMenu();
      },

      backToMenu: function() {
        this.showScreen('main-menu');
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden');
        this.isGameActive = false;
        this.isRogueModeActive = false; // Reset rogue mode on going back to main menu
        if (this.elements.dealerMusic) {
          this.elements.dealerMusic.pause();
          this.elements.dealerMusic.currentTime = 0;
        }
        // Reset active brawl rule when leaving brawl mode
        if (this.activeBrawlRule && this.activeBrawlRule.revert) { // Revert any active rule
            this.activeBrawlRule.revert();
        }
        this.activeBrawlRule = null;
        // Reset background to default when returning to main menu
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB')`;
      },

      resetAllDataConfirmation: function() {
        this.showGameMessage('Are you sure? Click "Reset Game Data" again to confirm!', 'lose');
        // Temporarily change the onclick for the specific button
        const resetButton = this.elements.mainMenu.querySelector('button[onclick="game.resetAllDataConfirmation()"]');
        if (resetButton) {
            resetButton.onclick = () => {
                localStorage.removeItem('cyberBlackjackGameData');
                location.reload(); 
            };
            // Revert the onclick after a delay if not confirmed
            setTimeout(() => {
                if (resetButton.onclick !== game.resetAllDataConfirmation) { // Check if it hasn't been clicked already
                    resetButton.onclick = () => game.resetAllDataConfirmation();
                    this.hideGameMessage(); 
                }
            }, 5000); 
        }
      },

      adjustBet: function(amount) {
        let currentBet = parseInt(this.elements.betAmountInput.value) || 0;
        let newBet = currentBet + amount;

        newBet = Math.max(10, newBet); 
        newBet = Math.min(this.playerCredits, newBet); 

        this.elements.betAmountInput.value = newBet;
      },

      betMax: function() {
        this.elements.betAmountInput.value = this.playerCredits;
      },
      resetHands: function() {
        // Clear the arrays holding the cards for both player and dealer
        this.playerHand = [];
        this.dealerHand = [];

        // Reset the numerical total of hands (assuming you have these properties)
        this.playerTotal = 0;
        this.dealerTotal = 0;
        
        // Clear the displayed cards and totals on the UI
        // (Ensure these elements are correctly cached in this.elements)
        if (this.elements.playerCardsDiv) {
            this.elements.playerCardsDiv.innerHTML = '';
        }
        if (this.elements.dealerCardsDiv) {
            this.elements.dealerCardsDiv.innerHTML = '';
        }
        if (this.elements.playerTotalDisplay) {
            this.elements.playerTotalDisplay.textContent = '0';
        }
        // For dealerTotalDisplay, you might only show 0 or partial info until their turn
        // You might want to handle this in updateHandsDisplay or updateUI for the dealer
        if (this.elements.dealerTotalDisplay) {
            this.elements.dealerTotalDisplay.textContent = '0'; // Or a placeholder like '?'
        }

        console.log("Hands have been reset."); // For debugging
      },

      resetDeck: function() {
        this.deck = this.createDeck();
        this.shuffleDeck();
        this.showGameMessage('New deck shuffled!', 'tie');
      },

      startGame: function() {
        console.log("startGame called.");
        // --- NEW: Select currentDealer for Brawl Mode if not already set or re-entering brawl game ---
        // Ensure a random dealer is selected for Brawl Mode if not already set by startBrawlMode call
        if (this.isBrawl && !this.currentDealer) {
            if (this.dealers && this.dealers.length > 0) {
                const randomIndex = Math.floor(Math.random() * this.dealers.length);
                this.currentDealer = this.dealers[randomIndex];
                // Set dealer HP based on the newly selected dealer
                this.dealerHP = this.currentDealer.hp; 
                console.log("Brawl Mode (startGame): Selected dealer", this.currentDealer.name, "with HP:", this.dealerHP);
                this.updateCurrentDealerInfo(); // Update current dealer display
            } else {
                console.error("Error: No dealers available to select for Brawl Mode!");
                this.showGameMessage("ERROR: No dealers available for Brawl Mode. Returning to menu.", "lose");
                this.backToMenu();
                return; // Prevent game from proceeding without a dealer
            }  
        }
        console.log(`[startGame] this.isBrawl value at start: ${this.isBrawl}`);
        // --- END NEW CODE ---
        // Ensure betAmountInput is correctly cached and has a value before parsing
        // This line assumes you have correctly set the id="bet-amount-input" in your HTML
        this.currentBet = parseInt(this.elements.betAmountInput.value);
        console.log("Current Bet:", this.currentBet);
        console.log("Player Credits:", this.playerCredits);

        // --- START: Bet Validation ---
        if (isNaN(this.currentBet) || this.currentBet <= 0) {
          this.showGameMessage('Please place a valid bet.', 'lose');
          console.log("Validation Failed: Invalid bet amount.");
          this.elements.betAmountInput.focus(); // Ensure input is focused for correction
          return;
        }
        if (this.playerCredits < this.currentBet) {
          this.showGameMessage('Not enough credits!', 'lose');
          console.log("Validation Failed: Insufficient credits.");
          this.elements.betAmountInput.focus(); // Ensure input is focused for correction
          return;
        }
        // --- END: Bet Validation ---
        
        // --- START: Crucial lines for disabling input and buttons immediately upon successful validation ---
        this.elements.betAmountInput.disabled = true;
        this.elements.dealBtn.disabled = true; // This will be re-enabled when gameControls becomes visible
        // --- END: Crucial lines ---

        // --- START: Deck and Hand Initialization ---
        if (!this.deck || this.deck.length < this.DECK_RELOAD_THRESHOLD) {
          this.resetDeck(); // Ensure deck is ready
        }

        this.playerCredits -= this.currentBet;
        this.playerHand = [];
        this.dealerHand = [];
        
        this.isGameActive = true;
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        // --- END: Deck and Hand Initialization ---

        // --- START: Round Specific Resets and Brawl Mode Rule Application ---
        // Reset hit counters for Limit Barriers hazard
        this.playerHitsThisRound = 0;
        this.dealerHitsThisRound = 0;
        this.isLimitBarrierActive = false; // Reset the flag

        // Revert any previously active brawl rule effects
        if (this.activeBrawlRule && this.activeBrawlRule.revert) {
            this.activeBrawlRule.revert();
        }
        this.activeBrawlRule = null; // Clear previous rule

        // NEW: Random Round Rules for Brawl Mode (25% chance to activate a random rule)
        if (this.isBrawl && Math.random() < 0.30) { 
          this.activeBrawlRule = this.brawlRules[Math.floor(Math.random() * this.brawlRules.length)];
          this.showGameMessage(this.activeBrawlRule.message, 'tie');
          if (this.activeBrawlRule.apply) {
            this.activeBrawlRule.apply();
          }
        } 

        if (this.isBrawl) {
            this.updateBrawlHUD(); 
        }
        // Reset all ability usage flags for the current dealer at the start of a new game/round
        // This 'if (this.currentDealer)' block handles dealer ability resets.
        if (this.currentDealer) { 
            if (this.currentDealer.uniqueAbility) {
                this.currentDealer.uniqueAbility.usedThisGame = false;
            }
            if (this.currentDealer.secondaryAbility) {
                this.currentDealer.secondaryAbility.usedThisGame = false;
            }

            // --- LOGIC FOR CHECKING AND TRIGGERING ABILITIES ---
            // Place this where you want abilities to potentially activate (e.g., at the start of a new round, or during the dealer's turn)
            // Ensure a dealer is loaded before checking abilities
            // *** 1. CHECK AND TRIGGER UNIQUE ABILITY (Pre-deal/Start of Round) ***
            if (this.currentDealer.uniqueAbility && !this.currentDealer.uniqueAbility.usedThisGame) {
                // Neon Nighthawk's 'aggressive_ability' trigger (now calls activateAbility)
                if (this.currentDealer.uniqueAbility.id === 'aggressive_ability' && Math.random() < 0.50) {
                    this.activateAbility(this.currentDealer.uniqueAbility); // CALL THE CENTRAL FUNCTION
                }
                // Example for Omega's unique ability ('system_override'):
                else if (this.currentDealer.uniqueAbility.id === 'system_override' && this.playerHand.length >= 2 && Math.random() < 1.0) { // Low chance for this
                    // For System Override, we need to defer activation until after initial cards are dealt
                    // or implement a separate phase. For now, it will apply to already dealt cards if triggered here.
                    // This is less ideal, but matches existing structure.
                    // A better approach would be to have a 'pre-round' ability phase.
                    console.log("System Override attempts to activate but might not have cards yet.");
                    // Defer this to after initial cards are dealt if it affects them, or keep it here for pre-game effects.
                    // For now, leaving it here as it was, but noting potential timing issues.
                    // It will be re-evaluated later in dealerTurn if needed.
                }
                // Zenith's Adaptive Strategy
                else if (this.currentDealer.uniqueAbility.id === 'master_ability' && Math.random() < 1.0) {
                     // This ability affects dealer's play strategy, often triggered during their turn.
                     // It can also be triggered at the start for a general "mood" for the round.
                     // We'll call activate, but its main effect is in dealerTurn.
                     this.activateAbility(this.currentDealer.uniqueAbility);
                }
                 // The Glitch's Data Corruption (pre-deal for visual)
                else if (this.currentDealer.uniqueAbility.id === 'glitch_ability' && Math.random() < 1.0) {
                     this.activateAbility(this.currentDealer.uniqueAbility);
                }
            }

            // *** 2. CHECK AND TRIGGER SECONDARY ABILITY (Pre-deal/Start of Round) ***
            if (this.currentDealer.secondaryAbility && !this.currentDealer.secondaryAbility.usedThisGame) {
                // Check for Omega's secondary ability: Credit Lockdown (often at start of round)
                if (this.currentDealer.secondaryAbility.id === 'credit_lockdown' && this.playerCredits > 500 && Math.random() < 1.0) { // Low chance
                    this.activateAbility(this.currentDealer.secondaryAbility); 
                }
                // Zenith's Entropy Cascade (often at start of round to scramble player cards)
                else if (this.currentDealer.secondaryAbility.id === 'entropy_cascade' && Math.random() < 1.0) {
                    this.activateAbility(this.currentDealer.secondaryAbility);
                }
                // Shadow Weaver's Phantom Echo (can be early in round)
                else if (this.currentDealer.secondaryAbility.id === 'phantom_echo' && Math.random() < 1.0) {
                    this.activateAbility(this.currentDealer.secondaryAbility);
                }
            }
        }
        // --- END: Round Specific Resets and Brawl Mode Rule Application ---

        // --- START: Screen transition and control visibility code (with element existence checks for robustness) ---
        // These lines hide the betting section and show the game area and its controls
        if (this.elements.bettingSection) {
            this.elements.bettingSection.classList.add('hidden'); // Hide betting section
        } else {
            console.error("Error: bettingSection element not found in cacheElements!");
        }

        if (this.elements.gameArea) {
            this.elements.gameArea.classList.remove('hidden'); // Show game area
        } else {
            console.error("Error: gameArea element not found in cacheElements!");
        }

        if (this.elements.gameControls) {
            this.elements.gameControls.classList.remove('hidden'); // Show game controls (Hit, Stand, Double, Deal)
        } else {
            console.error("Error: gameControls element not found in cacheElements!");
        }

        if (this.elements.powerupControls) {
            this.elements.powerupControls.classList.remove('hidden'); // Ensure power-up controls are visible
        } else {
            console.error("Error: powerupControls element not found in cacheElements!");
        }
        this.elements.postGameControls.classList.add('hidden'); // Ensure post-game controls are hidden
        // --- END: Screen transition and control visibility code ---

        // --- START: Critical game initialization steps ---
        this.resetHands(); // Ensure hands are completely cleared before dealing
        this.dealInitialCards(); // This deals the starting cards to player and dealer
        this.updateHandsDisplay(); // Update display for hands (used to be part of updateUI)
        this.updateUI(); // This updates all general UI elements like scores, credits, etc.
        // Removed sfx-dealCards as it's not defined in your audio elements, preventing error.
        console.log("Showing game-area."); // Confirming transition
        // --- END: Critical game initialization steps ---

        // --- START: Brawl Mode Specific Blackjack Bonus (added from your last snippet) ---
        if (this.isBrawl) {
            const playerTotal = this.getHandValue(this.playerHand);
            if (playerTotal === 21 && this.playerHand.length === 2) {
                this.playerHP = Math.min(100, this.playerHP + 50); 
                this.addCharge(0, 50); 
                this.showGameMessage('BLACKJACK! You gained 50 HP and 50 Ultimate Charge!', 'win');
                this.updateBrawlHUD(); 
                console.log("[startGame] updateBrawlHUD called."); 
            }
        }
        // --- PLACE THE NEW TEMPORAL FLUX ACTIVATION CODE HERE ---
        // THIS IS THE CORRECT SPOT:
        if (this.currentDealer && 
            this.currentDealer.id === 'calculating' && // Check if it's The Quantum Quasar
            this.currentDealer.secondaryAbility && 
            !this.currentDealer.secondaryAbility.usedThisGame && // Ensure it hasn't been used
            (this.getHandValue(this.playerHand) === 20 || this.getHandValue(this.playerHand) === 21) && // Player's initial hand is 20 or 21
            Math.random() < 1.0) { // 10% chance to activate
            
            this.activateAbility(this.currentDealer.secondaryAbility); 
        }
        // --- END OF TEMPORAL FLUX ACTIVATION CODE ---
        // --- END: Brawl Mode Specific Blackjack Bonus ---
      }, // <--- THIS IS THE FINAL CLOSING BRACE FOR THE 'startGame' FUNCTION
      createDeck: function() {
        const suits = ['â¤ï¸', 'â™¦ï¸', 'â™£ï¸', 'â™ ï¸'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const deck = [];
        for (const suit of suits) {
          for (const rank of ranks) {
            let value;
            if (rank === 'A') value = 11;
            else if (['K', 'Q', 'J'].includes(rank)) value = 10;
            else value = parseInt(rank);
            deck.push({ rank, suit, value: value, originalValue: value, isFaceDown: false }); // Store original value for glitch
          }
        }
        return deck;
      },

      shuffleDeck: function() {
        triggerScreenShake(); 
        if (this.elements.gameDeck) { 
            this.elements.gameDeck.classList.add('shuffle-animation');
            // Small delay to let the animation start before actual shuffle
            setTimeout(() => {
                this.elements.gameDeck.classList.remove('shuffle-animation');
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }, 500); // This timeout should match or be slightly less than the CSS animation duration
        } else {
            console.error("Error: gameDeck element not found for shuffle animation. Shuffling immediately.");
            for (let i = this.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
            }
        }
      },

      dealCard: function() {
        if (this.deck.length === 0) {
            console.error("Attempted to deal a card from an empty deck. Resetting and reshuffling.");
            this.resetDeck(); // Reshuffle if deck is empty
            this.showGameMessage('Deck ran out! Automatically reshuffling.', 'tie');
        }
        // Ensure the card drawn is always a new object, not a reference to one in the deck
        // Also ensure isFaceDown property is clean for new cards
        return { ...this.deck.pop(), isFaceDown: false };
      },

      dealInitialCards: function() {
        this.playerHand.push(this.dealCard());
        
        // Ensure proper handling of isFaceDown for the second player card
        let secondPlayerCard = this.dealCard();
        // If Low Visibility is active, the second player card should be face down
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
            secondPlayerCard.isFaceDown = true;
        }
        this.playerHand.push(secondPlayerCard);

        let dealerFirstCard = this.dealCard();
        let dealerSecondCard = this.dealCard();
        
        // Dealer's second card is always face down initially in standard blackjack.
        // For Low Visibility, both dealer cards are face down initially.
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
            dealerFirstCard.isFaceDown = true;
            dealerSecondCard.isFaceDown = true;
        } else {
            dealerSecondCard.isFaceDown = true;
        }
        
        this.dealerHand.push(dealerFirstCard);
        this.dealerHand.push(dealerSecondCard);
      },

      getHandValue: function(hand) {
        let value = 0;
        let numAces = 0;

        for (const card of hand) {
          
          // Use glitchedValue if 'Glitch in the Matrix' is active and card has it
          const cardValue = (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.glitchedValue !== undefined) ? card.glitchedValue : 
                            (card.value !== undefined ? card.value : parseInt(card.rank)); // Fallback if no value or not A/K/Q/J

          value += cardValue;
          if (card.rank === 'A') { 
            numAces++;
          }
        }

        while (value > 21 && numAces > 0) {
          value -= 10;
          numAces--;
        }
        return value;
      },

      updateHandsDisplay: function() {
        this.elements.playerCardsDiv.innerHTML = '';
        this.elements.dealerCardsDiv.innerHTML = '';

        this.playerHand.forEach((card, index) => {
          this.elements.playerCardsDiv.appendChild(this.createCardElement(card, index, 'player'));
        });

        this.dealerHand.forEach((card, index) => {
          this.elements.dealerCardsDiv.appendChild(this.createCardElement(card, index, 'dealer'));
        });

        this.elements.playerTotalDisplay.textContent = `Total: ${this.getHandValue(this.playerHand)}`;
        
        // For Low Visibility, dealer total is hidden until reveal
        // For standard game, only the face-up cards are counted for dealer's visible total
        const dealerFaceUpCards = this.dealerHand.filter(card => !card.isFaceDown);
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility' && this.isGameActive) {
            this.elements.dealerTotalDisplay.textContent = `Total: ??`;
        } else {
            // Display total of face-up cards for the dealer, or full total if all are revealed
            this.elements.dealerTotalDisplay.textContent = `Total: ${this.getHandValue(dealerFaceUpCards)}`;
        }

        // Disable double down if Limit Barriers is active or if already hit
        // Also disable if player doesn't have enough credits for double the current bet
        this.elements.doubleBtn.disabled = (this.playerHand.length > 2 || this.playerCredits < this.currentBet || (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1));
        // Disable hit if Limit Barriers is active and already hit
        this.elements.hitBtn.disabled = (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1);
      },

      createCardElement: function(card, index, handType) {
        const cardElement = document.createElement('div');
        cardElement.classList.add('card');
        
        let displayRank = card.rank;
        let displaySuit = card.suit;
        let displayValue = card.value;

        // Apply Glitch in the Matrix visual if active and card has glitchedValue
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.glitchedValue !== undefined) {
            displayRank = '??';
            displaySuit = 'â“'; // Use a question mark for the suit
            displayValue = '??';
        }

        // Determine if the card should be face down visually
        let isActuallyFaceDown = card.isFaceDown;
        // The Low Visibility rule means *all* cards are initially face down, except the first player card.
        // This logic needs to override the card.isFaceDown flag for display purposes initially.
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility' && this.isGameActive) {
            if (handType === 'player' && index === 0) {
                isActuallyFaceDown = false; // First player card is always visible
            } else {
                isActuallyFaceDown = true; // All other cards are face down initially
            }
        }
        
        // If the card is truly face down (by game logic or initial Low Visibility rule)
        if (isActuallyFaceDown) {
            cardElement.classList.add('flipped');
            cardElement.innerHTML = `
                <div class="card-inner">
                    <div class="card-front"></div>
                    <div class="card-back">Cyber<br>Blackjack</div>
                </div>
            `;
        } else {
            const suitClass = (card.suit === 'â¤ï¸' || card.suit === 'â™¦ï¸') ? 'red' : 'black';
            cardElement.innerHTML = `
                <div class="card-inner">
                    <div class="card-front ${suitClass}">
                        <span>${displayRank}</span>
                        <span>${displaySuit}</span>
                        <span>${displayRank}</span>
                        <span class="card-value" style="display: none;">${displayValue}</span> 
                    </div>
                    <div class="card-back">Cyber<br>Blackjack</div>
                </div>
            `;
        }
        return cardElement;
      },

      hit: function() {
        if (!this.isGameActive) return;

        // NEW: Limit Barriers check
        if (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1) {
            this.showGameMessage('Limit Barriers active! Only one hit allowed per hand!', 'lose');
            return;
        }

        this.playSFX('sfx-hit'); // Play hit sound effect


        const newCard = this.dealCard();
        // If low visibility is active and this is player's second card or more, keep it face down
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility' && this.playerHand.length >= 1) {
            newCard.isFaceDown = true;
        }
        this.playerHand.push(newCard);
        this.updateHandsDisplay();
         // --- NEW CODE: Phantom Echo Ability Check ---
    // Place this block immediately after updating player's hand and display
    if (this.isBrawl && this.currentDealer &&
        this.currentDealer.secondaryAbility && !this.currentDealer.secondaryAbility.usedThisGame &&
        this.currentDealer.secondaryAbility.id === 'phantom_echo' &&
        this.playerHand.length >= 3 && Math.random() < 1.0) { // Increased chance for testing, adjust as needed
        this.activateAbility(this.currentDealer.secondaryAbility);
    }
    // --- END NEW CODE ---

        if (this.isBrawl) {
            this.addCharge(10); // Gain 10 special charge on hit
            if (this.isLimitBarrierActive) {
                this.playerHitsThisRound++; // Increment hit counter only if limit barriers are active
            }
        }

        const playerTotal = this.getHandValue(this.playerHand);
        // Special condition for Low Visibility: total for busting is based on face-up cards,
        // but for checking 21, all cards (even face down) count for the actual game logic.
        // So, we need to calculate the *true* total including hidden cards for game state checks.
        let truePlayerTotal = 0;
        let playerAces = 0;
        this.playerHand.forEach(card => {
            let val = card.value;
            // Use original value for true total if glitch effect is active to avoid miscalculation
            if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.originalValue !== undefined) {
                val = card.originalValue; 
            }
            truePlayerTotal += val;
            if (card.rank === 'A') playerAces++;
        });
        while (truePlayerTotal > 21 && playerAces > 0) {
            truePlayerTotal -= 10;
            playerAces--;
        }

        if (truePlayerTotal > 21) {
          this.endGame('bust');
        } else if (truePlayerTotal === 21) {
          if (this.isBrawl) {
            this.addCharge(0, 25); // Gain 25 ultimate charge for 21
            this.playerHP = Math.min(100, this.playerHP + 30); // Gain 30 HP for 21
            this.showGameMessage('Hit 21! +30 HP and +25 Ultimate Charge!', 'win');
            this.updateBrawlHUD(); 
          }
          this.stand(); 
        }
      },
      resetRound: function() {
        console.log("resetRound called: Resetting game state for new round.");

        // Reset player and dealer hands
        this.playerHand = [];
        this.dealerHand = [];

        // Ensure game is not active initially
        this.isGameActive = false;

        // Reset temporary effects introduced by abilities
        this.isPlayerCardsScrambled = false; // For Zenith's Entropy Cascade
        // Restore original card values if they were scrambled
        // Iterate through all cards that might have been scrambled and reset their value
        // This assumes your cards might have an 'originalValue' property
        // (Ensure you also implement 'originalValue' setting in activateAbility for Entropy Cascade)
        // Note: playerHand will be empty here, but the logic is robust for any cards that might be lingering
        if (this.playerHand && this.playerHand.length > 0) { // Check if playerHand exists and has cards
            this.playerHand.forEach(card => {
                if (card.hasOwnProperty('originalValue')) {
                    card.value = card.originalValue;
                    delete card.originalValue; // Clean up the temporary property
                }
                if (card.hasOwnProperty('isPhantom')) { // For Shadow Weaver's Phantom Echo
                    // Phantom cards should be removed entirely
                }
            });
            // Filter out phantom cards if any were added
            this.playerHand = this.playerHand.filter(card => !card.isPhantom);
        }
        
        this.playerCreditsLocked = 0; // For Omega's Credit Lockdown

        // Reset special/ultimate charge
        this.specialCharge = 0;
        this.ultimateCharge = 0;

        // Reset hit counters for hazards if applicable
        this.playerHitsThisRound = 0;
        this.dealerHitsThisRound = 0;
        this.isLimitBarrierActive = false; // Reset the flag

        // Clear any active brawl rules from the previous round
        if (this.activeBrawlRule && this.activeBrawlRule.revert) {
            this.activeBrawlRule.revert(); // Call revert if the rule has one
        }
        this.activeBrawlRule = null;

        // --- IMPORTANT: RESET ALL DEALER ABILITY FLAGS (FOR ALL DEALERS) ---
        // Iterate through your entire dealers array and reset their ability usage flags
        if (this.dealers && this.dealers.length > 0) {
            this.dealers.forEach(dealer => {
                if (dealer.uniqueAbility) {
                    dealer.uniqueAbility.usedThisGame = false;
                }
                if (dealer.secondaryAbility) {
                    dealer.secondaryAbility.usedThisGame = false;
                }
            });
        }

        // Reset the deck for a new round
        this.resetDeck();

        // Hide any old game messages or results
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden');
        this.elements.postGameControls.classList.add('hidden'); // Ensure post-game controls are hidden
        this.elements.gameControls.classList.remove('hidden'); // Ensure game controls are visible
        this.elements.powerupControls.classList.remove('hidden'); // Ensure power-up controls are visible

        // Enable bet input at the start of a new round
        this.elements.betAmountInput.disabled = false;
        this.elements.betAmountInput.value = ''; // Clear previous bet amount

        // Finally, update the UI to reflect the reset state
        this.updateHandsDisplay();
        this.updateBrawlHUD(); // If in Brawl Mode
        this.updateUI(); // General UI update
    },
      stand: function() {
        if (!this.isGameActive) return;
        this.playSFX('sfx-stand'); // Play stand sound effect

        this.isGameActive = false;
        this.elements.gameControls.classList.add('hidden'); 
        this.elements.powerupControls.classList.add('hidden'); 
        this.elements.betAmountInput.disabled = false; 

        // Reveal all dealer cards if Low Visibility was active or for standard game
        this.dealerHand.forEach(card => card.isFaceDown = false);
        // After revealing all, proceed to dealer's turn
        // Set a timeout to ensure all flip animations have a chance to complete
        setTimeout(() => {
            this.updateHandsDisplay(); // Update display to show flipped cards
            this.dealerTurn();
        }, 1500); 
      },
      doubleDown: function() {
        if (!this.isGameActive || this.playerHand.length !== 2 || this.playerCredits < this.currentBet) return;
        
        // NEW: Limit Barriers check for Double Down
        if (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1) {
            this.showGameMessage('Limit Barriers active! Only one hit allowed per hand!', 'lose');
            return;
        }

        this.playSFX('sfx-doubledown'); // Play double down sound effect

        this.playerCredits -= this.currentBet; 
        this.currentBet *= 2;
        const newCard = this.dealCard();
        // If low visibility is active, keep the new card face down
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
            newCard.isFaceDown = true;
        }
        this.playerHand.push(newCard); 
        this.updateHandsDisplay();
        this.updateUI();

        if (this.isBrawl) {
            this.addCharge(15); 
            if (this.isLimitBarrierActive) {
                this.playerHitsThisRound++; // Double Down counts as a hit for Limit Barriers
            }
        }

        const playerTotal = this.getHandValue(this.playerHand);
        // Again, for game logic check, use true total including hidden cards
        let truePlayerTotal = 0;
        let playerAces = 0;
        this.playerHand.forEach(card => {
            let val = card.value;
             // Use original value for true total if glitch effect is active
            if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.originalValue !== undefined) {
                val = card.originalValue;
            }
            truePlayerTotal += val;
            if (card.rank === 'A') playerAces++;
        });
        while (truePlayerTotal > 21 && playerAces > 0) {
            truePlayerTotal -= 10;
            playerAces--;
        }

        if (truePlayerTotal > 21) {
          this.endGame('bust');
        } else {
          if (this.isBrawl && truePlayerTotal === 21) {
            this.addCharge(0, 25); 
            this.playerHP = Math.min(100, this.playerHP + 30); 
            this.showGameMessage('Double Down 21! +30 HP and +25 Ultimate Charge!', 'win');
            this.updateBrawlHUD(); 
          }
          this.stand(); 
        }
      },

      dealerTurn: function() {
        // Ensure all dealer cards are revealed before proceeding with dealer's turn logic
        this.dealerHand.forEach(card => card.isFaceDown = false);
        this.updateHandsDisplay(); // Update display to show all cards revealed

        let dealerTotal = this.getHandValue(this.dealerHand);
        const playerTotal = this.getHandValue(this.playerHand);
        let abilityActivatedThisTurn = false; // Flag to track if ANY ability activated
        let currentDealerData = this.currentDealer;

        // Apply Glitch in the Matrix's visual effect if active
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix') {
            this.applyGlitchEffect(); // Re-apply visual glitch if needed for dealer's turn
        }

        // --- MAIN BLOCK FOR UNIQUE ABILITY ACTIVATION ---
        // Check if current dealer has a unique ability and it hasn't been used
        if (currentDealerData && currentDealerData.uniqueAbility && !currentDealerData.uniqueAbility.usedThisGame) {
            const abilityId = currentDealerData.uniqueAbility.id;
            switch (abilityId) {
                case 'novice_ability': // CYPHER-BOT 7: RESERVE CARD
                    // Only activate if dealer would bust (total > 21) AND has more than 2 cards (to avoid infinite loop with 2 card bust)
                    if (dealerTotal > 21 && Math.random() < 0.7 && this.dealerHand.length > 2) {
                        this.showGameMessage('CYPHER-BOT 7 USES RESERVE CARD!', 'tie');
                        this.dealerHand.pop(); // Remove the busting card
                        const newCard = this.dealCard();
                        // Small chance of drawing an Ace as the new card
                        if (Math.random() < 0.3) {
                            newCard.rank = 'A';
                            newCard.value = 11; // Ensure it's an Ace value
                        }
                        this.dealerHand.push(newCard);
                        this.updateHandsDisplay();
                        currentDealerData.uniqueAbility.usedThisGame = true;
                        this.saveGameData();
                        setTimeout(() => this.dealerTurn(), 1000); // Re-evaluate after ability
                        return; // Stop current dealerTurn execution
                    }
                    break;
                case 'conservative_ability': // DATA-SAMURAI: FOCUSED DRAW
                    if (Math.random() < 0.3 && dealerTotal >= 12 && dealerTotal <= 16 && this.deck.length > 0) {
                        const nextCard = this.deck[this.deck.length - 1]; // Peek the top card
                        const potentialHand = [...this.dealerHand];
                        potentialHand.push(nextCard); // Temporarily add next card to hand for value calculation

                        let potentialTotal = 0;
                        let potentialAces = 0;
                        for (const card of potentialHand) {
                            potentialTotal += card.value;
                            if (card.rank === 'A') potentialAces++;
                        }
                        while (potentialTotal > 21 && potentialAces > 0) {
                            potentialTotal -= 10;
                            potentialAces--;
                        }

                        if (potentialTotal >= 17 && potentialTotal <= 21) {
                            this.showGameMessage('DATA-SAMURAI USES FOCUSED DRAW!', 'tie');
                            this.dealerHand.push(this.dealCard()); // Actually deal the card
                            this.updateHandsDisplay();
                            currentDealerData.uniqueAbility.usedThisGame = true;
                            this.saveGameData();
                            setTimeout(() => this.dealerTurn(), 1000);
                            return;
                        }
                    }
                    break;
                case 'calculating_ability': // THE QUANTUM QUASAR: CARD PREDICTION
                    if (Math.random() < 1.0 && dealerTotal >= 14 && dealerTotal <= 16 && this.deck.length >= 3) {
                        const potentialCards = this.deck.slice(-3).reverse(); // Get top 3 cards without removing

                        let bestCard = null;
                        for (const cardOption of potentialCards) {
                            const tempHand = [...this.dealerHand, cardOption];
                            let potentialTotal = 0;
                            let potentialAces = 0;
                            for (const card of tempHand) {
                                potentialTotal += card.value;
                                if (card.rank === 'A') potentialAces++;
                            }
                            while (potentialTotal > 21 && potentialAces > 0) {
                                potentialTotal -= 10;
                                potentialAces--;
                            }

                            if (potentialTotal >= 17 && potentialTotal <= 21) {
                                bestCard = cardOption;
                                break; // Found a good card, stop looking
                            }
                        }

                        if (bestCard) {
                            // Find the index of the best card in the deck and remove it
                            const bestCardIndexInDeck = this.deck.indexOf(bestCard);
                            if (bestCardIndexInDeck > -1) {
                                this.deck.splice(bestCardIndexInDeck, 1);
                            }
                            this.dealerHand.push(bestCard); // Add the "predicted" card to dealer's hand
                            this.showGameMessage('THE QUANTUM QUASAR PREDICTS THE FUTURE!', 'tie');
                            this.updateHandsDisplay();
                            currentDealerData.uniqueAbility.usedThisGame = true;
                            this.saveGameData();
                            setTimeout(() => this.dealerTurn(), 2000);
                            return;
                        } else {
                            this.showGameMessage('THE QUANTUM QUASAR RESHUFFLES! (NO PREDICTION)', 'tie');
                            const tempCards = this.deck.splice(this.deck.length - 3, 3); // Remove last 3 cards
                            tempCards.sort(() => Math.random() - 0.5); // Shuffle them
                            this.deck = this.deck.concat(tempCards); // Add them back to the end
                        }
                    }
                    break;
                case 'expert_ability': // SHADOW WEAVER: HIDDEN CARD SWAP
                    if (Math.random() < 1.0 && this.dealerHand.length >= 2 && this.deck.length > 0) { // Low chance
                        const cardToSwapIndex = Math.floor(Math.random() * this.dealerHand.length); // Randomly pick a dealer card
                        const oldCard = this.dealerHand[cardToSwapIndex];
                        const newCardFromDeck = this.dealCard();

                        this.dealerHand[cardToSwapIndex] = newCardFromDeck; // Replace old card with new
                        this.deck.unshift(oldCard); // Put the old card back into the deck (at the beginning)

                        this.showGameMessage('SHADOW WEAVER PERFORMS A HIDDEN CARD SWAP!', 'lose');
                        this.updateHandsDisplay();
                        currentDealerData.uniqueAbility.usedThisGame = true;
                        this.saveGameData();
                    }
                    break;
                case 'system_override': // OMEGA: SYSTEM OVERRIDE
                    if (Math.random() < 1.0 && playerTotal >= 20 && dealerTotal < 17 && this.deck.length >= 2) { // Very low chance
                        this.activateAbility(currentDealerData.uniqueAbility); // Call activateAbility for the effect
                        setTimeout(() => this.dealerTurn(), 1000); // Re-evaluate after ability
                        return;
                    }
                    break;
                case 'glitch_ability': // THE GLITCH: DATA CORRUPTION
                    // This ability is typically activated at the start of the round (in startGame).
                    // If not activated then, it could be triggered here as a secondary chance.
                    if (Math.random() < 0.1 && !currentDealerData.uniqueAbility.usedThisGame) { // Check if not used already
                        this.activateAbility(currentDealerData.uniqueAbility);
                    }
                    break;
                case 'master_ability': // ZENITH: ADAPTIVE STRATEGY
                     // This ability is typically activated at the start of the round (in startGame).
                     // If not activated then, it could be triggered here as a secondary chance.
                    if (Math.random() < 1.0 && !currentDealerData.uniqueAbility.usedThisGame) {
                        this.activateAbility(currentDealerData.uniqueAbility);
                    }
                    break;
            } // End of the unique ability switch
        } // End of the unique ability if block

        // --- CORRECTLY PLACED BLOCK FOR SECONDARY ABILITY ACTIVATION ---
        // This 'if' block runs AFTER the unique ability checks.
        // It ensures that a secondary ability is only attempted if a unique one wasn't used this turn.
        if (currentDealerData && currentDealerData.secondaryAbility && !currentDealerData.secondaryAbility.usedThisGame) {
            let secondaryAbilityTriggered = false; // Local flag for secondary abilities within this check

            // Check for Zenith's secondary ability: Entropy Cascade
            if (this.currentDealer.secondaryAbility.id === 'entropy_cascade' && Math.random() < 1.0 && playerTotal > 15 && dealerTotal < playerTotal) {
                this.activateAbility(this.currentDealer.secondaryAbility);
                secondaryAbilityTriggered = true;
            }
            // Check for Shadow Weaver's secondary ability: Phantom Echo
            else if (this.currentDealer.secondaryAbility.id === 'phantom_echo' && Math.random() < 1.0 && playerTotal < 10 && this.playerHand.length < 3) {
                this.activateAbility(this.currentDealer.secondaryAbility);
                secondaryAbilityTriggered = true;
            }
            // Check for Omega's secondary ability: Credit Lockdown
            else if (this.currentDealer.secondaryAbility.id === 'credit_lockdown' && Math.random() < 1.0 && playerTotal > 18 && this.playerCredits > 500) {
                this.activateAbility(this.currentDealer.secondaryAbility);
                secondaryAbilityTriggered = true;
            }

            // If any secondary ability activated, update game state
            if (secondaryAbilityTriggered) {
                abilityActivatedThisTurn = true; // Mark that an ability activated
                setTimeout(() => this.dealerTurn(), 1000); // Re-evaluate after secondary ability
                return;
            }
        }

        let dealerStrategy = 'standard'; 
        if (this.currentDealer) {
            dealerStrategy = this.currentDealer.strategy;
        }

        const playDealerHand = () => {
            dealerTotal = this.getHandValue(this.dealerHand); 
            // NEW: Limit Barriers check for dealer
            if (this.isBrawl && this.isLimitBarrierActive && this.dealerHitsThisRound >= 1) {
                this.showGameMessage('Dealer hit limit due to Limit Barriers!', 'tie');
                this.determineWinner();
                return;
            }
            
            // Revert Glitch effect before making hit/stand decision based on actual values
            if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && currentDealerData.uniqueAbility && currentDealerData.uniqueAbility.usedThisGame) {
                this.revertGlitchEffect(); // Revert for accurate calculation
                dealerTotal = this.getHandValue(this.dealerHand); // Recalculate with original values
            }

            // Logic for dealer hit/stand decision based on strategy
            if (dealerTotal < 17 || 
                (dealerStrategy === 'aggressive' && dealerTotal >= 17 && dealerTotal < 21 && Math.random() < 0.5) || // Aggressive might hit on 17-20
                (dealerStrategy === 'unpredictable' && Math.random() < 0.5 && dealerTotal < 19) // Unpredictable is more random
            ) {
                const newCard = this.dealCard();
                // If Low Visibility is active, the newly drawn card for dealer should be face down
                if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
                    newCard.isFaceDown = true;
                }
                this.dealerHand.push(newCard);
                 // >>> PLACE THE DEALER BUST CHECK HERE <<<
                if (this.getHandValue(this.dealerHand) > 21) {
                    this.gameOutcome = 'win'; // Player wins because dealer busted
                    this.showGameMessage('DEALER BUSTS! You win!', 'win');
                    this.playSFX('sfx-win');
                    this.updateUI();
                    this.saveGameData();
                    this.elements.postGameControls.classList.remove('hidden');
                    return; // Exit the dealer turn as the game is over
                }
                // >>> END OF DEALER BUST CHECK <<<
                this.updateHandsDisplay();
                if (this.isBrawl && this.isLimitBarrierActive) {
                    this.dealerHitsThisRound++; // Increment dealer hit counter
                }
                setTimeout(playDealerHand, 1000); 
            } else {
                this.determineWinner();
            }
        };

        if (this.powerUps.freeze > 0 && this.isGameActive) { 
            this.showGameMessage('Dealer Frozen! Skips next hit.', 'tie');
            this.powerUps.freeze--;
            this.updatePowerUpButtons();
            // If Glitch in the Matrix was active for this dealer, ensure it's reverted after the freeze turn
            if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && currentDealerData.uniqueAbility && currentDealerData.uniqueAbility.usedThisGame) {
                this.revertGlitchEffect();
            }
            this.determineWinner();
        } else {
            playDealerHand();
        }
        // Reset adaptive strategy after the dealer's turn concludes
        if (currentDealerData && currentDealerData.uniqueAbility && currentDealerData.uniqueAbility.id === 'master_ability' && currentDealerData.uniqueAbility.usedThisGame) { 
            currentDealerData.strategy = 'optimal'; // Revert to optimal after adaptive turn
        }
      },

      determineWinner: function() {
        const playerTotal = this.getHandValue(this.playerHand);
        const dealerTotal = this.getHandValue(this.dealerHand);

        this.games++;
        this.saveGameData();

        let outcome = '';
        if (playerTotal > 21) {
          outcome = 'bust';
        } else if (dealerTotal > 21) {
          outcome = 'dealerBust';
        } else if (playerTotal > dealerTotal) {
          outcome = 'win';
        } else if (dealerTotal > playerTotal) {
          outcome = 'lose';
        } else {
          outcome = 'tie';
        }
        this.endGame(outcome);
      },

      endGame: function(outcome) {
        this.isGameActive = false;
        this.elements.gameControls.classList.add('hidden'); 
        this.elements.powerupControls.classList.add('hidden'); 
        this.elements.betAmountInput.disabled = false; 
        this.elements.postGameControls.classList.remove('hidden'); 

        let message = '';
        let messageType = '';
        let xpReward = 0;
        let creditsWon = 0;

        const baseXP = 50;
        const campaignMultiplier = this.currentDealer ? this.currentDealer.xpMultiplier : 1;
        let betMultiplier = this.currentBet / 50; // Normalize bet to a multiplier (assuming 50 is base bet)
        
        // Apply Cyber Nexus Pass credit bonus (NEW)
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            betMultiplier *= (1 + this.cyberNexusPassDetails.creditBonus);
            this.showGameMessage(`Cyber Nexus Pass Credit Bonus: +${(this.cyberNexusPassDetails.creditBonus * 100).toFixed(0)}% Credits!`, 'win');
        }

        // Revert any active brawl rule effects at the end of the round
        if (this.activeBrawlRule && this.activeBrawlRule.revert) {
            this.activeBrawlRule.revert();
        }
        // Set activeBrawlRule to null for the next round
        this.activeBrawlRule = null;

        // Track stats for campaign progress and rogue wins
        if (this.currentDealer && !this.isRogueModeActive) { // Only track for non-rogue dealers
            if (outcome === 'win' || outcome === 'dealerBust') {
                this.campaignProgress.streaks.campaign++;
                // Increment wins for this specific dealer
                this.campaignProgress.dealerWins[this.currentDealer.id] = (this.campaignProgress.dealerWins[this.currentDealer.id] || 0) + 1;
                this.checkRogueModeUnlockConditions(); // Check for unlock after each win
            } else {
                this.campaignProgress.streaks.campaign = 0;
            }
            if (this.campaignProgress.streaks.campaign > this.campaignProgress.bestStreak) {
                this.campaignProgress.bestStreak = this.campaignProgress.streaks.campaign;
            }
        } else if (!this.currentDealer && !this.isRogueModeActive) { // Quick Play
            if (outcome === 'win' || outcome === 'dealerBust') {
                this.campaignProgress.streaks.quickPlay++;
            } else {
                this.campaignProgress.streaks.quickPlay = 0;
            }
        } else if (this.isRogueModeActive) { // If in Rogue Mode, always consider wins part of a "campaign streak"
             if (outcome === 'win' || outcome === 'dealerBust') {
                this.campaignProgress.streaks.campaign++; // Use campaign streak for rogue mode as well
            } else {
                this.campaignProgress.streaks.campaign = 0;
            }
        }


        // Specific statistics
        const playerTotalAtEnd = this.getHandValue(this.playerHand);
        // Blackjack only if 2 cards and total 21
        if (playerTotalAtEnd === 21 && this.playerHand.length === 2) { 
            this.campaignProgress.totalBlackjacks++;
        }
        if (outcome === 'bust') {
            this.campaignProgress.totalBusts++;
        }

        switch (outcome) {
          case 'win':
            message = 'You Win!';
            messageType = 'win';
            creditsWon = this.currentBet * 2; 
            xpReward = baseXP * campaignMultiplier * betMultiplier;
            this.wins++;
            this.playSFX('sfx-win'); // Play win sound
            if (this.isBrawl) {
                this.addCharge(20); // Gain special charge on win
            }
            break;
          case 'dealerBust':
            message = 'Dealer Busts! You Win!';
            messageType = 'win';
            creditsWon = this.currentBet * 2;
            xpReward = baseXP * campaignMultiplier * betMultiplier;
            this.wins++;
            this.playSFX('sfx-win'); // Play win sound
            if (this.isBrawl) {
                this.addCharge(20); // Gain special charge on dealer bust
            }
            break;
          case 'lose':
            message = 'You Lose.';
            messageType = 'lose';
            xpReward = baseXP / 2 * campaignMultiplier * betMultiplier; 
            this.playSFX('sfx-lose'); // Play lose sound
            // In Brawl Mode, losing a hand does NOT inherently reduce player HP.
            // HP loss is managed by explicit dealer attacks or hazards.
            // Check for game over *only* if HP is zero from other sources AND no shield.
            if (this.isBrawl) {
                // If the game reached this state in Brawl, it means player lost the hand
                // but this does not automatically reduce HP unless specified by a rule.
                // The explicit HP check is usually done *after* damage is inflicted by dealer.
                // So, if player HP is already 0, it means player was defeated earlier.
                // Brawl Mode credit deductions for specific opponents
                    const opponentId = this.currentDealerId; // Assuming currentDealerId holds the unique ID of the opponent
                    switch (opponentId) {
                        case 'zenith':
                            this.playerCredits -= 400;
                            this.showGameMessage('Lost to Zenith in Brawl Mode! -400 Credits!', 'lose');
                            break;
                        case 'shadow_weaver':
                            this.playerCredits -= 450;
                            this.showGameMessage('Lost to Shadow Weaver in Brawl Mode! -450 Credits!', 'lose');
                            break;
                        case 'omega':
                            this.playerCredits -= 500;
                            this.showGameMessage('Lost to Omega in Brawl Mode! -500 Credits!', 'lose');
                            break;
                        default:
                            // Optional: A default loss for other brawl opponents if needed
                            // this.playerCredits -= 300; // Example for a generic brawl loss
                            // this.showGameMessage('Lost in Brawl Mode! Credits deducted!', 'lose');
                            break;
                    }
                    this.updateUI(); // Ensure credits display is updated
                    this.saveGameData(); // Save the new credit balance
                    // >>> END OF NEW CODE BLOCK <<<
                if (this.playerHP <= 0) { 
                    message = 'You were defeated in Brawl Mode!';
                    messageType = 'lose';
                    this.showGameMessage(message, messageType);
                    this.elements.postGameControls.classList.add('hidden');
                    setTimeout(() => { this.backToMenu(); }, 3000);
                    return; // End the function here to prevent further game flow
                }
            }
            break;
          case 'bust':
            message = 'You Bust!';
            messageType = 'lose';
            xpReward = baseXP / 2 * campaignMultiplier * betMultiplier;
            this.playSFX('sfx-lose'); // Play lose sound
            // Similar to 'lose' case, handle Brawl HP for bust if it applies
            if (this.isBrawl) {
                if (this.playerHP <= 0) { 
                    message = 'You were defeated in Brawl Mode!';
                    messageType = 'lose';
                    this.showGameMessage(message, messageType);
                    this.elements.postGameControls.classList.add('hidden');
                    setTimeout(() => { this.backToMenu(); }, 3000);
                    return; 
                }
            }
            break;
          case 'tie':
            message = 'It\'s a Tie!';
            messageType = 'tie';
            creditsWon = this.currentBet; 
            xpReward = baseXP / 4 * campaignMultiplier * betMultiplier; 
            this.playSFX('sfx-tie'); // Play tie sound
            break;
        }

        this.playerCredits += creditsWon;
        this.addXP(xpReward);

        this.showGameMessage(message, messageType);
        this.updateUI(); 

        if (this.isBrawl) {
            this.updateBrawlHUD();
            // Check if dealer HP is zero *after* determining game outcome and applying any damage
            if (this.dealerHP <= 0) {
                const creditsDrop = this.currentDealer ? this.currentDealer.credits_drop : 300; // Use dealer's specific drop, default 300
                this.showGameMessage(`DEALER DEFEATED! You won ${creditsDrop} Credits!`, 'win');
                this.playerCredits += creditsDrop; 
                this.updateUI(); 
                this.elements.postGameControls.classList.add('hidden'); 
                setTimeout(() => { this.backToMenu(); }, 3000); 
                return; 
            }
            // Dealer has a chance to special attack after player's turn concludes (if not defeated)
            // This is a post-round attack, not part of the current round's blackjack outcome
            if (this.dealerHP > 0 && Math.random() < 0.4) { 
                this.dealerSpecialAttack();
            }
        }
      },

      startRiskGame: function() {
        const playerActualTotal = this.getHandValue(this.playerHand);
        // Only allow risk game if the player didn't already get 21 or bust
        if (playerActualTotal === 21 && this.playerHand.length === 2) {
            this.elements.riskResult.textContent = 'You already got a Blackjack! No risk game needed.';
            this.elements.riskResult.className = 'message win';
            this.elements.riskResult.classList.remove('hidden');
            return;
        }
        if (playerActualTotal > 21) {
            this.elements.riskResult.textContent = 'You busted! No risk game available.';
            this.elements.riskResult.className = 'message lose';
            this.elements.riskResult.classList.remove('hidden');
            return;
        }

        this.showGameMessage('Risk Game: Guess higher or lower than the hidden card!', '');
        this.elements.riskResult.classList.add('hidden');
        this.elements.riskButton.disabled = true; 

        // Create a temporary deck for the risk game to not interfere with main deck
        const riskDeck = this.createDeck(); // Re-use createDeck for a fresh set of cards
        for (let i = riskDeck.length - 1; i > 0; i--) { // Shuffle the risk deck
            const j = Math.floor(Math.random() * (i + 1));
            [riskDeck[i], riskDeck[j]] = [riskDeck[j], riskDeck[i]];
        }

        const hiddenCard = riskDeck.pop();
        const playerCard = riskDeck.pop(); 

        // Clear previous hand displays and show only the player's risk card
        this.elements.playerCardsDiv.innerHTML = ''; 
        this.elements.playerCardsDiv.appendChild(this.createCardElement(playerCard));
        this.elements.playerTotalDisplay.textContent = `Your Card: ${playerCard.rank}`;
        this.elements.dealerCardsDiv.innerHTML = ''; // Clear dealer area for now
        this.elements.dealerTotalDisplay.textContent = `Hidden Card: ??`;


        const higherBtn = document.createElement('button');
        higherBtn.classList.add('game-button');
        higherBtn.textContent = 'Higher';
        higherBtn.onclick = () => this.resolveRiskGame('higher', playerCard, hiddenCard);

        const lowerBtn = document.createElement('button');
        lowerBtn.classList.add('game-button');
        lowerBtn.textContent = 'Lower';
        lowerBtn.onclick = () => this.resolveRiskGame('lower', playerCard, hiddenCard);

        this.elements.gameControls.innerHTML = ''; 
        this.elements.gameControls.appendChild(higherBtn);
        this.elements.gameControls.appendChild(lowerBtn);
        this.elements.gameControls.classList.remove('hidden');
        this.elements.postGameControls.classList.add('hidden'); // Hide post-game controls during risk game
      },

      resolveRiskGame: function(choice, playerCard, hiddenCard) {
        this.elements.gameControls.classList.add('hidden'); 
        this.elements.riskButton.disabled = false; 
        this.hideGameMessage();

        const getCardNumericValue = (card) => {
            // Ensure proper value retrieval for Risk Game, ignoring glitched/face-down states
            if (card.rank === 'A') return 11;
            if (['K', 'Q', 'J'].includes(card.rank)) return 10;
            return parseInt(card.rank);
        };

        const playerCardValue = getCardNumericValue(playerCard);
        const hiddenCardValue = getCardNumericValue(hiddenCard);

        this.elements.dealerCardsDiv.innerHTML = ''; 
        // Display the hidden card face-up now
        this.elements.dealerCardsDiv.appendChild(this.createCardElement(hiddenCard, 0, 'dealer')); // Pass handType 'dealer'
        this.elements.dealerTotalDisplay.textContent = `Hidden Card: ${hiddenCard.rank} (${hiddenCardValue})`;

        let win = false;
        if (choice === 'higher') {
            win = hiddenCardValue > playerCardValue;
        } else { // choice === 'lower'
            win = hiddenCardValue < playerCardValue;
        }

        if (hiddenCardValue === playerCardValue) {
            this.elements.riskResult.textContent = 'It\'s a Push! Bet returned.';
            this.elements.riskResult.className = 'message tie';
            this.playerCredits += this.currentBet;
            this.playSFX('sfx-tie'); // Play tie sound
        } else if (win) {
            this.elements.riskResult.textContent = 'You Win! Double your credits!';
            this.elements.riskResult.className = 'message win';
            this.playerCredits += this.currentBet * 2; 
            this.playSFX('sfx-win'); // Play win sound
        } else {
            this.elements.riskResult.textContent = 'You Lose! All credits lost.';
            this.elements.riskResult.className = 'message lose';
            this.playerCredits = 0; // Player loses ALL current credits (double or nothing for ALL credits)
            this.playSFX('sfx-lose'); // Play lose sound
        }
        this.elements.riskResult.classList.remove('hidden');
        this.updateUI();
        this.saveGameData();
        // Re-show post-game controls after risk game
        this.elements.postGameControls.classList.remove('hidden'); 
        // Hide the risk game button after played
        this.elements.riskButton.classList.add('hidden');
      },

      // Campaign mode functions
      setupDealers: function() {
        this.elements.dealersGrid.innerHTML = '';
        console.log("Setting up dealers selection screen.");
        
        let dealersToDisplay = [];
        if (this.isRogueModeActive) {
            dealersToDisplay = this.rogueDealers; // If in rogue mode, display only generated rogue dealers
        } else {
            dealersToDisplay = this.dealers; // Otherwise, display all standard campaign dealers
        }

        dealersToDisplay.forEach(dealer => {
          const dealerCard = document.createElement('div');
          dealerCard.classList.add('dealer-card');
          dealerCard.style.borderColor = dealer.color;
          dealerCard.onclick = () => this.selectCampaignDealer(dealer.id);

          const isLocked = !this.isRogueModeActive && (dealer.unlocksAtLevel > this.playerLevel); // Only lock in regular campaign
          
          if (isLocked) {
            dealerCard.classList.add('locked');
            dealerCard.innerHTML = `
              <div class="locked-overlay">
                <span>LOCKED</span>
                <span>Level ${dealer.unlocksAtLevel} Required</span>
                <span style="font-size: 0.8em;">Wins: ${this.campaignProgress.dealerWins[dealer.id] || 0}/${this.REQUIRED_WINS_FOR_ROGUE_MODE}</span>
              </div>
            `;
          } else {
            // Added onerror to the img tag for dealer avatars
            dealerCard.innerHTML = `
              <div class="dealer-avatar" style="border-color: ${dealer.color};">
                <img src="${dealer.avatarSrc}" alt="${dealer.name} Avatar" onerror="this.onerror=null; this.src='https://placehold.co/80x80/333/666?text=X'; console.error('Failed to load ${dealer.avatarSrc}');">
              </div>
              <div class="dealer-name ${dealer.isBoss ? 'boss-dealer-name' : ''}">${dealer.name}</div>
              <div class="dealer-type">${dealer.type}</div>
              <div class="dealer-description">${dealer.description}</div>
              <div class="dealer-stats">
                <div class="dealer-stat">
                  <span class="dealer-stat-label">XP Multiplier:</span>
                  <span class="dealer-stat-value">${dealer.xpMultiplier}x</span>
                </div>
                <div class="dealer-stat">
                  <span class="dealer-stat-label">Bet Multiplier:</span>
                  <span class="dealer-stat-value">${dealer.betMultiplier}x</span>
                </div>
              </div>
              ${dealer.uniqueAbility ? `<div class="dealer-ability-info" style="font-size: 0.75rem; color: #88ffff; margin-top: 10px;">${dealer.uniqueAbility.name}: ${dealer.uniqueAbility.description}</div>` : ''}
              <div style="font-size: 0.85rem; margin-top: 10px; color: #00ff88;">Wins: ${this.campaignProgress.dealerWins[dealer.id] || 0}/${this.REQUIRED_WINS_FOR_ROGUE_MODE}</div>
            `;
          }
          this.elements.dealersGrid.appendChild(dealerCard);
        });

        // Add Rogue Dealers button if not in rogue mode
        if (!this.isRogueModeActive) {
            this.setupRogueModeButton();
        } else {
            // If in rogue mode, add a "Back to Campaign Selection" button
            let backButton = document.createElement('button');
            backButton.classList.add('back-button');
            backButton.textContent = 'Back to Campaign Selection';
            backButton.onclick = () => {
                this.isRogueModeActive = false; // Exit rogue mode
                this.showCampaign(); // Go back to original campaign screen
            };
            this.elements.dealersGrid.appendChild(backButton);
        }
      },

      // NEW: Rogue Mode Functionality
      checkRogueModeUnlockConditions: function() {
        let allDealersUnlockedByLevel = true;
        let allDealersBeatenRequiredTimes = true;

        this.dealers.forEach(dealer => {
            if (this.playerLevel < dealer.unlocksAtLevel) {
                allDealersUnlockedByLevel = false;
            }
            if ((this.campaignProgress.dealerWins[dealer.id] || 0) < this.REQUIRED_WINS_FOR_ROGUE_MODE) {
                allDealersBeatenRequiredTimes = false;
            }
        });

        if (allDealersUnlockedByLevel && allDealersBeatenRequiredTimes && !this.campaignProgress.rogueModeUnlocked) {
            this.campaignProgress.rogueModeUnlocked = true;
            this.saveGameData();
            this.showGameMessage('ROGUE DEALER MODE UNLOCKED! Prepare for the ultimate challenge!', 'win');
            this.setupRogueModeButton(); // Update button visibility
        }
      },

      setupRogueModeButton: function() {
        // Remove existing rogue mode button if it was there (for re-rendering)
        const existingRogueCard = this.elements.dealersGrid.querySelector('.rogue-mode-card');
        if (existingRogueCard) {
            existingRogueCard.remove();
        }

        const rogueCard = document.createElement('div');
        rogueCard.classList.add('dealer-card', 'rogue-mode-card');
        
        if (this.campaignProgress.rogueModeUnlocked) {
            rogueCard.onclick = () => this.enterRogueMode();
            // Added onerror to the img tag for rogue dealer avatar
            rogueCard.innerHTML = `
                <div class="dealer-avatar" style="border-color: #FF00FF;">
                  <img src="https://placehold.co/80x80/FF00FF/FFFFFF?text=ðŸ”€" alt="Rogue Dealers Avatar" onerror="this.onerror=null; this.src='https://placehold.co/80x80/333/666?text=X'; console.error('Failed to load Rogue Dealers Avatar');">
                </div>
                <div class="dealer-name boss-dealer-name">ROGUE DEALERS</div>
                <div class="dealer-type">Procedural Challenge</div>
                <div class="dealer-description">Face 7 unpredictable AI with randomized strategies and abilities. Endless challenge!</div>
                <div class="dealer-stats">
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Difficulty:</span>
                        <span class="dealer-stat-value">UNBEATABLE</span>
                    </div>
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Rewards:</span>
                        <span class="dealer-stat-value">HIGHEST</span>
                    </div>
                </div>
            `;
            // Add it at the end of the grid
            this.elements.dealersGrid.appendChild(rogueCard);
        } else {
            rogueCard.classList.add('locked');
            let unlockMessage = '';
            let allDealersUnlockedByLevel = true;
            let allDealersBeatenRequiredTimes = true;

            this.dealers.forEach(dealer => {
                if (this.playerLevel < dealer.unlocksAtLevel) {
                    allDealersUnlockedByLevel = false;
                }
                if ((this.campaignProgress.dealerWins[dealer.id] || 0) < this.REQUIRED_WINS_FOR_ROGUE_MODE) {
                    allDealersBeatenRequiredTimes = false;
                }
            });

            if (!allDealersUnlockedByLevel) {
                const highestLevelNeeded = Math.max(...this.dealers.map(d => d.unlocksAtLevel));
                unlockMessage = `Unlock all dealers (Reach Level ${highestLevelNeeded})`;
            } else if (!allDealersBeatenRequiredTimes) {
                let remainingWins = 0;
                this.dealers.forEach(dealer => {
                    remainingWins += Math.max(0, this.REQUIRED_WINS_FOR_ROGUE_MODE - (this.campaignProgress.dealerWins[dealer.id] || 0));
                });
                unlockMessage = `Beat each dealer ${this.REQUIRED_WINS_FOR_ROGUE_MODE} times (Need ${remainingWins} more wins)`;
            }

            rogueCard.innerHTML = `
              <div class="locked-overlay">
                <span>LOCKED: ROGUE MODE</span>
                <span>${unlockMessage}</span>
              </div>
            `;
             // Add it at the end of the grid
            this.elements.dealersGrid.appendChild(rogueCard);
        }
      },

      enterRogueMode: function() {
        if (!this.campaignProgress.rogueModeUnlocked) {
            this.showGameMessage('Rogue Dealer mode is locked!', 'lose');
            return;
        }

        this.isRogueModeActive = true;
        this.rogueDealers = []; // Clear previous rogue dealers
        for (let i = 0; i < 7; i++) { // Generate 7 rogue dealers
            this.rogueDealers.push(this.generateRogueDealer(i));
        }
        this.displayRogueDealers(); // Display the generated dealers
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/4B0082/FF00FF?text=ROGUE+MODE+ENTERING')`;
      },

      displayRogueDealers: function() {
        this.elements.dealersGrid.innerHTML = ''; // Clear existing dealers
        this.rogueDealers.forEach(dealer => {
            const dealerCard = document.createElement('div');
            dealerCard.classList.add('dealer-card', 'rogue-dealer-instance'); // Add a class for rogue instances
            dealerCard.style.borderColor = dealer.color;
            dealerCard.onclick = () => this.selectCampaignDealer(dealer.id); // Re-use selectCampaignDealer

            // Added onerror to the img tag for rogue dealer instances
            dealerCard.innerHTML = `
                <div class="dealer-avatar" style="border-color: ${dealer.color};">
                  <img src="${dealer.avatarSrc}" alt="${dealer.name} Avatar" onerror="this.onerror=null; this.src='https://placehold.co/80x80/333/666?text=X'; console.error('Failed to load ${dealer.avatarSrc}');">
                </div>
                <div class="dealer-name">${dealer.name}</div>
                <div class="dealer-type">${dealer.type}</div>
                <div class="dealer-description">${dealer.description}</div>
                <div class="dealer-stats">
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Strategy:</span>
                        <span class="dealer-stat-value">${dealer.strategy}</span>
                    </div>
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Ability:</span>
                        <span class="dealer-stat-value">${dealer.uniqueAbility.name}</span>
                    </div>
                </div>
                 <div class="dealer-ability-info" style="font-size: 0.75rem; color: #88ffff; margin-top: 10px;">${dealer.uniqueAbility.description}</div>
            `;
            this.elements.dealersGrid.appendChild(dealerCard);
        });
        // Add a "Back to Campaign" button when viewing rogue dealers
        let backButton = document.createElement('button');
        backButton.classList.add('back-button');
        backButton.textContent = 'Back to Campaign Selection';
        backButton.onclick = () => {
            this.isRogueModeActive = false; // Exit rogue mode
            this.showCampaign(); // Go back to original campaign screen
        };
        this.elements.dealersGrid.appendChild(backButton);
      },

      // NEW: Populate available rogue abilities once on init
      populateAvailableRogueAbilities: function() {
        this.availableRogueAbilities = [];
        this.dealers.forEach(dealer => {
            if (dealer.uniqueAbility) {
                // Deep copy the unique ability object to ensure `usedThisGame` is independent
                this.availableRogueAbilities.push(JSON.parse(JSON.stringify(dealer.uniqueAbility)));
            }
        });
      },

      generateRogueDealer: function(index) {
        const adjectives = ['Cyber', 'Neon', 'Quantum', 'Shadow', 'Void', 'Synth', 'Chrono', 'Data', 'Ghost', 'Echo'];
        const nouns = ['Reaper', 'Specter', 'Viper', 'Assassin', 'Warden', 'Jester', 'Phantom', 'Knight', 'Guardian', 'Outlaw'];
        const types = ['Unbeatable', 'Legendary', 'Mythic', 'Apex'];
        // Placeholder image URLs for avatars
        const avatars = [
            'https://placehold.co/80x80/FF00FF/FFFFFF?text=R1', 
            'https://placehold.co/80x80/00FFFF/000000?text=R2',
            'https://placehold.co/80x80/FFFF00/000000?text=R3',
            'https://placehold.co/80x80/FF4500/FFFFFF?text=R4',
            'https://placehold.co/80x80/32CD32/000000?text=R5',
            'https://placehold.co/80x80/8A2BE2/FFFFFF?text=R6',
            'https://placehold.co/80x80/FF69B4/000000?text=R7',
            'https://placehold.co/80x80/00BFFF/000000?text=R8'
        ];
        const colors = ['#FF00FF', '#00FFFF', '#FFFF00', '#FF4500', '#32CD32', '#8A2BE2', '#FF69B4', '#00BFFF'];
        const strategies = ['conservative', 'aggressive', 'advanced', 'optimal', 'unpredictable', 'erratic', 'perfect'];
        // New array for unique rogue room images
        const rogueRoomImages = [
            'https://placehold.co/1920x1080/4B0082/FF00FF?text=ROGUE+SANCTUM',
            'https://placehold.co/1920x1080/004d40/00ffff?text=GLITCHED+REALITY',
            'https://placehold.co/1920x1080/8B0000/FFFF00?text=CORRUPTED+ZONE',
            'https://placehold.co/1920x1080/2F4F4F/32CD32?text=ANOMALY+CHAMBER',
            'https://placehold.co/1920x1080/4682B4/FF69B4?text=NEBULA+ARENA',
            'https://placehold.co/1920x1080/00008B/8A2BE2?text=VOID+CONVERGENCE',
            'https://placehold.co/1920x1080/6A5ACD/00BFFF?text=QUANTUM+RIFT'
        ];

        const randomName = `${adjectives[Math.floor(Math.random() * adjectives.length)]} ${nouns[Math.floor(Math.random() * nouns.length)]}`;
        const randomAvatarSrc = avatars[Math.floor(Math.random() * avatars.length)]; // Randomly pick an image
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        const randomStrategy = strategies[Math.floor(Math.random() * strategies.length)];
        // Assign a unique rogue room image
        const randomRoomImage = rogueRoomImages[index % rogueRoomImages.length]; 
        
        // Pick a random unique ability from the pre-populated pool
        const randomAbility = JSON.parse(JSON.stringify(this.availableRogueAbilities[Math.floor(Math.random() * this.availableRogueAbilities.length)]));
        randomAbility.usedThisGame = false; // Ensure it's reset for the new dealer instance

        return {
            id: `rogue-${index}-${Date.now() + Math.random()}`, // Unique ID for each rogue dealer instance
            name: randomName,
            type: types[Math.floor(Math.random() * types.length)],
            description: 'A rogue AI with unpredictable traits. Approach with caution!',
            avatarSrc: randomAvatarSrc, // Use the randomly selected image path
            color: randomColor,
            music: 'https://www.soundhelix.com/examples/mp3/SoundHelix-Song-14.mp3', // Always use a high-difficulty music
            unlocksAtLevel: 1, // Already unlocked by entering the mode
            betMultiplier: 2.5, // Always highest multiplier
            xpMultiplier: 2.5, // Always highest multiplier
            strategy: randomStrategy,
            hp: 250, // Always highest HP
            isBoss: true, // Treat rogue dealers as bosses for visual effects
            uniqueAbility: randomAbility,
            roomImage: randomRoomImage, // Assign the generated room image
            credits_drop: 500 // Rogue dealers always drop max credits
        };
      },

      // Shop functions
      setupShop: function() {
        this.elements.shopCredits.textContent = this.playerCredits;

        // Render Weekly Pass
        this.elements.weeklyPassGrid.innerHTML = '';
        const passDetails = this.cyberNexusPassDetails;
        const passItem = document.createElement('button');
        passItem.classList.add('shop-item');
        passItem.style.borderColor = '#ffd700'; // Gold border for premium feel
        passItem.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.7)';

        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            passItem.classList.add('pass-active');
            passItem.innerHTML = `
                ${passDetails.name} (Active)<br>
                <span>Benefits active for: <span id="pass-shop-time-remaining"></span></span><br>
                <span>Renews for $${passDetails.priceUSD.toFixed(2)} USD</span><br>
                <span>Daily Bonus: ${passDetails.dailyCreditBonus} Credits</span>
            `;
            passItem.disabled = true; // Cannot buy if already active
            this.updateCyberNexusPassUI(); // Ensure header UI is updated
        } else {
            passItem.innerHTML = `
                ${passDetails.name}<br>
                <span>Access all weekly benefits!</span><br>
                <span>Price: $${passDetails.priceUSD.toFixed(2)} USD</span><br>
                <span>Worth: $${passDetails.worthUSD.toFixed(2)} USD</span><br>
                <span style="color: #00ff00;">(Save $${(passDetails.worthUSD - passDetails.priceUSD).toFixed(2)}!)</span>
            `;
            passItem.onclick = () => this.buyCyberNexusPass();
        }
        this.elements.weeklyPassGrid.appendChild(passItem);


        // Card Skins
        this.elements.cardSkinsGrid.innerHTML = '';
        this.cardSkins.forEach(skin => {
          const skinItem = document.createElement('button');
          skinItem.classList.add('shop-item');
          if (this.purchasedSkins.includes(skin.id)) {
            skinItem.classList.add('purchased');
            if (this.activeCardSkin === skin.id) {
                skinItem.classList.add('active-skin');
                skinItem.textContent = `${skin.name} (Active)`;
            } else {
                skinItem.textContent = `${skin.name} (Owned)`;
                skinItem.onclick = () => this.activateCardSkin(skin.id);
            }
          } else {
            // Apply shop discount if pass is active (NEW)
            let displayPrice = skin.price;
            if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
                displayPrice = Math.round(skin.price * (1 - this.cyberNexusPassDetails.shopDiscount));
                skinItem.innerHTML = `${skin.name}<br><span>${displayPrice} Credits <span style="text-decoration: line-through; color: #888;">${skin.price}</span></span>`;
            } else {
                skinItem.innerHTML = `${skin.name}<br><span>${skin.price} Credits</span>`; // Use innerHTML for newline
            }
            skinItem.onclick = () => this.buyCardSkin(skin.id, displayPrice);
            if (this.playerCredits < displayPrice) {
                skinItem.disabled = true;
            }
          }
          this.elements.cardSkinsGrid.appendChild(skinItem);
        });

        // Power-up Packs - apply discount if pass is active (NEW)
        // Ensure initial prices are set for the buttons in HTML if not dynamic
        const smallPackOriginalPrice = 300;
        const mediumPackOriginalPrice = 750;

        let displaySmallPackPrice = smallPackOriginalPrice;
        let displayMediumPackPrice = mediumPackOriginalPrice;

        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            displaySmallPackPrice = Math.round(smallPackOriginalPrice * (1 - this.cyberNexusPassDetails.shopDiscount));
            displayMediumPackPrice = Math.round(mediumPackOriginalPrice * (1 - this.cyberNexusPassDetails.shopDiscount));
        }

        // Find the specific buttons by index or a more robust selector if they had IDs
        const smallPackButton = this.elements.powerUpsGrid.children[0];
        const mediumPackButton = this.elements.powerUpsGrid.children[1];

        if (smallPackButton) {
            smallPackButton.innerHTML = `Small Pack<br><span>(1 Random Power-up)</span><br><span>${displaySmallPackPrice} Credits ${displaySmallPackPrice !== smallPackOriginalPrice ? `<span style="text-decoration: line-through; color: #888;">${smallPackOriginalPrice}</span>` : ''}</span>`;
            smallPackButton.onclick = () => this.buyPowerPack(1, displaySmallPackPrice);
            smallPackButton.disabled = this.playerCredits < displaySmallPackPrice;
        }

        if (mediumPackButton) {
            mediumPackButton.innerHTML = `Medium Pack<br><span>(3 Random Power-ups)</span><br><span>${displayMediumPackPrice} Credits ${displayMediumPackPrice !== mediumPackOriginalPrice ? `<span style="text-decoration: line-through; color: #888;">${mediumPackOriginalPrice}</span>` : ''}</span>`;
            mediumPackButton.onclick = () => this.buyPowerPack(3, displayMediumPackPrice);
            mediumPackButton.disabled = this.playerCredits < displayMediumPackPrice;
        }
      },

      buyCardSkin: function(skinId, price) {
        if (this.playerCredits >= price) {
          this.playerCredits -= price;
          this.purchasedSkins.push(skinId);
          this.activeCardSkin = skinId; 
          this.showGameMessage(`${this.cardSkins.find(s => s.id === skinId).name} skin purchased and activated!`, 'win');
          this.playSFX('sfx-purchase'); // Play purchase sound
          this.saveGameData();
          this.updateUI();
          this.setupShop(); 
        } else {
          this.showGameMessage('Not enough credits to buy this skin!', 'lose');
        }
      },

      activateCardSkin: function(skinId) {
        if (this.purchasedSkins.includes(skinId)) {
          this.activeCardSkin = skinId;
          this.showGameMessage(`${this.cardSkins.find(s => s.id === skinId).name} skin activated!`, 'win');
          this.playSFX('sfx-purchase'); // Play activate sound (can be same as purchase)
          this.saveGameData();
          this.updateUI();
          this.setupShop(); 
        }
      },

      buyPowerPack: function(packSize, price) { // Price now passed as argument
        if (this.playerCredits >= price) {
            this.playerCredits -= price;
            let purchasedCount = 0;
            for (let i = 0; i < packSize; i++) {
                const powerUpIds = Object.keys(this.powerUps);
                const randomPowerUpId = powerUpIds[Math.floor(Math.random() * powerUpIds.length)];
                this.powerUps[randomPowerUpId]++;
                purchasedCount++;
            }
            this.showGameMessage(`Purchased ${purchasedCount} power-up(s)!`, 'win');
            this.playSFX('sfx-purchase'); // Play purchase sound
            this.saveGameData();
            this.updateUI();
            // No need to call updatePowerUpButtons separately as updateUI handles it
            this.elements.shopCredits.textContent = this.playerCredits; // Update credits in shop view
            this.setupShop(); // Re-render shop items to update button states (disabled/enabled)
        } else {
            this.showGameMessage('Not enough credits to buy this power-up pack!', 'lose');
        }
      },

      // NEW: Cyber Nexus Pass purchase logic
      buyCyberNexusPass: function() {
        // In a real application, this would trigger a payment gateway (e.g., Stripe, Google Play, Apple Pay)
        // For this simulation, we'll assume a successful purchase
        this.showGameMessage(`Connecting to payment system for $${this.cyberNexusPassDetails.priceUSD.toFixed(2)} USD...!?!`, 'tie');
        
        setTimeout(() => {
            const purchaseSuccessful = Math.random() > 0.1; // 90% chance of success for demo

            if (purchaseSuccessful) {
                const now = new Date();
                this.cyberNexusPass.active = true;
                this.cyberNexusPass.expiryDate = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days from now
                
                // Grant immediate bonus
                this.playerCredits += this.cyberNexusPassDetails.dailyCreditBonus * 2; // Double daily bonus as immediate perk
                this.showGameMessage('Cyber Nexus Pass Activated! Enjoy your benefits!', 'win');
                this.playSFX('sfx-purchase'); // Play purchase sound

                // Handle consecutive weeks bonus (if applicable for next purchase)
                // This logic would ideally check the *previous* pass expiry
                // For simplicity, we'll increment on purchase for now, assuming renewal.
                // A more robust system would check if it's a direct renewal.
                this.cyberNexusPass.consecutiveWeeks++;

                // Assign this week's exclusive cosmetic (or a random one for demo)
                this.cyberNexusPass.currentWeeklyCosmetic = this.weeklyCosmeticsPool[Math.floor(Math.random() * this.weeklyCosmeticsPool.length)];
                this.cyberNexusPass.weeklyCosmeticClaimed = true; // Mark as claimed for this week

                this.cyberNexusPass.lastLoginDate = now; // Set initial last login for daily bonus

                this.saveGameData();
                this.updateUI(); // Updates everything including shop and pass indicator
                this.setupShop(); // Re-render shop to show pass as active
                this.checkDailyBonus(); // Check for daily bonus right after purchase
            } else {
                this.showGameMessage('Payment failed. Please try again.', 'lose');
            }
        }, 2000); // Simulate payment processing time
      },

      // NEW: Check and grant daily bonus for pass holders
      checkDailyBonus: function() {
        if (!this.cyberNexusPass.active || (this.cyberNexusPass.expiryDate && this.cyberNexusPass.expiryDate <= new Date())) {
            return; // Pass not active or expired
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0); // Normalize today to start of day

        const lastLogin = this.cyberNexusPass.lastLoginDate;
        let lastLoginDay = null;
        if (lastLogin) {
            lastLoginDay = new Date(lastLogin);
            lastLoginDay.setHours(0, 0, 0, 0); // Normalize last login to start of day
        }

        // If no last login, or if last login was before today
        if (!lastLogin || lastLoginDay.getTime() < today.getTime()) {
            this.playerCredits += this.cyberNexusPassDetails.dailyCreditBonus;
            this.showGameMessage(`Daily Cyber Nexus Pass bonus: +${this.cyberNexusPassDetails.dailyCreditBonus} Credits!`, 'win');
            this.cyberNexusPass.lastLoginDate = new Date(); // Update last login to now
            this.saveGameData();
            this.updateUI();
        }
      },

      // NEW: Update Cyber Nexus Pass UI in header
      updateCyberNexusPassUI: function() {
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate && this.cyberNexusPass.expiryDate > new Date()) {
            this.elements.weeklyPassIndicator.classList.remove('hidden');
            const timeLeft = this.cyberNexusPass.expiryDate.getTime() - new Date().getTime();
            const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

            this.elements.passTimeRemaining.textContent = 
                `${days}d ${hours}h ${minutes}m ${seconds}s`;

            // Also update the time remaining in the shop if it's open
            const shopPassTimeRemaining = document.getElementById('pass-shop-time-remaining');
            if (shopPassTimeRemaining) {
                shopPassTimeRemaining.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
            }

        } else {
            this.cyberNexusPass.active = false; // Ensure it's marked inactive if time runs out
            this.cyberNexusPass.expiryDate = null; // Clear expiry date
            this.elements.weeklyPassIndicator.classList.add('hidden');
            this.saveGameData(); // Save status
            this.setupShop(); // Re-render shop to show pass as buyable
        }
      },

      // NEW: Check pass status on game load (or shop open)
      checkCyberNexusPassStatus: function() {
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate && this.cyberNexusPass.expiryDate <= new Date()) {
            this.cyberNexusPass.active = false;
            this.cyberNexusPass.expiryDate = null;
            this.cyberNexusPass.weeklyCosmeticClaimed = false; // Reset for next week
            this.cyberNexusPass.currentWeeklyCosmetic = null;
            this.showGameMessage('Your Cyber Nexus Pass has expired!', 'lose');
            this.saveGameData();
        } else if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate && this.cyberNexusPass.expiryDate > new Date()) {
            this.checkDailyBonus(); // Grant daily bonus if due
        }
        this.updateCyberNexusPassUI();
      },

      updatePowerUpButtons: function() {
        for (const powerUpId in this.powerUps) {
          const button = document.getElementById(`use-${powerUpId}`);
          if (button) {
            button.querySelector('span').textContent = this.powerUps[powerUpId];
            // Only enable/disable if not under EMP Burst effect
            if (!this.isBrawl || !this.activeBrawlRule || this.activeBrawlRule.id !== 'empBurst') {
                button.disabled = this.powerUps[powerUpId] === 0;
            } else {
                button.disabled = true; // Force disable under EMP Burst
            }
          }
        }
      },

      usePowerUp: function(powerUpId, event) { // Pass event to spawnParticles
        // Prevent power-up use if EMP Burst is active
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'empBurst') {
            this.showGameMessage('EMP Burst active! Power-ups are disabled!', 'lose');
            return;
        }

        if (this.powerUps[powerUpId] > 0) {
          let powerUpEffectiveness = 1;
          if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'powerSurge') {
            powerUpEffectiveness = 1.5; // 50% more effective
            this.showGameMessage('Power Surge bonus applied!', 'win');
          }
          // Apply Cyber Nexus Pass Power-Up Resonance bonus (NEW)
          if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
              powerUpEffectiveness += this.cyberNexusPassDetails.powerUpEffectivenessBonus; // Add small bonus
          }

          switch (powerUpId) {
            case 'extraCard':
              this.playSFX('sfx-powerup-extraCard');
              let cardValueBias = 0;
              // Small chance for better card with pass
              if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date() && Math.random() < this.cyberNexusPassDetails.powerUpEffectivenessBonus * 2) { 
                  cardValueBias = Math.random() < 0.5 ? 10 : 11; // Bias towards 10 or 11
              }
              
              let newCard = this.dealCard(); // Always deal a card first

              if (cardValueBias > 0) { // If biased, try to find a card matching bias (for demo purposes)
                  let foundBiasedCard = false;
                  // Look for a card in the current deck that matches the bias
                  const potentialBiasedCardIndex = this.deck.findIndex(card => card.value === cardValueBias);
                  if (potentialBiasedCardIndex !== -1) {
                      newCard = this.deck.splice(potentialBiasedCardIndex, 1)[0]; // Remove and use the biased card
                      foundBiasedCard = true;
                  }
                  // If not found or if the picked card isn't great, just add the already dealt one.
              }
              
              // If low visibility is active, keep the new card face down
              if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
                  newCard.isFaceDown = true;
              }

              this.playerHand.push(newCard);
              this.updateHandsDisplay();
              
              // Recalculate true total after adding the card
              let playerTotal = 0;
              let playerAces = 0;
              this.playerHand.forEach(card => {
                  let val = card.value;
                  // Use original value for true total if glitch effect is active
                  if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.originalValue !== undefined) {
                      val = card.originalValue;
                  }
                  playerTotal += val;
                  if (card.rank === 'A') playerAces++;
              });
              while (playerTotal > 21 && playerAces > 0) {
                  playerTotal -= 10;
                  playerAces--;
              }

              if (playerTotal > 21) {
                this.endGame('bust');
              } else if (playerTotal === 21) {
                this.stand();
              }
              break;
            case 'peekDealer':
                this.playSFX('sfx-powerup-peekDealer');
                spawnParticles(40 * powerUpEffectiveness, '#ff00ff', 9, 1400, event); 
                const faceDownCard = this.dealerHand.find(card => card.isFaceDown);
                if (faceDownCard) {
                    faceDownCard.isFaceDown = false;
                    this.updateHandsDisplay();
                    this.showGameMessage(`Dealer's hidden card was ${faceDownCard.rank} of ${faceDownCard.suit}!`, 'tie');
                    // Show optimal next move hint (NEW - if pass active)
                    if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
                        const playerCurrentTotal = this.getHandValue(this.playerHand);
                        const dealerCurrentTotal = this.getHandValue(this.dealerHand); // Dealer's full hand is now known
                        let hint = "Consider your options carefully.";
                        // Peek at the next card in the deck for the player
                        const nextPlayerCard = this.deck.length > 0 ? this.deck[this.deck.length - 1] : null;
                        let potentialPlayerHitTotal = playerCurrentTotal;
                        if (nextPlayerCard) {
                            potentialPlayerHitTotal = this.getHandValue([...this.playerHand, nextPlayerCard]);
                        }
                        
                        if (potentialPlayerHitTotal <= 21 && potentialPlayerHitTotal > playerCurrentTotal) {
                            hint = "Hint: Hitting might improve your hand without busting.";
                        } else if (playerCurrentTotal > dealerCurrentTotal && playerCurrentTotal <= 21) {
                            hint = "Hint: Standing looks strong!";
                        } else if (dealerCurrentTotal > playerCurrentTotal && dealerCurrentTotal <= 21) {
                            hint = "Hint: Standing might not be enough. Consider another power-up or special!";
                        } else if (playerCurrentTotal === dealerCurrentTotal) {
                            hint = "Hint: It's a tie, but maybe you can push for a win?";
                        }
                        this.showGameMessage(`Dealer's card revealed! ${hint}`, 'tie');
                    }

                } else {
                    this.showGameMessage('No hidden card to peek!', 'lose');
                    this.powerUps[powerUpId]++; // Refund the power-up if it couldn't be used
                    this.updatePowerUpButtons();
                    return;
                }
                break;
            case 'shieldLoss':
                this.playSFX('sfx-powerup-shieldLoss');
                let healAmount = 20 * powerUpEffectiveness;
                if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
                    healAmount += 5; // Additional 5 HP for pass holders
                }
                spawnParticles(60 * powerUpEffectiveness, '#00ff00', 12, 1700, event); 
                this.playerHP = Math.min(100, this.playerHP + healAmount); 
                this.updateBrawlHUD();
                this.showGameMessage(`Shield activated! Healed for ${healAmount} HP!`, 'win');
                break;
            case 'bomb':
                if (this.isBrawl) {
                    this.playSFX('sfx-powerup-bomb');
                    triggerScreenShake();
                    spawnParticles(80 * powerUpEffectiveness, '#ff0000', 15, 1800, event); 
                    const damageDealt = Math.round(20 * powerUpEffectiveness);
                    this.dealerHP -= damageDealt; 
                    this.updateBrawlHUD();
                    this.showGameMessage(`Brawl Bomb deployed! Dealer took ${damageDealt} damage!`, 'lose');
                    if (this.dealerHP <= 0) {
                        this.endGame('win'); // End the game as a win if dealer is defeated
                        return; 
                    }
                } else {
                    this.showGameMessage('Bomb can only be used in Brawl Mode!', 'lose');
                    this.powerUps[powerUpId]++; // Refund if used in wrong mode
                    this.updatePowerUpButtons();
                    return;
                }
                break;
            case 'freeze':
                this.playSFX('sfx-powerup-freeze');
                spawnParticles(50 * powerUpEffectiveness, '#00aaff', 10, 1600, event); 
                // Freeze effect is handled in dealerTurn
                break;
            case 'doubleXP':
                this.playSFX('sfx-powerup-doubleXP');
                spawnParticles(60 * powerUpEffectiveness, '#ffd700', 12, 1700, event); 
                // Double XP effect is handled in addXP
                break;
          }
          this.powerUps[powerUpId]--;
          this.updatePowerUpButtons();
          this.saveGameData();
        } else {
          this.showGameMessage(`You don't have any ${this.powerUpItems[powerUpId].name}!`, 'lose');
        }
      },

      // Helper for getCardNumericValue for Peek Dealer hint
      getCardNumericValue: function(card) {
        // This function is for getting the actual numerical value of a card, ignoring glitches/face-down states.
        if (card.rank === 'A') return 11;
        if (['K', 'Q', 'J'].includes(card.rank)) return 10;
        return parseInt(card.rank);
      },


      // Brawl Mode specific attacks
      useSpecialAttack: function(event) { // Pass event to spawnParticles
        if (this.isBrawl && this.specialCharge >= 100) {
            this.playSFX('sfx-specialAttack'); // Play special attack sound
            triggerScreenShake();
            spawnParticles(100, '#00aaff', 15, 2000, event); // Increased count, size, duration, neon blue lightning
            this.dealerHP -= 30; 
            this.specialCharge = 0;
            this.updateBrawlHUD();
            this.showGameMessage('Special Attack! Dealer took 30 damage!', 'win');
            if (this.dealerHP <= 0) {
                this.endGame('win'); // End the game as a win if dealer is defeated
                return; 
            }
        } else {
            this.showGameMessage('Special Attack not charged!', 'lose');
        }
      },

      useUltimatePower: function(event) { // Pass event to spawnParticles
        if (this.isBrawl && this.ultimateCharge >= 100) {
            this.playSFX('sfx-ultimate'); // Play ultimate attack sound
            triggerScreenShake();
            spawnParticles(200, '#ff0000', 20, 2500, event); // Significantly increased count, size, duration, light red neon lightning
            this.dealerHP -= 50; 
            this.playerHP += 20; 
            if (this.playerHP > 100) this.playerHP = 100;
            this.ultimateCharge = 0;
            this.updateBrawlHUD();
            this.showGameMessage('ULTIMATE POWER! Massive damage and self-heal!', 'win');
            if (this.dealerHP <= 0) {
                this.endGame('win'); // End the game as a win if dealer is defeated
                return; 
            }
        } else {
            this.showGameMessage('Ultimate Power not charged!', 'lose');
        }
      },

      dealerSpecialAttack: function() {
        if (this.isBrawl && this.playerHP > 0) { // Only attack if player is not already defeated
            this.playSFX('sfx-specialAttack'); // Dealer special attack sound (can be same or different)
            triggerScreenShake();
            spawnParticles(80, '#00aaff', 12, 1500); // Dealer's attack particles, more visible
            const damage = Math.floor(Math.random() * 15) + 15; // Dealer deals 15-30 damage
            
            let finalDamage = damage;
            // Check for Shield of Resilience
            if (this.powerUps.shieldLoss > 0) {
                this.showGameMessage('Shield of Resilience absorbed some damage!', 'tie');
                finalDamage = Math.max(0, damage - 10); // Reduce damage by 10 (or make it zero if shield fully absorbs)
                this.powerUps.shieldLoss--; // Consume one shield charge
                this.updatePowerUpButtons(); // Update button to reflect consumed shield
            }

            this.playerHP -= finalDamage; 
            if (this.playerHP < 0) this.playerHP = 0; // Ensure HP doesn't go below 0
            this.updateBrawlHUD();
            this.showGameMessage(`Dealer used a special attack! You took ${finalDamage} damage!`, 'lose');
            this.addCharge(20, 20); // Dealer's attack also charges player's ultimate/special for balance
            if (this.playerHP <= 0) {
                this.endGame('lose'); // End game if player HP drops to 0
            }
        }
      },

      addCharge: function(specialGain = 0, ultimateGain = 0) {
        if (this.isBrawl) {
            this.specialCharge = Math.min(100, this.specialCharge + specialGain);
            this.ultimateCharge = Math.min(100, this.ultimateCharge + ultimateGain);
            this.updateBrawlHUD();
        }
      },

      // NEW: Glitch in the Matrix helper functions
      applyGlitchEffect: function() {
        // Iterate through all cards currently on display for both player and dealer
        // Do not add 'glitchedValue' to cards still in the deck.
        const allCardsInPlay = [...this.playerHand, ...this.dealerHand];
        allCardsInPlay.forEach(card => {
            // Only glitch cards that are face-up
            if (!card.isFaceDown) {
                // Store original value if not already stored
                if (card.originalValue === undefined) {
                    card.originalValue = card.value;
                }
                // Assign a random glitched value (e.g., between 1 and 11)
                card.glitchedValue = Math.floor(Math.random() * 11) + 1;
            }
        });
        this.updateHandsDisplay(); // Update display to show '??' or glitched values
      },

      revertGlitchEffect: function() {
        const allCardsInPlay = [...this.playerHand, ...this.dealerHand];
        allCardsInPlay.forEach(card => {
            if (card.originalValue !== undefined) {
                card.value = card.originalValue; // Revert to original value
                delete card.glitchedValue; // Remove glitched property
                // Keep originalValue if it's meant to persist or be reapplied by the rule
                // For a temporary rule, it's fine to delete it after revert
                // delete card.originalValue; // Removed this line to maintain originalValue for future re-applications if rule is active again
            }
        });
        this.updateHandsDisplay(); // Update display to show original values
      },

      // NEW: System Overload hazard functions
      applySystemOverload: function() {
        const damage = Math.floor(Math.random() * 6) + 5; // 5-10 damage
        this.playerHP = Math.max(0, this.playerHP - damage);
        this.dealerHP = Math.max(0, this.dealerHP - damage);
        this.updateBrawlHUD();
        triggerScreenShake();
        spawnParticles(150, '#ffaa00', 18, 2000); // Orange/yellow particles for overload
        this.showGameMessage(`SYSTEM OVERLOAD! Both took ${damage} damage!`, 'lose');
        if (this.playerHP <= 0) {
            this.endGame('lose'); // Player loses if HP drops to 0
        }
        if (this.dealerHP <= 0) {
            this.endGame('win'); // Player wins if dealer HP drops to 0
        }
      },

      // NEW: EMP Burst hazard functions
      applyEmpBurst: function() {
        this.updatePowerUpButtons(); // Force disable all power-up buttons
      },

      revertEmpBurst: function() {
        this.updatePowerUpButtons(); // Re-enable based on current count
      },

      // NEW: Limit Barriers hazard functions
      applyLimitBarriers: function() {
        this.isLimitBarrierActive = true;
        // Buttons are disabled/enabled based on playerHitsThisRound in updateHandsDisplay
        this.updateHandsDisplay(); 
      },

      revertLimitBarriers: function() {
        this.isLimitBarrierActive = false;
        this.playerHitsThisRound = 0;
        this.dealerHitsThisRound = 0;
        this.updateHandsDisplay(); // Re-enable buttons if they were disabled
      },


      // Stats Screen Functions
      updateStatsScreen: function() {
        this.elements.statsGames.textContent = this.games;
        this.elements.statsWins.textContent = this.wins;
        const winRate = this.games > 0 ? ((this.wins / this.games) * 100).toFixed(2) : 0;
        this.elements.statsRate.textContent = `${winRate}%`;
        
        let mostUsedPowerUp = 'N/A';
        let maxUsage = -1; // Initialize with -1 to correctly handle 0 usage
        for (const powerUpId in this.powerUps) {
            if (this.powerUps[powerUpId] > maxUsage) {
                maxUsage = this.powerUps[powerUpId];
                mostUsedPowerUp = this.powerUpItems[powerUpId] ? this.powerUpItems[powerUpId].name : powerUpId;
            }
        }
        // If no power-ups have been used, explicitly set to N/A
        if (maxUsage === -1 || maxUsage === 0) {
            mostUsedPowerUp = 'N/A';
        }

        this.elements.statsPowerup.textContent = mostUsedPowerUp;
        this.elements.statsBlackjacks.textContent = this.campaignProgress.totalBlackjacks;
        this.elements.statsBusts.textContent = this.campaignProgress.totalBusts;
      },

      updateLeaderboard: function() {
        this.elements.leaderboard.innerHTML = '';
        const leaderboardData = [
            { name: 'Campaign Streak', value: this.campaignProgress.streaks.campaign },
            { name: 'Best Campaign Streak', value: this.campaignProgress.bestStreak },
            { name: 'Quick Play Streak', value: this.campaignProgress.streaks.quickPlay }
        ];

        leaderboardData.sort((a, b) => b.value - a.value); 

        leaderboardData.forEach((item, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span>${index + 1}. ${item.name}:</span>
                <span>${item.value}</span>
            `;
            this.elements.leaderboard.appendChild(listItem);
        });
      }
    };

    document.addEventListener('DOMContentLoaded', () => {
      game.init();
    });
  </script>
</body>
</html>
