<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyber Blackjack</title>
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    :root {
        --card-back-color: #222; /* Default card back color */
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Orbitron', monospace;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
      color: #00ffff;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0,255,255,0.15) 0%, transparent 40%),
        radial-gradient(circle at 80% 20%, rgba(255,0,255,0.15) 0%, transparent 40%);
      pointer-events: none;
      z-index: -1;
    }

    .dealer-room-bg {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-size: cover;
        background-position: center;
        transition: background-image 0.5s ease-in-out;
        z-index: -2;
        /* Default futuristic background when no dealer is selected */
        background-image: url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB');
    }

    /* General Layout */
    .container {
      width: 90%;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #00ffff;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.3);
      border-radius: 10px;
      position: relative;
      z-index: 1;
      animation: neon-border-pulse 3s infinite alternate;
    }

    @keyframes neon-border-pulse {
      from { border-color: #00ffff; box-shadow: 0 0 20px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.3); }
      to { border-color: #ff00ff; box-shadow: 0 0 30px rgba(255, 0, 255, 0.7), inset 0 0 15px rgba(255, 0, 255, 0.5); }
    }

    h1, h2 {
      text-align: center;
      margin-bottom: 20px;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.7);
    }

    /* .hidden class is kept for reference but no longer applied to screens for always-visible mode */
    .hidden {
      display: none !important;
    }

    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding: 10px 0;
      border-bottom: 1px dashed #00ffff;
    }

    .header-left, .header-right {
      display: flex;
      align-items: center;
    }

    .header-info {
      margin-left: 15px;
      font-size: 1.1rem;
      color: #00ffdd;
    }
    
    .xp-bar {
      width: 150px;
      height: 15px;
      background-color: #333;
      border: 1px solid #00ffff;
      border-radius: 5px;
      overflow: hidden;
      margin-left: 10px;
      position: relative;
    }

    .xp-bar-fill {
      height: 100%;
      background-color: #00ff88;
      width: 0%;
      transition: width 0.5s ease-out;
      border-radius: 3px;
    }

    .xp-text {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        color: #000;
        text-shadow: 0 0 2px #00ffff;
    }

    /* Weekly Pass Indicator */
    .pass-indicator {
        margin-left: 15px;
        font-size: 0.9rem;
        color: #ffd700;
        background: rgba(255, 215, 0, 0.1);
        padding: 5px 10px;
        border-radius: 5px;
        border: 1px solid #ffd700;
        animation: neon-glow-small 1.5s infinite alternate;
    }

    @keyframes neon-glow-small {
        from { box-shadow: 0 0 5px rgba(255, 215, 0, 0.7); }
        to { box-shadow: 0 0 8px rgba(255, 215, 0, 0.9); }
    }


    /* Main Menu */
    .main-menu, .campaign-section, .powerups-section, .shop-screen, .stats-screen, .pvp-lobby {
      display: flex;
      flex-direction: column;
      gap: 15px;
      align-items: center;
      justify-content: center;
    }

    .menu-button, .bet-button, .game-button, .shop-button, .back-button, .powerup-button {
      background: #00aaff;
      color: #fff;
      border: 2px solid #00ffff;
      padding: 12px 25px;
      font-family: 'Orbitron', monospace;
      font-size: 1.2rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      text-shadow: 0 0 5px rgba(255,255,255,0.5);
      box-shadow: 0 0 10px rgba(0, 170, 255, 0.7);
    }

    .menu-button:hover, .bet-button:hover, .game-button:hover, .shop-button:hover, .back-button:hover, .powerup-button:hover {
      background: #00ffff;
      color: #000;
      border-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.9);
      transform: translateY(-2px);
    }

    .menu-button:disabled, .game-button:disabled, .powerup-button:disabled {
      background: #555;
      border-color: #777;
      color: #bbb;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* Betting Section */
    .betting-section, .game-area {
      text-align: center;
    }

    .bet-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 8px;
      font-family: 'Orbitron', monospace;
      font-size: 1rem;
      border-radius: 5px;
      margin-bottom: 20px;
      width: 150px;
    }

    .bet-options {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
    }

    /* Game Area */
    .game-board {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      margin-top: 20px;
    }

    .player-section, .dealer-section {
      width: 100%;
      text-align: center;
      background: rgba(0, 0, 0, 0.4);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #00ffff;
      box-shadow: inset 0 0 5px #00ffff;
    }

    .hand-display {
      display: flex;
      justify-content: center;
      min-height: 120px; /* To prevent layout shift */
      gap: 10px;
      flex-wrap: wrap;
    }

    .card {
      width: 80px;
      height: 110px;
      background-color: #fff;
      border: 2px solid #00aaff;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0, 170, 255, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
      position: relative;
      transition: transform 0.5s;
      transform-style: preserve-3d;
      perspective: 1000px;
    }
    
    .card-inner {
      width: 100%;
      height: 100%;
      position: relative;
      transform-style: preserve-3d;
      transition: transform 0.5s;
    }

    .card.flipped .card-inner {
      transform: rotateY(180deg);
    }

    .card-front, .card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 5px;
      box-sizing: border-box;
    }

    .card-front {
      background-color: #fff;
      color: #000;
      border: 1px solid #00aaff;
    }

    .card-front span {
      font-size: 1.2rem;
      line-height: 1;
    }

    .card-front span:first-child { align-self: flex-start; }
    .card-front span:last-child { align-self: flex-end; }
    .card-front span:nth-child(2) { font-size: 2rem; } /* Suit symbol */

    .card-front.red { color: #ff0000; }
    .card-front.black { color: #000000; }


    .card-back {
      background-color: var(--card-back-color); /* Dynamic color */
      transform: rotateY(180deg);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
      font-size: 0.8rem;
      text-shadow: 0 0 5px rgba(255,255,255,0.5);
      border: 1px solid #00ffff;
      box-shadow: inset 0 0 5px rgba(0,255,255,0.7);
    }
    
    .game-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
    }

    .message {
      margin-top: 20px;
      font-size: 1.3rem;
      font-weight: bold;
      padding: 10px;
      border-radius: 5px;
      animation: pulse 1s infinite alternate;
    }

    .message.win {
        color: #00ff00;
        text-shadow: 0 0 8px #00ff00;
        border: 1px solid #00ff00;
    }
    .message.lose {
        color: #ff0000;
        text-shadow: 0 0 8px #ff0000;
        border: 1px solid #ff0000;
    }
    .message.tie {
        color: #ffff00;
        text-shadow: 0 0 8px #ffff00;
        border: 1px solid #ffff00;
    }

    @keyframes pulse {
      from { transform: scale(1); opacity: 1; }
      to { transform: scale(1.02); opacity: 0.9; }
    }

    .post-game-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
    }

    .risk-game-section {
        margin-top: 20px;
        border-top: 1px dashed #00ffff;
        padding-top: 15px;
        text-align: center;
    }

    .risk-game-section button {
        background-color: #ffaa00;
        border-color: #ffff00;
        color: #333;
    }
    .risk-game-section button:hover {
        background-color: #ffff00;
        border-color: #ffaa00;
        color: #000;
    }

    /* Campaign Section */
    .dealers-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }

    .dealer-card {
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid; /* Color set by JS */
        border-radius: 10px;
        padding: 15px;
        text-align: center;
        cursor: pointer;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
        position: relative;
        overflow: hidden;
    }

    .dealer-card:hover:not(.locked) {
        transform: translateY(-5px);
        box-shadow: 0 0 15px currentColor; /* Uses border color */
    }

    .dealer-card.locked {
        opacity: 0.5;
        cursor: not-allowed;
        filter: grayscale(100%);
    }

    .dealer-card .locked-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: #ff0000;
        font-weight: bold;
        text-shadow: 0 0 5px #ff0000;
        font-size: 1.2rem;
        gap: 5px;
    }

    .dealer-avatar {
        font-size: 3rem;
        margin-bottom: 10px;
        border-radius: 50%;
        border: 3px solid; /* Color set by JS */
        width: 80px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 auto 10px;
    }

    .dealer-name {
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 5px;
    }

    .boss-dealer-name {
        animation: boss-neon-pulse 2s infinite alternate;
    }

    @keyframes boss-neon-pulse {
        from { color: #ffd700; text-shadow: 0 0 10px #ffd700; }
        to { color: #ff00ff; text-shadow: 0 0 15px #ff00ff; }
    }

    .dealer-type {
        font-size: 0.9rem;
        opacity: 0.8;
        margin-bottom: 10px;
    }

    .dealer-description {
        font-size: 0.9rem;
        margin-bottom: 15px;
    }

    .dealer-stats {
        display: flex;
        justify-content: space-around;
        font-size: 0.85rem;
        border-top: 1px dashed rgba(0, 255, 255, 0.5);
        padding-top: 10px;
    }

    .dealer-stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .dealer-stat-label {
        font-weight: bold;
        color: #00ff88;
    }
    .dealer-stat-value {
        margin-top: 3px;
        color: #00ffff;
    }

    .current-dealer-info {
        display: flex;
        align-items: center;
        gap: 15px;
        background: rgba(0, 0, 0, 0.5);
        border: 2px solid #00ffff;
        padding: 10px 20px;
        border-radius: 8px;
        margin-top: 15px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    .current-dealer-info .current-dealer-avatar {
        font-size: 2.5rem;
        border-radius: 50%;
        border: 2px solid;
        width: 60px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Shop Screen */
    .shop-section {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .shop-category {
        margin-bottom: 20px;
    }

    .shop-category h3 {
        text-align: center;
        color: #ff00ff;
        text-shadow: 0 0 8px #ff00ff;
        margin-bottom: 15px;
        border-bottom: 1px dashed #ff00ff;
        padding-bottom: 5px;
    }

    .shop-items-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
    }

    .shop-item {
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        font-family: 'Orbitron', monospace;
        color: #00ffff;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .shop-item:hover:not(.purchased):not(.active-skin):not(.pass-active) {
        background: rgba(0, 170, 255, 0.3);
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
    }

    .shop-item.purchased {
        border-color: #00ff00;
        color: #00ff00;
        opacity: 0.8;
        cursor: default;
    }

    .shop-item.active-skin, .shop-item.pass-active {
        border-color: #ff00ff;
        color: #ff00ff;
        box-shadow: 0 0 15px #ff00ff;
        font-weight: bold;
    }

    .shop-item span {
        font-size: 0.8rem;
        color: #aaa;
        display: block;
        margin-top: 5px;
    }

    /* Power-up Controls in Game Area */
    .powerup-controls {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-top: 15px;
    }
    .powerup-controls .powerup-button {
        background-color: #ff6600;
        border-color: #ff9900;
        color: #eee;
    }
    .powerup-controls .powerup-button:hover {
        background-color: #ff9900;
        border-color: #ff6600;
        color: #000;
    }

    /* Brawl Mode HUD */
    .brawl-hud {
        display: flex;
        justify-content: space-around;
        margin-top: 20px;
        width: 100%;
    }

    .hp-bar-container {
        width: 45%;
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid #00ffff;
        border-radius: 8px;
        padding: 10px;
        text-align: center;
        box-shadow: inset 0 0 5px #00ffff;
    }

    .hp-bar-label {
        font-size: 1rem;
        margin-bottom: 5px;
    }

    .hp-bar {
        width: 100%;
        height: 20px;
        background-color: #333;
        border: 1px solid #00ff00;
        border-radius: 5px;
        overflow: hidden;
    }

    .hp-bar-fill {
        height: 100%;
        background-color: #00ff00; /* Green for player */
        width: 100%;
        transition: width 0.3s ease-out, background-color 0.3s ease-out;
    }

    .hp-bar-fill.dealer {
        background-color: #00aaff; /* Blue for dealer */
    }

    .hp-text-display {
        font-size: 1.1rem;
        font-weight: bold;
        margin-top: 5px;
    }

    .brawl-special-controls {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-top: 20px;
    }

    .charge-bar-container {
        width: 150px;
        height: 15px;
        background-color: #333;
        border: 1px solid #ff00ff;
        border-radius: 5px;
        overflow: hidden;
        margin-left: 10px;
        position: relative;
    }

    .charge-bar-fill {
        height: 100%;
        background-color: #ff00ff;
        width: 0%;
        transition: width 0.5s ease-out;
        border-radius: 3px;
    }

    .charge-text {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        color: #000;
        text-shadow: 0 0 2px #ff00ff;
    }
    
    #special-attack-btn {
        background-color: #ff00ff;
        border-color: #ff00ff;
        color: #000;
    }
    #special-attack-btn:hover {
        background-color: #00ffff;
        border-color: #ff00ff;
        color: #000;
    }
    #ultimate-btn {
        background-color: #ff0000;
        border-color: #ff5500;
        color: #fff;
    }
    #ultimate-btn:hover {
        background-color: #ff5500;
        border-color: #ff0000;
        color: #000;
    }

    /* Stats Screen */
    .stats-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
    }
    .stats-item {
        font-size: 1.1rem;
        padding: 8px;
        border: 1px dashed #00ffff;
        border-radius: 5px;
        width: 100%;
        max-width: 400px;
        text-align: center;
    }
    .stats-item span {
        color: #00ff88;
        font-weight: bold;
        margin-left: 10px;
    }
    .leaderboard-list {
        list-style: none;
        padding: 0;
        margin-top: 20px;
        width: 100%;
        max-width: 500px;
    }
    .leaderboard-list li {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid #ff00ff;
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    /* PvP Lobby */
    .pvp-lobby {
        text-align: center;
    }
    .pvp-status {
        font-size: 1.2rem;
        margin-bottom: 20px;
        color: #00ff88;
    }

    /* Game Deck for animations */
    .game-deck {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 110px;
        background-color: var(--card-back-color);
        border: 2px solid #00ffff;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        z-index: 0; /* Behind other elements */
        display: flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 0.8rem;
        opacity: 0.8;
    }

    .game-deck.shuffle-animation {
        animation: shuffle-deck 0.5s ease-out;
    }

    @keyframes shuffle-deck {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        25% { transform: translate(-55%, -50%) rotate(5deg); }
        50% { transform: translate(-50%, -50%) rotate(0deg); }
        75% { transform: translate(-45%, -50%) rotate(-5deg); }
        100% { transform: translate(-50%, -50%) rotate(0deg); }
    }

    /* Screen Shake Effect */
    body.screen-shake {
        animation: shake 0.2s cubic-bezier(.36,.07,.19,.97) both;
        transform: translate3d(0, 0, 0);
        backface-visibility: hidden;
        perspective: 1000px;
    }

    @keyframes shake {
        10%, 90% { transform: translate3d(-1px, 0, 0); }
        20%, 80% { transform: translate3d(2px, 0, 0); }
        30%, 70% { transform: translate3d(-4px, 0, 0); }
        40%, 60% { transform: translate3d(4px, 0, 0); }
        50% { transform: translate3d(-4px, 0, 0); }
    }

    /* Particle Effects (for JS generated elements) */
    .particle {
        position: fixed;
        background-color: #fff; /* Default, overridden by JS */
        border-radius: 50%;
        animation: fadeOut 1.5s forwards; /* Increased duration */
        pointer-events: none;
        z-index: 9999;
    }

    @keyframes fadeOut {
        from { opacity: 1; transform: scale(1); }
        to { opacity: 0; transform: scale(0); }
    }

    .rogue-mode-card {
        border-color: #FF00FF !important;
        box-shadow: 0 0 15px rgba(255, 0, 255, 0.7) !important;
    }

    .rogue-mode-card .dealer-name {
        animation: boss-neon-pulse 1.5s infinite alternate;
    }
  </style>
</head>
<body>
  <div class="dealer-room-bg" id="dealer-room-bg"></div>
  <audio id="dealer-music" loop preload="auto"></audio>

  <!-- Audio elements for sound effects -->
  <audio id="sfx-hit" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" preload="auto"></audio> <!-- Replace with actual hit sound -->
  <audio id="sfx-stand" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" preload="auto"></audio> <!-- Replace with actual stand sound -->
  <audio id="sfx-doubledown" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" preload="auto"></audio> <!-- Replace with actual double down sound -->
  <audio id="sfx-win" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3" preload="auto"></audio> <!-- Replace with actual win sound -->
  <audio id="sfx-lose" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3" preload="auto"></audio> <!-- Replace with actual lose sound -->
  <audio id="sfx-tie" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-6.mp3" preload="auto"></audio> <!-- Replace with actual tie sound -->
  <audio id="sfx-powerup-extraCard" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-7.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-peekDealer" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-8.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-shieldLoss" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-9.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-bomb" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-10.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-freeze" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-11.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-powerup-doubleXP" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-12.mp3" preload="auto"></audio> <!-- Replace with actual powerup sound -->
  <audio id="sfx-specialAttack" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-13.mp3" preload="auto"></audio> <!-- Replace with actual special attack sound -->
  <audio id="sfx-ultimate" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-14.mp3" preload="auto"></audio> <!-- Replace with actual ultimate attack sound -->
  <audio id="sfx-levelUp" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-15.mp3" preload="auto"></audio> <!-- Replace with actual level up sound -->
  <audio id="sfx-purchase" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-16.mp3" preload="auto"></audio> <!-- Replace with actual purchase sound -->

  <div class="container">
    <div class="header">
      <div class="header-left">
        <div class="header-info">Credits: <span id="credits">1000</span></div>
        <div class="header-info">Level: <span id="player-level">1</span></div>
        <div class="xp-bar">
          <div class="xp-bar-fill" id="xp-bar-fill"></div>
          <span class="xp-text" id="xp-text"><span id="player-xp">0</span>/<span id="xp-to-next">100</span> XP</span>
        </div>
        <div id="weekly-pass-indicator" class="pass-indicator hidden">Cyber Nexus Pass: <span id="pass-time-remaining"></span></div>
      </div>
      <div class="header-right">
        <div class="header-info">Wins: <span id="wins">0</span></div>
        <div class="header-info">Games: <span id="games">0</span></div>
      </div>
    </div>

    <!-- Main menu screen -->
    <div id="main-menu" class="main-menu screen"> 
      <h2>Cyber Blackjack</h2>
      <button class="menu-button" onclick="game.showQuickPlay()">Quick Play</button>
      <button class="menu-button" onclick="game.showCampaign()">Campaign Mode</button>
      <button class="menu-button" onclick="game.startBrawlMode()">Brawl Mode</button>
      <button class="menu-button" onclick="game.openShopScreen()">Shop</button>
      <button class="menu-button" onclick="game.openStatsScreen()">Stats</button>
      <button class="menu-button" onclick="game.startPvP()">PvP Online</button>
      <button class="menu-button" onclick="game.resetAllDataConfirmation()">Reset Game Data</button>
    </div>

    <!-- Betting section screen - initially hidden -->
    <div id="betting-section" class="betting-section screen hidden"> 
      <h2>Place Your Bet</h2>
      <div id="current-dealer-info" class="current-dealer-info hidden"></div>
      <input type="number" id="bet-amount" class="bet-input" value="50" min="10" step="10">
      <div class="bet-options">
        <button class="bet-button" onclick="game.adjustBet(-100)">-100</button>
        <button class="bet-button" onclick="game.adjustBet(-10)">-10</button>
        <button class="bet-button" onclick="game.adjustBet(10)">+10</button>
        <button class="bet-button" onclick="game.adjustBet(100)">+100</button>
        <button class="bet-button" onclick="game.betMax()">Max Bet</button>
      </div>
      <button class="menu-button" onclick="game.startGame()">Deal Cards</button>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- Campaign section screen - initially hidden -->
    <div id="campaign-section" class="campaign-section screen hidden">
        <h2>Choose Your Dealer</h2>
        <div id="dealers-grid" class="dealers-grid">
        </div>
        <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- Game area screen - initially hidden -->
    <div id="game-area" class="game-area screen hidden">
      <div class="game-board">
        <div id="dealer-section" class="dealer-section">
          <h3>Dealer (<span id="dealer-total">Total: 0</span>)</h3>
          <div id="dealer-cards" class="hand-display"></div>
        </div>

        <div id="brawl-hud" class="brawl-hud hidden">
            <div class="hp-bar-container player-hp-container">
                <div class="hp-bar-label">Player HP</div>
                <div class="hp-bar">
                    <div id="player-hp-bar" class="hp-bar-fill"></div>
                </div>
                <div id="player-hp" class="hp-text-display">100</div>
            </div>
            <div class="hp-bar-container dealer-hp-container">
                <div class="hp-bar-label">Dealer HP</div>
                <div class="hp-bar">
                    <div id="dealer-hp-bar" class="hp-bar-fill dealer"></div>
                </div>
                <div id="dealer-hp" class="hp-text-display">100</div>
            </div>
        </div>

        <div id="player-section" class="player-section">
          <h3>Player (<span id="player-total">Total: 0</span>)</h3>
          <div id="player-cards" class="hand-display"></div>
        </div>
      </div>

      <div id="powerup-controls" class="powerup-controls hidden">
        <button id="use-extraCard" class="powerup-button" onclick="game.usePowerUp('extraCard')">Extra Card (<span id="extraCard-count">0</span>)</button>
        <button id="use-peekDealer" class="powerup-button" onclick="game.usePowerUp('peekDealer')">Peek Dealer (<span id="peekDealer-count">0</span>)</button>
        <button id="use-shieldLoss" class="powerup-button" onclick="game.usePowerUp('shieldLoss')">Shield (<span id="shieldLoss-count">0</span>)</button>
        <button id="use-bomb" class="powerup-button" onclick="game.usePowerUp('bomb')">Bomb (<span id="bomb-count">0</span>)</button>
        <button id="use-freeze" class="powerup-button" onclick="game.usePowerUp('freeze')">Freeze (<span id="freeze-count">0</span>)</button>
        <button id="use-doubleXP" class="powerup-button" onclick="game.usePowerUp('doubleXP')">2x XP (<span id="doubleXP-count">0</span>)</button>
      </div>

      <div id="message-area" class="message hidden"></div>

      <div id="game-controls" class="game-controls">
        <button id="hit-btn" class="game-button" onclick="game.hit()">Hit</button>
        <button id="stand-btn" class="game-button" onclick="game.stand()">Stand</button>
        <button id="double-btn" class="game-button" onclick="game.doubleDown()">Double Down</button>
      </div>

      <div id="brawl-special-controls" class="brawl-special-controls hidden">
        <div class="charge-bar-container">
            <div class="charge-bar-fill" id="special-charge-bar-fill" style="background-color: #ff00ff;"></div>
            <span class="charge-text" id="special-charge">0% Special</span>
        </div>
        <button id="special-attack-btn" class="game-button" onclick="game.useSpecialAttack()">Special Attack</button>
        <div class="charge-bar-container">
            <div class="charge-bar-fill" id="ultimate-charge-bar-fill" style="background-color: #ff0000;"></div>
            <span class="charge-text" id="ultimate-charge">0% Ultimate</span>
        </div>
        <button id="ultimate-btn" class="game-button" onclick="game.useUltimatePower()">Ultimate Power</button>
      </div>

      <div id="post-game-controls" class="post-game-controls hidden">
        <button class="menu-button" onclick="game.startGame()">New Round</button>
        <button id="risk-button" class="game-button risk-game-section" onclick="game.startRiskGame()">Risk Game (Double or Nothing)</button>
        <div id="risk-result" class="message"></div>
        <button class="back-button" onclick="game.backToMenu()">Back to Menu</button>
      </div>
    </div>

    <!-- Shop screen - initially hidden -->
    <div id="shop-screen" class="shop-screen screen hidden"> 
      <h2>Cyber Shop</h2>
      <p>Your Credits: <span id="shop-credits">1000</span></p>
      <div class="shop-section">
        <!-- New Category for Weekly Pass -->
        <div class="shop-category">
          <h3>Cyber Nexus Pass</h3>
          <div id="weekly-pass-grid" class="shop-items-grid">
            <!-- Pass item will be dynamically inserted here -->
          </div>
        </div>
        <div class="shop-category">
          <h3>Card Skins</h3>
          <div id="card-skins" class="shop-items-grid">
          </div>
        </div>
        <div class="shop-category">
          <h3>Power-Up Packs</h3>
          <div id="powerup-packs" class="shop-items-grid">
            <button class="shop-item" onclick="game.buyPowerPack(1)">
              Small Pack<br><span>(1 Random Power-up)</span><br><span>300 Credits</span>
            </button>
            <button class="shop-item" onclick="game.buyPowerPack(3)">
              Medium Pack<br><span>(3 Random Power-ups)</span><br><span>750 Credits</span>
            </button>
          </div>
        </div>
      </div>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- Stats screen - initially hidden -->
    <div id="stats-screen" class="stats-screen screen hidden"> 
      <h2>Player Statistics</h2>
      <div class="stats-container">
        <div class="stats-item">Games Played: <span id="stats-games">0</span></div>
        <div class="stats-item">Games Won: <span id="stats-wins">0</span></div>
        <div class="stats-item">Win Rate: <span id="stats-rate">0%</span></div>
        <div class="stats-item">Most Used Power-Up: <span id="stats-powerup">N/A</span></div>
        <div class="stats-item">Total Blackjacks: <span id="stats-blackjacks">0</span></div>
        <div class="stats-item">Total Busts: <span id="stats-busts">0</span></div>
      </div>
      <h3>Leaderboard (Campaign Streaks)</h3>
      <ul id="leaderboard" class="leaderboard-list">
      </ul>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>

    <!-- PvP lobby screen - initially hidden -->
    <div id="pvp-lobby" class="pvp-lobby screen hidden"> 
      <h2>PvP Online</h2>
      <p class="pvp-status" id="pvp-status">Connecting to server...</p>
      <button class="menu-button" onclick="game.cancelPvP()">Cancel Search</button>
      <button class="back-button" onclick="game.backToMenu()">Back to Main Menu</button>
    </div>
  </div>

  <div id="game-deck" class="game-deck hidden">Deck</div>

  <script>
    // Global utility functions (can be moved into game object if preferred, but useful globally for effects)
    function triggerScreenShake() {
      document.body.classList.add('screen-shake');
      setTimeout(() => {
        document.body.classList.remove('screen-shake');
      }, 200); // Duration of the shake animation
    }

    /**
     * Spawns multiple particles with customizable color, size, and duration.
     * Particles will originate near the mouse click or screen center and spread.
     * @param {number} count - Number of particles to spawn.
     * @param {string} color - CSS color string for particles (e.g., '#FF00FF').
     * @param {number} [maxSize=5] - Maximum size of particles in pixels.
     * @param {number} [duration=1000] - Duration of particle animation in milliseconds.
     * @param {Event} [event=null] - Optional event object to spawn particles at cursor position.
     */
    function spawnParticles(count, color, maxSize = 5, duration = 1500, event = null) {
        for (let i = 0; i < count; i++) {
            const particle = document.createElement('div');
            particle.classList.add('particle');
            particle.style.backgroundColor = color;
            // Larger and more varied size
            const size = Math.random() * (maxSize - 5) + 5 + 'px'; // Min size 5px for better visibility
            particle.style.width = size;
            particle.style.height = size;

            // Start from center of the screen or event position if available
            const startX = event ? event.clientX : window.innerWidth / 2;
            const startY = event ? event.clientY : window.innerHeight / 2;
            
            // Randomize starting position slightly around the central point
            const offsetX = (Math.random() - 0.5) * 50; // -25 to +25 pixels
            const offsetY = (Math.random() - 0.5) * 50; // -25 to +25 pixels

            particle.style.left = (startX + offsetX) + 'px';
            particle.style.top = (startY + offsetY) + 'px';

            // Increase speed/distance for wider spread
            const angle = Math.random() * Math.PI * 2; // Full 360-degree spread
            const distance = Math.random() * 300 + 150; // Spread from 150 to 450 pixels away
            const endX = startX + distance * Math.cos(angle);
            const endY = startY + distance * Math.sin(angle);

            particle.style.transition = `transform ${duration / 1000}s ease-out, opacity ${duration / 1000}s forwards`;
            setTimeout(() => {
                // Ensure the transform translates from the initial position relative to the viewport
                particle.style.transform = `translate(${endX - (startX + offsetX)}px, ${endY - (startY + offsetY)}px)`;
                particle.style.opacity = 0;
            }, 10);
            document.body.appendChild(particle);
            particle.addEventListener('transitionend', () => {
                particle.remove();
            });
        }
    }


    // Main Game Object
    const game = {
      playerCredits: 1000,
      wins: 0,
      games: 0,
      playerLevel: 1,
      playerXP: 0,
      xpToNextLevel: 100,
      playerHand: [],
      dealerHand: [],
      deck: [],
      isGameActive: false,
      currentBet: 0,
      isBrawl: false,
      playerHP: 100,
      dealerHP: 100,
      specialCharge: 0,
      ultimateCharge: 0,
      powerUps: {
        extraCard: 0,
        peekDealer: 0,
        shieldLoss: 0,
        bomb: 0,
        freeze: 0,
        doubleXP: 0
      },
      purchasedSkins: ['default'],
      activeCardSkin: 'default',
      dealers: [
        { id: 'novice', name: 'Cypher-Bot 7', type: 'Novice', description: 'A basic AI. Prone to errors, easy to beat.', avatar: 'ðŸ¤–', color: '#00ff80', music: 'assets/music/novice_theme.mp3', unlocksAtLevel: 1, betMultiplier: 1, xpMultiplier: 1, strategy: 'conservative', hp: 100,
          roomImage: 'https://placehold.co/1920x1080/003300/00ff80?text=CYPHER-BOT+ROOM',
          uniqueAbility: {
            name: 'RESERVE CARD',
            description: 'ONCE PER GAME, IF THE DEALER BUSTS, THEY CAN DISCARD ONE OF THEIR CARDS AND DRAW A NEW ONE, BUT THE TOTAL VALUE CANNOT EXCEED 21. SLIGHT CHANCE OF DEALER DRAWING AN ACE AS THEIR NEW CARD.',
            id: 'novice_ability',
            usedThisGame: false 
          }
        },
        { id: 'conservative', name: 'Data-Samurai', type: 'Conservative', description: 'Plays it safe, rarely takes risks.', avatar: 'ðŸ¥‹', color: '#4169e1', music: 'assets/music/conservative_theme.mp3', unlocksAtLevel: 3, betMultiplier: 1.2, xpMultiplier: 1.2, strategy: 'conservative', hp: 120,
          roomImage: 'https://placehold.co/1920x1080/000033/4169e1?text=DATA-SAMURAI+DOJO',
          uniqueAbility: {
            name: 'FOCUSED DRAW',
            description: 'LOW CHANCE AT THE START OF DEALER\'S TURN IF CURRENT HAND IS 12-16. DEALER DRAWS THE NEXT CARD IN THE DECK (INSTEAD OF SHUFFLING) IF IT IMPROVES THEIR HAND WITHOUT BUSTING.',
            id: 'conservative_ability',
            usedThisGame: false
          }
        },
        { id: 'aggressive', name: 'Neon Nighthawk', type: 'Aggressive', description: 'High risk, high reward. Loves to hit!', avatar: 'ðŸ¦…', color: '#ff4500', music: 'assets/music/aggressive_theme.mp3', unlocksAtLevel: 5, betMultiplier: 1.5, xpMultiplier: 1.5, strategy: 'aggressive', hp: 150,
          roomImage: 'https://placehold.co/1920x1080/331100/ff4500?text=NEON+NIGHTHAWK+ARENA',
          uniqueAbility: {
            name: 'AGGRESSIVE BET',
            description: 'SMALL CHANCE AT THE START OF ANY ROUND. FORCES THE PLAYER\'S CURRENT BET TO DOUBLE (IF PLAYER HAS ENOUGH CREDITS).',
            id: 'aggressive_ability',
            usedThisGame: false
          }
        },
        { id: 'calculating', name: 'The Quantum Quasar', type: 'Calculating', description: 'Analyzes odds, exploits weaknesses.', avatar: 'ðŸŒŒ', color: '#9370db', music: 'assets/music/calculating_theme.mp3', unlocksAtLevel: 8, betMultiplier: 1.8, xpMultiplier: 1.8, strategy: 'advanced', hp: 180,
          roomImage: 'https://placehold.co/1920x1080/110033/9370db?text=QUANTUM+QUASAR+LAB',
          uniqueAbility: {
            name: 'CARD PREDICTION',
            description: 'LOW CHANCE AT THE START OF DEALER\'S TURN IF DEALER HAND IS 14-16. DEALER "PREDICTS" THE NEXT CARD. IF IT HELPS REACH 17-21, THEY TAKE IT. IF NOT, THEY RESHUFFLE THE TOP FEW CARDS.',
            id: 'calculating_ability',
            usedThisGame: false
          }
        },
        { id: 'master', name: 'Zenith', type: 'Master', description: 'The ultimate challenge. Only for true champions.', avatar: 'ðŸ‘½', color: '#ffd700', music: 'assets/music/master_theme.mp3', unlocksAtLevel: 10, betMultiplier: 2.0, xpMultiplier: 2.0, strategy: 'optimal', hp: 200,
          roomImage: 'https://placehold.co/1920x1080/333300/ffd700?text=ZENITH+CORE',
          uniqueAbility: {
            name: 'ADAPTIVE STRATEGY',
            description: 'MEDIUM CHANCE IF DEALER IS LOSING OR HAS A WEAK HAND. TEMPORARILY SWITCHES THEIR STRATEGY TO BE MORE OPTIMAL OR RISKY FOR THE CURRENT HAND.',
            id: 'master_ability',
            usedThisGame: false
          }
        },
        { id: 'expert', name: 'Shadow Weaver', type: 'Expert', description: 'Strikes from the shadows, unpredictable moves.', avatar: 'ðŸ‘»', color: '#8A2BE2', music: 'assets/music/expert_theme.mp3', unlocksAtLevel: 12, betMultiplier: 2.2, xpMultiplier: 2.2, strategy: 'unpredictable', hp: 220,
          roomImage: 'https://placehold.co/1920x1080/1a0033/8A2BE2?text=SHADOW+LAIR',
          uniqueAbility: {
            name: 'HIDDEN CARD SWAP',
            description: 'VERY LOW CHANCE AFTER INITIAL DEAL OR AFTER DEALER HITS. SECRETLY SWAPS ONE OF THEIR FACE-DOWN CARDS WITH A FAVORABLE CARD FROM THE BOTTOM OF THE DECK.',
            id: 'expert_ability',
            usedThisGame: false
          }
        },
        { id: 'unbeatable', name: 'OMEGA', type: 'Unbeatable', description: 'The final boss. Prepare for your end.', avatar: 'â˜¢ï¸', color: '#FF1493', music: 'assets/music/omega_theme.mp3', unlocksAtLevel: 15, betMultiplier: 2.5, xpMultiplier: 2.5, strategy: 'perfect', hp: 250, isBoss: true,
          roomImage: 'https://placehold.co/1920x1080/33001a/FF1493?text=OMEGA+FORTRESS',
          uniqueAbility: {
            name: 'SYSTEM OVERRIDE',
            description: 'EXTREMELY LOW CHANCE, ONLY IF PLAYER HAS A VERY STRONG HAND AND DEALER HAS A WEAK HAND. FORCES A RE-DEAL OF A SINGLE CARD FOR BOTH PLAYER AND DEALER.',
            id: 'unbeatable_ability',
            usedThisGame: false
          }
        },
        { id: 'glitch', name: 'The Glitch', type: 'Erratic', description: 'Randomly alters game conditions.', avatar: 'ðŸ‘¾', color: '#00FFFF', music: 'assets/music/glitch_theme.mp3', unlocksAtLevel: 7, betMultiplier: 1.6, xpMultiplier: 1.6, strategy: 'erratic', hp: 160,
          roomImage: 'https://placehold.co/1920x1080/003333/00FFFF?text=GLITCH+DIMENSION',
          uniqueAbility: {
            name: 'DATA CORRUPTION',
            description: 'SMALL CHANCE AT THE START OF DEALER\'S TURN. TEMPORARILY SCRAMBLES THE DISPLAYED VALUES OF DEALER\'S CARDS.',
            id: 'glitch_ability',
            usedThisGame: false
          }
        }
      ],
      currentDealer: null,
      currentDealerId: null, 
      campaignProgress: {
        currentLevel: 0,
        unlockedDealers: ['novice'],
        streaks: { quickPlay: 0, campaign: 0 },
        bestStreak: 0,
        totalBlackjacks: 0,
        totalBusts: 0,
        totalSplits: 0,
        dealerWins: {}, // New: Track wins against each specific dealer
        rogueModeUnlocked: false // New: Flag for rogue mode unlock
      },
      REQUIRED_WINS_FOR_ROGUE_MODE: 15, // New: Constant for unlock condition

      // Properties for Rogue Dealers
      isRogueModeActive: false, // Tracks if we are currently in rogue mode session
      rogueDealers: [], // Stores the 7 generated rogue dealers for the current session
      availableRogueAbilities: [], // Pool of unique abilities for rogue dealers

      cardSkins: [
        { id: 'default', name: 'Standard Cyber', color: '#222', price: 0 },
        { id: 'neon-matrix', name: 'Neon Matrix', color: '#00ffff', price: 500 },
        { id: 'lava-burst', name: 'Lava Burst', color: '#ff4500', price: 750 },
        { id: 'royal-purple', name: 'Royal Purple', color: '#8A2BE2', price: 1000 } 
      ],
      powerUpItems: {
        extraCard: { name: 'Extra Card', description: 'Draw an additional card.', price: 200 },
        peekDealer: { name: 'Peek Dealer Card', description: 'Reveal dealer\'s hidden card.', price: 300 },
        shieldLoss: { name: 'Shield of Resilience', description: 'Prevents one HP loss in Brawl.', price: 400 },
        bomb: { name: 'Brawl Bomb', description: 'Deals direct damage in Brawl.', price: 350 },
        freeze: { name: 'Dealer Freeze', description: 'Dealer skips next hit.', price: 500 },
        doubleXP: { name: 'XP Booster', description: 'Double XP for next round.', price: 600 }
      },
      DECK_RELOAD_THRESHOLD: 15, 

      // New: Brawl Mode Specific properties
      activeBrawlRule: null, // Stores the currently active random rule
      brawlRules: [
        {
          id: 'lowVisibility',
          name: 'LOW VISIBILITY',
          message: 'LOW VISIBILITY PROTOCOL ACTIVATED! Cards are hidden!',
          apply: function() {
            // Logic for dealing cards face down, handled in dealInitialCards and createCardElement
          },
          revert: function() {
            // Logic to reveal dealer's second card
            const faceDownCard = game.dealerHand.find(card => card.isFaceDown);
            if (faceDownCard) {
                faceDownCard.isFaceDown = false;
                game.updateHandsDisplay();
            }
          }
        },
        {
          id: 'powerSurge',
          name: 'POWER SURGE',
          message: 'POWER SURGE DETECTED! Power-ups are 50% more effective!',
          apply: function() { /* Effect applied directly in usePowerUp */ },
          revert: function() { /* No direct revert needed, effect is for one round */ }
        },
        {
          id: 'glitchInMatrix',
          name: 'GLITCH IN THE MATRIX',
          message: 'GLITCH IN THE MATRIX! Card values are scrambling!',
          apply: function() { game.applyGlitchEffect(); },
          revert: function() { game.revertGlitchEffect(); }
        },
        // NEW: Environmental Hazards
        {
          id: 'systemOverload',
          name: 'SYSTEM OVERLOAD',
          message: 'SYSTEM OVERLOAD DETECTED! Both combatants take damage!',
          apply: function() { game.applySystemOverload(); },
          revert: function() { /* Damage is permanent, no revert needed */ }
        },
        {
          id: 'empBurst',
          name: 'EMP BURST',
          message: 'EMP BURST! Power-ups temporarily disabled!',
          apply: function() { game.applyEmpBurst(); },
          revert: function() { game.revertEmpBurst(); }
        },
        {
          id: 'limitBarriers',
          name: 'LIMIT BARRIERS',
          message: 'LIMIT BARRIERS ENGAGED! Only one hit allowed per hand!',
          apply: function() { game.applyLimitBarriers(); },
          revert: function() { game.revertLimitBarriers(); }
        }
      ],

      // NEW: State for Limit Barriers hazard
      playerHitsThisRound: 0,
      dealerHitsThisRound: 0,
      isLimitBarrierActive: false,

      // NEW: Cyber Nexus Pass properties
      cyberNexusPass: {
        active: false,
        expiryDate: null, // Timestamp for when the pass expires
        weeklyCosmeticClaimed: false, // Track if this week's cosmetic has been claimed
        lastLoginDate: null, // Track last login for daily bonuses
        consecutiveWeeks: 0, // For loyalty streak
        currentWeeklyCosmetic: null // Stores the ID of the current weekly cosmetic
      },
      // Define pass details, including dollar price and "worth" for psychological framing
      cyberNexusPassDetails: {
          id: 'cyberNexusPass',
          name: 'Cyber Nexus Pass',
          priceUSD: 4.99, // Charm pricing
          worthUSD: 15.00, // Anchoring effect
          description: 'Access the Nexus: Accelerate XP, boost credits, get exclusive weekly cosmetics, and more!',
          xpBonus: 0.25, // +25% XP
          creditBonus: 0.15, // +15% Credits
          shopDiscount: 0.10, // 10% discount on other shop items
          dailyCreditBonus: 50, // Daily bonus credits for pass holders
          powerUpEffectivenessBonus: 0.05 // +5% chance for power-up resonance
      },
      weeklyCosmeticsPool: [
          { id: 'nexus-card-back-01', name: 'Nexus Flux Cardback', type: 'card-back' },
          { id: 'glowing-avatar-frame-01', name: 'Quantum Glow Frame', type: 'avatar-frame' },
          { id: 'win-particle-effect-01', name: 'Victory Glitch Effect', type: 'win-particle' }
          // Add more unique weekly cosmetic items here
      ],


      // UI Elements (cached for performance)
      elements: {},

      init: function() {
        this.cacheElements();
        this.loadGameData();
        this.populateAvailableRogueAbilities(); // Populate the abilities pool once
        this.updateUI();
        this.showScreen('main-menu'); 
        this.setupDealers(); 
        this.setupShop(); 
        this.updatePowerUpButtons();
        this.checkRogueModeUnlockConditions(); // Check on init
        this.checkCyberNexusPassStatus(); // Check pass status on init
        setInterval(() => this.updateCyberNexusPassUI(), 1000); // Update pass UI every second
      },

      cacheElements: function() {
        this.elements = {
          mainMenu: document.getElementById('main-menu'),
          bettingSection: document.getElementById('betting-section'),
          campaignSection: document.getElementById('campaign-section'),
          powerUpsSection: document.getElementById('powerups-section'), 
          pvpLobby: document.getElementById('pvp-lobby'),
          gameArea: document.getElementById('game-area'),
          statsScreen: document.getElementById('stats-screen'),
          shopScreen: document.getElementById('shop-screen'),
          creditsDisplay: document.getElementById('credits'),
          winsDisplay: document.getElementById('wins'),
          gamesDisplay: document.getElementById('games'),
          playerLevelDisplay: document.getElementById('player-level'),
          xpBarFill: document.getElementById('xp-bar-fill'), 
          playerXPSpan: document.getElementById('player-xp'), 
          xpToNextSpan: document.getElementById('xp-to-next'), 
          betAmountInput: document.getElementById('bet-amount'),
          dealerCardsDiv: document.getElementById('dealer-cards'),
          playerCardsDiv: document.getElementById('player-cards'),
          dealerTotalDisplay: document.getElementById('dealer-total'),
          playerTotalDisplay: document.getElementById('player-total'),
          hitBtn: document.getElementById('hit-btn'),
          standBtn: document.getElementById('stand-btn'),
          doubleBtn: document.getElementById('double-btn'),
          messageArea: document.getElementById('message-area'),
          postGameControls: document.getElementById('post-game-controls'),
          riskButton: document.getElementById('risk-button'),
          riskResult: document.getElementById('risk-result'),
          dealersGrid: document.getElementById('dealers-grid'),
          powerUpsGrid: document.getElementById('powerup-packs'),
          shopCredits: document.getElementById('shop-credits'),
          cardSkinsGrid: document.getElementById('card-skins'),
          playerHpBar: document.getElementById('player-hp-bar'),
          dealerHpBar: document.getElementById('dealer-hp-bar'),
          playerHpText: document.getElementById('player-hp'),
          dealerHpText: document.getElementById('dealer-hp'),
          brawlHud: document.getElementById('brawl-hud'),
          specialChargeBarFill: document.getElementById('special-charge-bar-fill'),
          specialChargeText: document.getElementById('special-charge'),
          ultimateChargeBarFill: document.getElementById('ultimate-charge-bar-fill'),
          ultimateChargeText: document.getElementById('ultimate-charge'),
          specialAttackBtn: document.getElementById('special-attack-btn'),
          ultimateBtn: document.getElementById('ultimate-btn'),
          brawlSpecialControls: document.getElementById('brawl-special-controls'),
          statsGames: document.getElementById('stats-games'),
          statsWins: document.getElementById('stats-wins'),
          statsRate: document.getElementById('stats-rate'),
          statsPowerup: document.getElementById('stats-powerup'),
          statsBlackjacks: document.getElementById('stats-blackjacks'),
          statsBusts: document.getElementById('stats-busts'),
          leaderboard: document.getElementById('leaderboard'),
          pvpStatus: document.getElementById('pvp-status'),
          dealerRoomBg: document.getElementById('dealer-room-bg'),
          dealerMusic: document.getElementById('dealer-music'),
          currentDealerInfo: document.getElementById('current-dealer-info'),
          currentDealerAvatar: null, 
          currentDealerName: null,   
          powerupControls: document.getElementById('powerup-controls'),
          gameControls: document.getElementById('game-controls'), 
          gameDeck: document.getElementById('game-deck'), 
          weeklyPassGrid: document.getElementById('weekly-pass-grid'), // NEW
          weeklyPassIndicator: document.getElementById('weekly-pass-indicator'), // NEW
          passTimeRemaining: document.getElementById('pass-time-remaining'), // NEW
          // New audio elements
          sfxHit: document.getElementById('sfx-hit'),
          sfxStand: document.getElementById('sfx-stand'),
          sfxDoubledown: document.getElementById('sfx-doubledown'),
          sfxWin: document.getElementById('sfx-win'),
          sfxLose: document.getElementById('sfx-lose'),
          sfxTie: document.getElementById('sfx-tie'),
          sfxPowerupExtraCard: document.getElementById('sfx-powerup-extraCard'),
          sfxPowerupPeekDealer: document.getElementById('sfx-powerup-peekDealer'),
          sfxPowerupShieldLoss: document.getElementById('sfx-powerup-shieldLoss'),
          sfxPowerupBomb: document.getElementById('sfx-powerup-bomb'),
          sfxPowerupFreeze: document.getElementById('sfx-powerup-freeze'),
          sfxPowerupDoubleXP: document.getElementById('sfx-powerup-doubleXP'),
          sfxSpecialAttack: document.getElementById('sfx-specialAttack'),
          sfxUltimate: document.getElementById('sfx-ultimate'),
          sfxLevelUp: document.getElementById('sfx-levelUp'),
          sfxPurchase: document.getElementById('sfx-purchase')
        };
      },

      /**
       * Plays a sound effect by its ID.
       * @param {string} soundId - The ID of the audio element to play (e.g., 'sfx-hit').
       */
      playSFX: function(soundId) {
        const audio = this.elements[soundId];
        if (audio) {
          audio.currentTime = 0; // Rewind to start
          audio.play().catch(e => {
            console.warn(`Failed to play sound '${soundId}':`, e);
          });
        } else {
          console.warn(`Sound element with ID '${soundId}' not found.`);
        }
      },

      loadGameData: function() {
        const savedData = JSON.parse(localStorage.getItem('cyberBlackjackGameData'));
        if (savedData) {
          this.playerCredits = savedData.playerCredits;
          this.wins = savedData.wins;
          this.games = savedData.games;
          this.playerLevel = savedData.playerLevel || 1;
          this.playerXP = savedData.playerXP || 0;
          this.xpToNextLevel = savedData.xpToNextLevel || 100;
          this.powerUps = savedData.powerUps || { extraCard: 0, peekDealer: 0, shieldLoss: 0, bomb: 0, freeze: 0, doubleXP: 0 };
          this.purchasedSkins = savedData.purchasedSkins || ['default'];
          this.activeCardSkin = savedData.activeCardSkin || 'default';
          this.campaignProgress = savedData.campaignProgress || {
            currentLevel: 0,
            unlockedDealers: ['novice'],
            streaks: { quickPlay: 0, campaign: 0 },
            bestStreak: 0,
            totalBlackjacks: 0,
            totalBusts: 0,
            totalSplits: 0,
            dealerWins: {}, // Initialize if not present
            rogueModeUnlocked: false // Initialize if not present
          };
          // Initialize dealerWins for all dealers if not already done
          this.dealers.forEach(dealer => {
            if (!this.campaignProgress.dealerWins[dealer.id]) {
              this.campaignProgress.dealerWins[dealer.id] = 0;
            }
          });
          
          // Load Cyber Nexus Pass data (NEW)
          if (savedData.cyberNexusPass) {
              this.cyberNexusPass = savedData.cyberNexusPass;
              // Convert expiryDate back to Date object if it was stored as string
              if (typeof this.cyberNexusPass.expiryDate === 'string') {
                  this.cyberNexusPass.expiryDate = new Date(this.cyberNexusPass.expiryDate);
              }
              if (typeof this.cyberNexusPass.lastLoginDate === 'string') {
                  this.cyberNexusPass.lastLoginDate = new Date(this.cyberNexusPass.lastLoginDate);
              }
          }

          // NEW: LOAD ABILITY USAGE FROM SAVED DATA IF AVAILABLE
          if (savedData.dealerAbilities) { 
              this.dealers.forEach(dealer => { 
                  if (dealer.uniqueAbility && savedData.dealerAbilities[dealer.id]) { 
                      dealer.uniqueAbility.usedThisGame = savedData.dealerAbilities[dealer.id].usedThisGame; 
                  }
              });
          }
        } else {
            // If no saved data, ensure dealerWins is initialized for all base dealers
            this.dealers.forEach(dealer => {
                this.campaignProgress.dealerWins[dealer.id] = 0;
            });
        }
      },

      saveGameData: function() {
        // NEW: PREPARE ABILITY USAGE DATA TO SAVE
        const abilityUsageData = {}; 
        this.dealers.forEach(dealer => { 
            if (dealer.uniqueAbility) { 
                abilityUsageData[dealer.id] = {
                    usedThisGame: dealer.uniqueAbility.usedThisGame 
                };
            }
        });
        const gameData = { 
          playerCredits: this.playerCredits,
          wins: this.wins,
          games: this.games,
          playerLevel: this.playerLevel,
          playerXP: this.playerXP,
          xpToNextLevel: this.xpToNextLevel,
          powerUps: this.powerUps,
          purchasedSkins: this.purchasedSkins,
          activeCardSkin: this.activeCardSkin,
          campaignProgress: this.campaignProgress,
          dealerAbilities: abilityUsageData,
          cyberNexusPass: { // Save Cyber Nexus Pass data (NEW)
              active: this.cyberNexusPass.active,
              expiryDate: this.cyberNexusPass.expiryDate ? this.cyberNexusPass.expiryDate.toISOString() : null,
              weeklyCosmeticClaimed: this.cyberNexusPass.weeklyCosmeticClaimed,
              lastLoginDate: this.cyberNexusPass.lastLoginDate ? this.cyberNexusPass.lastLoginDate.toISOString() : null,
              consecutiveWeeks: this.cyberNexusPass.consecutiveWeeks,
              currentWeeklyCosmetic: this.cyberNexusPass.currentWeeklyCosmetic
          }
        };
        localStorage.setItem('cyberBlackjackGameData', JSON.stringify(gameData));
      },

      updateUI: function() {
        this.elements.creditsDisplay.textContent = this.playerCredits;
        this.elements.winsDisplay.textContent = this.wins;
        this.elements.gamesDisplay.textContent = this.games;
        this.elements.playerLevelDisplay.textContent = this.playerLevel;
        this.elements.xpBarFill.style.width = (this.playerXP / this.xpToNextLevel) * 100 + '%';
        
        if (this.elements.playerXPSpan) {
            this.elements.playerXPSpan.textContent = this.playerXP;
        } else {
            console.error("player-xp span not found!");
        }
        if (this.elements.xpToNextSpan) {
            this.elements.xpToNextSpan.textContent = this.xpToNextLevel;
        } else {
            console.error("xp-to-next span not found!");
        }

        this.updatePowerUpButtons();
        this.updateCardSkin();
        this.updateStatsScreen();
        this.updateLeaderboard();
        this.updateCyberNexusPassUI(); // Update pass UI
      },

      updateCardSkin: function() {
        document.documentElement.style.setProperty('--card-back-color', this.cardSkins.find(skin => skin.id === this.activeCardSkin).color);
      },

      levelUp: function() {
        this.playerLevel++;
        this.playerXP = 0;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5); 
        this.playerCredits += 500; 
        this.showGameMessage(`LEVEL UP! You are now Level ${this.playerLevel}! +500 Credits!`, 'win');
        this.playSFX('sfx-levelUp'); // Play level up sound
        this.saveGameData();
        this.updateUI();
        this.setupDealers(); 
        this.checkRogueModeUnlockConditions(); // Check unlock conditions on level up
      },

      addXP: function(amount) {
        let xpGained = amount;
        if (this.powerUps.doubleXP > 0) {
            xpGained *= 2;
            this.powerUps.doubleXP--; 
            this.updatePowerUpButtons();
            this.showGameMessage('2x XP Booster activated!', 'win');
        }
        // Apply Cyber Nexus Pass XP bonus (NEW)
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            xpGained *= (1 + this.cyberNexusPassDetails.xpBonus);
            this.showGameMessage(`Cyber Nexus Pass XP Bonus: +${(this.cyberNexusPassDetails.xpBonus * 100).toFixed(0)}% XP!`, 'win');
        }

        this.playerXP += xpGained;
        if (this.playerXP >= this.xpToNextLevel) {
          this.levelUp();
        }
        this.updateUI();
      },

      showGameMessage: function(message, type = '') {
        this.elements.messageArea.textContent = message;
        this.elements.messageArea.className = `message ${type}`; 
        this.elements.messageArea.classList.remove('hidden');
      },

      hideGameMessage: function() {
        this.elements.messageArea.classList.add('hidden');
      },

      showScreen: function(screenId) {
        console.log(`Attempting to show screen: ${screenId}`);
        document.querySelectorAll('.screen').forEach(screen => {
          screen.classList.add('hidden');
        });
        const targetScreen = document.getElementById(screenId);
        if (targetScreen) {
          targetScreen.classList.remove('hidden');
          // Determine display style based on screenId or its CSS class
          if (['main-menu', 'campaign-section', 'powerups-section', 'shop-screen', 'stats-screen', 'pvp-lobby'].includes(screenId)) {
              targetScreen.style.display = 'flex';
          } else if (screenId === 'game-area') {
              targetScreen.style.display = 'block';
          } else {
              targetScreen.style.display = ''; // Default or fall back
          }
          console.log(`Screen '${screenId}' display style set to: ${targetScreen.style.display}`);
        } else {
          console.error(`Error: Screen with ID '${screenId}' not found!`);
        }
        if (screenId === 'betting-section' && this.currentDealer) {
            this.updateCurrentDealerInfo();
            document.getElementById('current-dealer-info').classList.remove('hidden');
        } else {
            document.getElementById('current-dealer-info').classList.add('hidden');
        }

        if (screenId !== 'game-area' || !this.isBrawl) {
            this.elements.brawlHud.classList.add('hidden');
            this.elements.brawlSpecialControls.classList.add('hidden');
        }

        if (screenId !== 'game-area') {
            this.elements.postGameControls.classList.add('hidden');
            this.elements.riskResult.classList.add('hidden');
        }
      },

      // Navigation functions
      showQuickPlay: function() {
        this.isBrawl = false;
        this.currentDealer = null; 
        this.currentDealerId = null; 
        this.isRogueModeActive = false; // Ensure rogue mode is off
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.resetDeck(); 
        this.showScreen('betting-section');
        // Reset background to default for quick play
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB')`;
      },

      showCampaign: function() {
        console.log("Entering showCampaign function.");
        this.isBrawl = false;
        this.isRogueModeActive = false; // Ensure rogue mode is off for regular campaign
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.setupDealers(); // Render regular dealers and rogue mode button
        this.showScreen('campaign-section');
        // Reset background to default for campaign selection
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CAMPAIGN+SELECT')`;
      },

      selectCampaignDealer: function(dealerId) {
        // If in rogue mode, select from rogueDealers, else from regular dealers
        let dealerList = this.isRogueModeActive ? this.rogueDealers : this.dealers;
        this.currentDealer = dealerList.find(d => d.id === dealerId);
        this.currentDealerId = dealerId; 

        if (this.currentDealer.unlocksAtLevel > this.playerLevel && !this.isRogueModeActive) { // Regular campaign unlock check
            this.showGameMessage(`You need to be Level ${this.currentDealer.unlocksAtLevel} to challenge ${this.currentDealer.name}!`, 'lose');
            return;
        }

        this.isBrawl = false; 
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.resetDeck(); 
        this.showScreen('betting-section');
        this.updateCurrentDealerInfo();
        // Play dealer music
        if (this.elements.dealerMusic) {
            // Check if music exists before setting src
            if (this.currentDealer.music) {
                this.elements.dealerMusic.src = this.currentDealer.music; 
                try {
                    this.elements.dealerMusic.play().catch(e => {
                        console.error("Failed to play dealer music:", e);
                    });
                } catch (e) {
                    console.error("Error attempting to play dealer music:", e);
                }
            } else {
                console.warn(`No music defined for dealer ${this.currentDealer.name}.`);
                this.elements.dealerMusic.pause();
                this.elements.dealerMusic.currentTime = 0;
            }
        } else {
            console.warn("Dealer music element not found.");
        }
        
        // Update dealer room background
        if (this.currentDealer.roomImage) {
            this.elements.dealerRoomBg.style.backgroundImage = `url('${this.currentDealer.roomImage}')`;
        } else {
            console.warn(`No room image defined for dealer ${this.currentDealer.name}. Using default background.`);
            this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB')`;
        }
      },

      updateCurrentDealerInfo: function() {
        if (!this.currentDealer) {
            this.elements.currentDealerInfo.classList.add('hidden');
            return;
        }
        if (!this.elements.currentDealerAvatar) { 
            this.elements.currentDealerAvatar = document.createElement('div');
            this.elements.currentDealerAvatar.classList.add('current-dealer-avatar');
            this.elements.currentDealerName = document.createElement('span');
            this.elements.currentDealerInfo.appendChild(this.elements.currentDealerAvatar);
            this.elements.currentDealerInfo.appendChild(this.elements.currentDealerName);
        }
        this.elements.currentDealerAvatar.textContent = this.currentDealer.avatar;
        this.elements.currentDealerAvatar.style.borderColor = this.currentDealer.color;
        this.elements.currentDealerName.textContent = this.currentDealer.name;
        this.elements.currentDealerInfo.classList.remove('hidden');
      },

      startBrawlMode: function() {
        this.isBrawl = true;
        this.isRogueModeActive = false; // Ensure rogue mode is off
        this.playerHP = 100;
        this.dealerHP = 100;
        this.specialCharge = 0;
        this.ultimateCharge = 0;
        this.currentDealer = this.dealers.find(d => d.id === 'aggressive'); 
        this.currentDealerId = this.currentDealer.id; 
        this.updateBrawlHUD();
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 
        this.resetDeck(); 
        this.showScreen('betting-section');
        // Set specific background for Brawl Mode
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/330000/ff0000?text=BRAWL+ARENA')`;
      },

      updateBrawlHUD: function() {
        this.elements.brawlHud.classList.remove('hidden');
        this.elements.brawlSpecialControls.classList.remove('hidden');
        this.elements.playerHpBar.style.width = this.playerHP + '%';
        this.elements.dealerHpBar.style.width = this.dealerHP + '%';
        this.elements.playerHpText.textContent = this.playerHP;
        this.elements.dealerHpText.textContent = this.dealerHP;
        this.elements.specialChargeBarFill.style.width = this.specialCharge + '%';
        this.elements.specialChargeText.textContent = `${this.specialCharge}% Special`;
        this.elements.ultimateChargeBarFill.style.width = this.ultimateCharge + '%';
        this.elements.ultimateChargeText.textContent = `${this.ultimateCharge}% Ultimate`;

        this.elements.specialAttackBtn.disabled = this.specialCharge < 100;
        this.elements.ultimateBtn.disabled = this.ultimateCharge < 100;
      },

      openShopScreen: function() {
        this.elements.shopCredits.textContent = this.playerCredits;
        this.setupShop(); 
        this.showScreen('shop-screen');
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/000000/ff69b4?text=CYBER+SHOP')`;
      },

      openStatsScreen: function() {
        this.updateStatsScreen();
        this.updateLeaderboard();
        this.showScreen('stats-screen');
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffdd?text=PLAYER+STATS')`;
      },

      startPvP: function() {
        this.showScreen('pvp-lobby');
        this.elements.pvpStatus.textContent = 'Searching for opponent...';
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/1a1a2e/8A2BE2?text=PVP+NETWORK')`;
        setTimeout(() => {
            this.elements.pvpStatus.textContent = 'Opponent found! Starting game...';
            setTimeout(() => {
                this.showGameMessage('PvP not yet fully implemented. Returning to menu.', 'lose');
                this.backToMenu();
            }, 2000);
        }, 3000);
      },

      cancelPvP: function() {
        this.showGameMessage('PvP search cancelled.', '');
        this.backToMenu();
      },

      backToMenu: function() {
        this.showScreen('main-menu');
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden');
        this.isGameActive = false;
        this.isRogueModeActive = false; // Reset rogue mode on going back to main menu
        if (this.elements.dealerMusic) {
          this.elements.dealerMusic.pause();
          this.elements.dealerMusic.currentTime = 0;
        }
        // Reset active brawl rule when leaving brawl mode
        if (this.activeBrawlRule && this.activeBrawlRule.revert) { // Revert any active rule
            this.activeBrawlRule.revert();
        }
        this.activeBrawlRule = null;
        // Reset background to default when returning to main menu
        this.elements.dealerRoomBg.style.backgroundImage = `url('https://placehold.co/1920x1080/0a0a0a/00ffff?text=CYBER+BLACKJACK+HUB')`;
      },

      resetAllDataConfirmation: function() {
        this.showGameMessage('Are you sure? Click "Reset Game Data" again to confirm!', 'lose');
        this.elements.mainMenu.querySelector('button[onclick="game.resetAllDataConfirmation()"]').onclick = () => {
          localStorage.removeItem('cyberBlackjackGameData');
          location.reload(); 
        };
        setTimeout(() => {
          this.elements.mainMenu.querySelector('button[onclick="game.resetAllDataConfirmation()"]').onclick = game.resetAllDataConfirmation;
          this.hideGameMessage(); 
        }, 5000); 
      },

      adjustBet: function(amount) {
        let currentBet = parseInt(this.elements.betAmountInput.value) || 0;
        let newBet = currentBet + amount;

        newBet = Math.max(10, newBet); 
        newBet = Math.min(this.playerCredits, newBet); 

        this.elements.betAmountInput.value = newBet;
      },

      betMax: function() {
        this.elements.betAmountInput.value = this.playerCredits;
      },

      resetDeck: function() {
        this.deck = this.createDeck();
        this.shuffleDeck();
        this.showGameMessage('New deck shuffled!', 'tie');
      },

      startGame: function() {
        console.log("startGame called.");
        this.currentBet = parseInt(this.elements.betAmountInput.value);
        console.log("Current Bet:", this.currentBet);
        console.log("Player Credits:", this.playerCredits);

        if (isNaN(this.currentBet) || this.currentBet <= 0) {
          this.showGameMessage('Please place a valid bet.', 'lose');
          console.log("Validation Failed: Invalid bet amount.");
          return;
        }
        if (this.playerCredits < this.currentBet) {
          this.showGameMessage('Not enough credits!', 'lose');
          console.log("Validation Failed: Insufficient credits.");
          return;
        }
        
        if (!this.deck || this.deck.length < this.DECK_RELOAD_THRESHOLD) {
          this.resetDeck(); 
        }

        this.playerCredits -= this.currentBet;
        this.playerHand = [];
        this.dealerHand = [];
        
        this.isGameActive = true;
        this.hideGameMessage();
        this.elements.riskResult.classList.add('hidden'); 

        // Reset hit counters for Limit Barriers hazard
        this.playerHitsThisRound = 0;
        this.dealerHitsThisRound = 0;
        this.isLimitBarrierActive = false; // Reset the flag

        // Revert any previously active brawl rule effects
        if (this.activeBrawlRule && this.activeBrawlRule.revert) {
            this.activeBrawlRule.revert();
        }
        this.activeBrawlRule = null; // Clear previous rule


        // NEW: Random Round Rules for Brawl Mode (25% chance to activate a random rule)
        if (this.isBrawl && Math.random() < 0.25) { 
          this.activeBrawlRule = this.brawlRules[Math.floor(Math.random() * this.brawlRules.length)];
          this.showGameMessage(this.activeBrawlRule.message, 'tie');
          if (this.activeBrawlRule.apply) {
            this.activeBrawlRule.apply();
          }
        } 

        if (this.isBrawl) {
            this.updateBrawlHUD(); 
        }

        // Reset unique ability usage for the current dealer at the start of a new game
        if (this.currentDealer && this.currentDealer.uniqueAbility) { 
            this.currentDealer.uniqueAbility.usedThisGame = false; 
            // AGGRESSIVE BET ABILITY ACTIVATION AT START OF GAME (NEON NIGHTHAWK)
            if (this.currentDealer.uniqueAbility.id === 'aggressive_ability' && Math.random() < 0.2 && !this.currentDealer.uniqueAbility.usedThisGame) { 
                if (this.playerCredits >= this.currentBet) { 
                    this.playerCredits -= this.currentBet; 
                    this.currentBet *= 2;
                    this.showGameMessage('NEON NIGHTHAWK FORCES AN AGGRESSIVE BET! YOUR BET DOUBLED!', 'lose');
                    this.currentDealer.uniqueAbility.usedThisGame = true; 
                    this.saveGameData();
                    this.updateUI(); 
                } else {
                    this.showGameMessage('NEON NIGHTHAWK ATTEMPTED AGGRESSIVE BET, BUT YOU LACKED CREDITS!', 'tie');
                }
            }
        }

        this.dealInitialCards();
        this.updateHandsDisplay();
        this.updateUI();
        this.showScreen('game-area');
        console.log("Showing game-area.");
        this.elements.postGameControls.classList.add('hidden'); 
        this.elements.gameControls.classList.remove('hidden'); 
        this.elements.powerupControls.classList.remove('hidden'); 
        this.elements.betAmountInput.disabled = true; 

        if (this.isBrawl) {
            const playerTotal = this.getHandValue(this.playerHand);
            if (playerTotal === 21 && this.playerHand.length === 2) {
                this.playerHP = Math.min(100, this.playerHP + 50); 
                this.addCharge(0, 50); 
                this.showGameMessage('BLACKJACK! You gained 50 HP and 50 Ultimate Charge!', 'win');
                this.updateBrawlHUD(); 
            }
        }
      },

      createDeck: function() {
        const suits = ['â¤ï¸', 'â™¦ï¸', 'â™£ï¸', 'â™ ï¸'];
        const ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
        const deck = [];
        for (const suit of suits) {
          for (const rank of ranks) {
            let value;
            if (rank === 'A') value = 11;
            else if (['K', 'Q', 'J'].includes(rank)) value = 10;
            else value = parseInt(rank);
            deck.push({ rank, suit, value: value, originalValue: value }); // Store original value for glitch
          }
        }
        return deck;
      },

      shuffleDeck: function() {
        triggerScreenShake(); 
        if (this.elements.gameDeck) { 
            this.elements.gameDeck.classList.add('shuffle-animation');
            setTimeout(() => {
                this.elements.gameDeck.classList.remove('shuffle-animation');
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }, 500); 
        } else {
            console.error("Error: gameDeck element not found for shuffle animation.");
            for (let i = this.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
            }
        }
      },

      dealCard: function() {
        if (this.deck.length === 0) {
            console.error("Attempted to deal a card from an empty deck. This should not happen.");
            this.resetDeck();
            this.showGameMessage('Deck ran out! Automatically reshuffling.', 'lose');
        }
        return this.deck.pop();
      },

      dealInitialCards: function() {
        this.playerHand.push(this.dealCard());
        // For Low Visibility rule, the first card is always face up for player
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
            this.playerHand.push({ ...this.dealCard(), isFaceDown: true });
            this.dealerHand.push({ ...this.dealCard(), isFaceDown: true });
            this.dealerHand.push({ ...this.dealCard(), isFaceDown: true });
        } else {
            this.playerHand.push(this.dealCard());
            this.dealerHand.push(this.dealCard());
            this.dealerHand.push({ ...this.dealCard(), isFaceDown: true });
        }
      },

      getHandValue: function(hand) {
        let value = 0;
        let numAces = 0;

        for (const card of hand) {
          // If Glitch in the Matrix is active and card has glitchedValue, use it for calculations
          if (card.isFaceDown) continue; 
          // Fix: Added missing parenthesis at the end of the line
          const cardValue = (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.glitchedValue !== undefined) ? card.glitchedValue : 
                            (card.value !== undefined ? card.value : 
                            (card.rank === 'A' ? 11 :
                             (['K', 'Q', 'J'].includes(card.rank) ? 10 : parseInt(card.rank)))); // Corrected line
          value += cardValue;
          if (card.rank === 'A') { 
            numAces++;
          }
        }

        while (value > 21 && numAces > 0) {
          value -= 10;
          numAces--;
        }
        return value;
      },

      updateHandsDisplay: function() {
        this.elements.playerCardsDiv.innerHTML = '';
        this.elements.dealerCardsDiv.innerHTML = '';

        this.playerHand.forEach((card, index) => {
          this.elements.playerCardsDiv.appendChild(this.createCardElement(card, index, 'player'));
        });

        this.dealerHand.forEach((card, index) => {
          this.elements.dealerCardsDiv.appendChild(this.createCardElement(card, index, 'dealer'));
        });

        this.elements.playerTotalDisplay.textContent = `Total: ${this.getHandValue(this.playerHand)}`;
        // For Low Visibility, dealer total is hidden until reveal
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility' && this.isGameActive) {
            this.elements.dealerTotalDisplay.textContent = `Total: ??`;
        } else {
            const dealerFaceUpValue = this.dealerHand.filter(card => !card.isFaceDown);
            this.elements.dealerTotalDisplay.textContent = `Total: ${this.getHandValue(dealerFaceUpValue)}`;
        }

        // Disable double down if Limit Barriers is active or if already hit
        this.elements.doubleBtn.disabled = (this.playerHand.length > 2 || this.playerCredits < this.currentBet || (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1));
        // Disable hit if Limit Barriers is active and already hit
        this.elements.hitBtn.disabled = (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1);
      },

      createCardElement: function(card, index, handType) {
        const cardElement = document.createElement('div');
        cardElement.classList.add('card');
        
        let displayRank = card.rank;
        let displayValue = card.value;

        // Apply Glitch in the Matrix visual if active and card has glitchedValue
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'glitchInMatrix' && card.glitchedValue !== undefined) {
            displayRank = '??';
            displayValue = '??';
        }

        // Low Visibility rule: only first player card is face up at start
        let isActuallyFaceDown = card.isFaceDown;
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility' && this.isGameActive) {
            if (handType === 'player' && index === 0) {
                isActuallyFaceDown = false; // First player card is always visible
            } else {
                isActuallyFaceDown = true; // All other cards are face down initially
            }
        }


        if (isActuallyFaceDown) {
            cardElement.classList.add('flipped');
            cardElement.innerHTML = `
                <div class="card-inner">
                    <div class="card-front"></div>
                    <div class="card-back">Cyber<br>Blackjack</div>
                </div>
            `;
        } else {
            const suitClass = (card.suit === 'â¤ï¸' || card.suit === 'â™¦ï¸') ? 'red' : 'black';
            cardElement.innerHTML = `
                <div class="card-inner">
                    <div class="card-front ${suitClass}">
                        <span>${displayRank}</span>
                        <span>${card.suit}</span>
                        <span>${displayRank}</span>
                        <span class="card-value" style="display: none;">${displayValue}</span> 
                    </div>
                    <div class="card-back">Cyber<br>Blackjack</div>
                </div>
            `;
        }
        return cardElement;
      },

      hit: function() {
        if (!this.isGameActive) return;

        // NEW: Limit Barriers check
        if (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1) {
            this.showGameMessage('Limit Barriers active! Only one hit allowed per hand!', 'lose');
            return;
        }

        this.playSFX('sfx-hit'); // Play hit sound effect

        this.playerHand.push(this.dealCard());
        this.updateHandsDisplay();

        if (this.isBrawl) {
            this.addCharge(10);
            if (this.isLimitBarrierActive) {
                this.playerHitsThisRound++; // Increment hit counter only if limit barriers are active
            }
        }

        const playerTotal = this.getHandValue(this.playerHand);
        if (playerTotal > 21) {
          this.endGame('bust');
        } else if (playerTotal === 21) {
          if (this.isBrawl) {
            this.addCharge(0, 25); 
            this.playerHP = Math.min(100, this.playerHP + 30); 
            this.showGameMessage('Hit 21! +30 HP and +25 Ultimate Charge!', 'win');
            this.updateBrawlHUD(); 
          }
          this.stand(); 
        }
      },

      stand: function() {
        if (!this.isGameActive) return;
        this.playSFX('sfx-stand'); // Play stand sound effect

        this.isGameActive = false;
        this.elements.gameControls.classList.add('hidden'); 
        this.elements.powerupControls.classList.add('hidden'); 
        this.elements.betAmountInput.disabled = false; 

        // Reveal all dealer cards if Low Visibility was active
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'lowVisibility') {
            this.dealerHand.forEach(card => card.isFaceDown = false);
            this.updateHandsDisplay();
            // Trigger flip animation for previously hidden cards
            this.elements.dealerCardsDiv.querySelectorAll('.card.flipped').forEach(cardElement => {
                cardElement.classList.remove('flipped');
            });
            setTimeout(() => this.dealerTurn(), 1000); 
        } else {
            const faceDownCardIndex = this.dealerHand.findIndex(card => card.isFaceDown);
            if (faceDownCardIndex !== -1) {
                this.dealerHand[faceDownCardIndex].isFaceDown = false;
                this.updateHandsDisplay();
                const cardElement = this.elements.dealerCardsDiv.children[faceDownCardIndex];
                if (cardElement) {
                    cardElement.classList.remove('flipped');
                }
            }
            setTimeout(() => this.dealerTurn(), 1000); 
        }
      },

      doubleDown: function() {
        if (!this.isGameActive || this.playerHand.length !== 2 || this.playerCredits < this.currentBet) return;
        
        // NEW: Limit Barriers check for Double Down
        if (this.isBrawl && this.isLimitBarrierActive && this.playerHitsThisRound >= 1) {
            this.showGameMessage('Limit Barriers active! Only one hit allowed per hand!', 'lose');
            return;
        }

        this.playSFX('sfx-doubledown'); // Play double down sound effect

        this.playerCredits -= this.currentBet; 
        this.currentBet *= 2;
        this.playerHand.push(this.dealCard()); 
        this.updateHandsDisplay();
        this.updateUI();

        if (this.isBrawl) {
            this.addCharge(15); 
            if (this.isLimitBarrierActive) {
                this.playerHitsThisRound++; // Double Down counts as a hit for Limit Barriers
            }
        }

        const playerTotal = this.getHandValue(this.playerHand);
        if (playerTotal > 21) {
          this.endGame('bust');
        } else {
          if (this.isBrawl && playerTotal === 21) {
            this.addCharge(0, 25); 
            this.playerHP = Math.min(100, this.playerHP + 30); 
            this.showGameMessage('Double Down 21! +30 HP and +25 Ultimate Charge!', 'win');
            this.updateBrawlHUD(); 
          }
          this.stand(); 
        }
      },

      dealerTurn: function() {
        let dealerTotal = this.getHandValue(this.dealerHand);
        const playerTotal = this.getHandValue(this.playerHand);
        let currentDealerData = this.currentDealer; // Use this.currentDealer directly as it's set in selectCampaignDealer

        // Chance to activate dealer unique ability (IF NOT USED THIS GAME AND NOT IN BRAWL)
        if (currentDealerData && currentDealerData.uniqueAbility && !currentDealerData.uniqueAbility.usedThisGame && !this.isBrawl) { 
            const abilityId = currentDealerData.uniqueAbility.id; 
            switch (abilityId) {
                case 'novice_ability': // CYPHER-BOT 7: RESERVE CARD
                    if (dealerTotal > 21 && Math.random() < 0.7 && this.dealerHand.length > 2) { 
                        this.showGameMessage('CYPHER-BOT 7 USES RESERVE CARD!', 'tie');
                        this.dealerHand.pop(); 
                        const newCard = this.dealCard(); 
                        if (Math.random() < 0.3) { 
                            newCard.rank = 'A';
                            newCard.value = 11; 
                        }
                        this.dealerHand.push(newCard);
                        this.updateHandsDisplay();
                        currentDealerData.uniqueAbility.usedThisGame = true; 
                        this.saveGameData();
                        setTimeout(() => this.dealerTurn(), 1000);
                        return;
                    }
                    break;
                case 'conservative_ability': // DATA-SAMURAI: FOCUSED DRAW
                    if (Math.random() < 0.3 && dealerTotal >= 12 && dealerTotal <= 16 && this.deck.length > 0) { 
                        const nextCard = this.deck[this.deck.length - 1]; 
                        const potentialTotal = this.getHandValue([...this.dealerHand, nextCard]);
                        if (potentialTotal >= 17 && potentialTotal <= 21) {
                            this.showGameMessage('DATA-SAMURAI USES FOCUSED DRAW!', 'tie');
                            this.dealerHand.push(this.dealCard()); 
                            this.updateHandsDisplay();
                            currentDealerData.uniqueAbility.usedThisGame = true; 
                            this.saveGameData();
                            setTimeout(() => this.dealerTurn(), 1000);
                            return;
                        }
                    }
                    break;
                case 'calculating_ability': // THE QUANTUM QUASAR: CARD PREDICTION
                    if (Math.random() < 0.2 && dealerTotal >= 14 && dealerTotal <= 16 && this.deck.length > 2) { 
                        const potentialCard1 = this.deck[this.deck.length - 1]; 
                        const potentialCard2 = this.deck[this.deck.length - 2]; 
                        const potentialCard3 = this.deck[this.deck.length - 3]; 
                        
                        let bestCard = null; 
                        for (const cardOption of [potentialCard1, potentialCard2, potentialCard3]) { 
                            if (cardOption && this.getHandValue([...this.dealerHand, cardOption]) <= 21 && this.getHandValue([...this.dealerHand, cardOption]) >= 17) {
                                bestCard = cardOption;
                                break;
                            }
                        }

                        if (bestCard) {
                            this.deck = this.deck.filter(card => card !== bestCard);
                            this.deck.push(bestCard);
                            this.showGameMessage('THE QUANTUM QUASAR PREDICTS THE FUTURE!', 'tie');
                            this.dealerHand.push(this.dealCard()); 
                            this.updateHandsDisplay();
                            currentDealerData.uniqueAbility.usedThisGame = true; 
                            this.saveGameData();
                            setTimeout(() => this.dealerTurn(), 1000);
                            return;
                        } else {
                            this.showGameMessage('THE QUANTUM QUASAR RESHUFFLES! (NO PREDICTION)', 'tie');
                            const tempCards = this.deck.splice(this.deck.length - 3, 3); 
                            tempCards.sort(() => Math.random() - 0.5); 
                            this.deck = this.deck.concat(tempCards); 
                        }
                    }
                    break;
                case 'master_ability': // ZENITH: ADAPTIVE STRATEGY
                    if (Math.random() < 0.4 && playerTotal > dealerTotal && dealerTotal < 17) { 
                        this.showGameMessage('ZENITH ADAPTS THEIR STRATEGY!', 'lose');
                        currentDealerData.strategy = 'aggressive'; 
                        currentDealerData.uniqueAbility.usedThisGame = true; 
                        this.saveGameData();
                    }
                    break;
                case 'expert_ability': // SHADOW WEAVER: HIDDEN CARD SWAP
                    if (Math.random() < 0.08 && this.dealerHand.length >= 2 && this.deck.length > 0) { 
                        const faceDownCardIndex = this.dealerHand.findIndex(card => card.isFaceDown); 
                        if (faceDownCardIndex !== -1) {
                            const oldFaceDownCard = this.dealerHand[faceDownCardIndex]; 
                            const newCardFromDeck = this.dealCard(); 
                            this.dealerHand[faceDownCardIndex] = newCardFromDeck;
                            this.deck.unshift(oldFaceDownCard); 
                            
                            this.showGameMessage('SHADOW WEAVER PERFORMS A HIDDEN CARD SWAP!', 'lose');
                            this.updateHandsDisplay(); 
                            currentDealerData.uniqueAbility.usedThisGame = true; 
                            this.saveGameData();
                        }
                    }
                    break;
                case 'unbeatable_ability': // OMEGA: SYSTEM OVERRIDE
                    if (Math.random() < 0.05 && playerTotal >= 20 && dealerTotal < 17 && this.deck.length >= 2) { 
                        this.showGameMessage('OMEGA INITIATES SYSTEM OVERRIDE!', 'lose');
                        triggerScreenShake(); 
                        
                        const playerCardToRemoveIndex = this.playerHand.length > 1 ? Math.floor(Math.random() * this.playerHand.length) : 0; 
                        this.playerHand.splice(playerCardToRemoveIndex, 1);
                        this.playerHand.push(this.dealCard()); 
                        
                        const dealerFaceDownIndex = this.dealerHand.findIndex(card => card.isFaceDown); 
                        if (dealerFaceDownIndex !== -1) {
                            this.dealerHand[dealerFaceDownIndex] = this.dealCard(); 
                        } else {
                            const dealerCardToRemoveIndex = this.dealerHand.length > 1 ? Math.floor(Math.random() * this.dealerHand.length) : 0; 
                            this.dealerHand.splice(dealerCardToRemoveIndex, 1);
                            this.dealerHand.push(this.dealCard()); 
                        }
                        
                        this.updateHandsDisplay();
                        currentDealerData.uniqueAbility.usedThisGame = true; 
                        this.saveGameData();
                        setTimeout(() => this.dealerTurn(), 1000);
                        return;
                    }
                    break;
                case 'glitch_ability': // THE GLITCH: DATA CORRUPTION
                    if (Math.random() < 0.2 && !this.currentDealer.uniqueAbility.usedThisGame) { 
                        this.showGameMessage('THE GLITCH CORRUPTS DATA! DEALER\'S CARD VALUES SCRAMBLED!', 'tie');
                        const dealerCardsElements = this.elements.dealerCardsDiv.querySelectorAll('.card'); 
                        dealerCardsElements.forEach(cardEl => { 
                            const cardValueSpan = cardEl.querySelector('.card-value'); 
                            if (cardValueSpan) {
                                const originalValue = cardValueSpan.textContent; 
                                cardValueSpan.textContent = '??';
                                setTimeout(() => { 
                                    cardValueSpan.textContent = originalValue;
                                }, 3000); 
                            }
                        });
                        currentDealerData.uniqueAbility.usedThisGame = true; 
                        this.saveGameData();
                    }
                    break;
            }
        }

        let dealerStrategy = 'standard'; 
        if (this.currentDealer) {
            dealerStrategy = this.currentDealer.strategy;
        }

        const playDealerHand = () => {
            dealerTotal = this.getHandValue(this.dealerHand); 

            // NEW: Limit Barriers check for dealer
            if (this.isBrawl && this.isLimitBarrierActive && this.dealerHitsThisRound >= 1) {
                this.showGameMessage('Dealer hit limit due to Limit Barriers!', 'tie');
                this.determineWinner();
                return;
            }

            if (dealerTotal < 17 || (dealerStrategy === 'aggressive' && dealerTotal === 17 && this.dealerHand.some(card => card.rank === 'A' && this.getHandValue(this.dealerHand) > 21 - 10))) {
                this.dealerHand.push(this.dealCard());
                this.updateHandsDisplay();
                if (this.isBrawl && this.isLimitBarrierActive) {
                    this.dealerHitsThisRound++; // Increment dealer hit counter
                }
                setTimeout(playDealerHand, 1000); 
            } else {
                this.determineWinner();
            }
        };

        if (this.powerUps.freeze > 0 && this.isGameActive) { 
            this.showGameMessage('Dealer Frozen! Skips next hit.', 'tie');
            this.powerUps.freeze--;
            this.updatePowerUpButtons();
            this.determineWinner();
        } else {
            playDealerHand();
        }
        if (currentDealerData && currentDealerData.uniqueAbility && currentDealerData.uniqueAbility.id === 'master_ability' && currentDealerData.uniqueAbility.usedThisGame) { 
            currentDealerData.strategy = 'optimal'; 
        }
      },

      determineWinner: function() {
        const playerTotal = this.getHandValue(this.playerHand);
        const dealerTotal = this.getHandValue(this.dealerHand);

        this.games++;
        this.saveGameData();

        let outcome = '';
        if (playerTotal > 21) {
          outcome = 'bust';
        } else if (dealerTotal > 21) {
          outcome = 'dealerBust';
        } else if (playerTotal > dealerTotal) {
          outcome = 'win';
        } else if (dealerTotal > playerTotal) {
          outcome = 'lose';
        } else {
          outcome = 'tie';
        }
        this.endGame(outcome);
      },

      endGame: function(outcome) {
        this.isGameActive = false;
        this.elements.gameControls.classList.add('hidden'); 
        this.elements.powerupControls.classList.add('hidden'); 
        this.elements.betAmountInput.disabled = false; 
        this.elements.postGameControls.classList.remove('hidden'); 

        let message = '';
        let messageType = '';
        let xpReward = 0;
        let creditsWon = 0;

        const baseXP = 50;
        const campaignMultiplier = this.currentDealer ? this.currentDealer.xpMultiplier : 1;
        let betMultiplier = this.currentBet / 50; 
        
        // Apply Cyber Nexus Pass credit bonus (NEW)
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            betMultiplier *= (1 + this.cyberNexusPassDetails.creditBonus);
            this.showGameMessage(`Cyber Nexus Pass Credit Bonus: +${(this.cyberNexusPassDetails.creditBonus * 100).toFixed(0)}% Credits!`, 'win');
        }

        // Revert any active brawl rule effects at the end of the round
        if (this.activeBrawlRule && this.activeBrawlRule.revert) {
            this.activeBrawlRule.revert();
        }
        // Set activeBrawlRule to null for the next round
        this.activeBrawlRule = null;

        // Track stats for campaign progress and rogue wins
        if (this.currentDealer && !this.isRogueModeActive) { // Only track for non-rogue dealers
            if (outcome === 'win' || outcome === 'dealerBust') {
                this.campaignProgress.streaks.campaign++;
                // Increment wins for this specific dealer
                this.campaignProgress.dealerWins[this.currentDealer.id] = (this.campaignProgress.dealerWins[this.currentDealer.id] || 0) + 1;
                this.checkRogueModeUnlockConditions(); // Check for unlock after each win
            } else {
                this.campaignProgress.streaks.campaign = 0;
            }
            if (this.campaignProgress.streaks.campaign > this.campaignProgress.bestStreak) {
                this.campaignProgress.bestStreak = this.campaignProgress.streaks.campaign;
            }
        } else if (!this.currentDealer && !this.isRogueModeActive) { // Quick Play
            if (outcome === 'win' || outcome === 'dealerBust') {
                this.campaignProgress.streaks.quickPlay++;
            } else {
                this.campaignProgress.streaks.quickPlay = 0;
            }
        } else if (this.isRogueModeActive) { // If in Rogue Mode, always consider wins part of a "rogue streak"
             if (outcome === 'win' || outcome === 'dealerBust') {
                this.campaignProgress.streaks.campaign++; // Use campaign streak for rogue mode as well
            } else {
                this.campaignProgress.streaks.campaign = 0;
            }
        }


        // Specific statistics
        const playerTotalAtEnd = this.getHandValue(this.playerHand);
        if (playerTotalAtEnd === 21 && this.playerHand.length === 2 && outcome === 'win') {
            this.campaignProgress.totalBlackjacks++;
        }
        if (outcome === 'bust') {
            this.campaignProgress.totalBusts++;
        }

        switch (outcome) {
          case 'win':
            message = 'You Win!';
            messageType = 'win';
            creditsWon = this.currentBet * 2; 
            xpReward = baseXP * campaignMultiplier * betMultiplier;
            this.wins++;
            this.playSFX('sfx-win'); // Play win sound
            if (this.isBrawl) {
                this.addCharge(20); 
            }
            break;
          case 'dealerBust':
            message = 'Dealer Busts! You Win!';
            messageType = 'win';
            creditsWon = this.currentBet * 2;
            xpReward = baseXP * campaignMultiplier * betMultiplier;
            this.wins++;
            this.playSFX('sfx-win'); // Play win sound
            if (this.isBrawl) {
                this.addCharge(20); 
            }
            break;
          case 'lose':
            message = 'You Lose.';
            messageType = 'lose';
            xpReward = baseXP / 2 * campaignMultiplier * betMultiplier; 
            this.playSFX('sfx-lose'); // Play lose sound
            // In Brawl Mode, player HP is now only deducted by explicit attacks, not by losing a hand.
            // The shield logic for HP <= 0 will still be relevant if other damage sources (like dealer special attacks) reduce HP.
            if (this.isBrawl && this.playerHP <= 0) { // If player HP drops to 0 due to other means (e.g., dealer attacks), end the game
                message = 'You were defeated in Brawl Mode!';
                messageType = 'lose';
                this.showGameMessage(message, messageType);
                this.elements.postGameControls.classList.add('hidden');
                setTimeout(() => { this.backToMenu(); }, 3000);
                return;
            } else if (this.isBrawl && this.playerHP <= 0 && this.powerUps.shieldLoss > 0) {
                this.playerHP = 1; 
                this.powerUps.shieldLoss--;
                this.showGameMessage('Shield Activated! You survived this round!', 'win');
                this.updatePowerUpButtons();
                message = 'You Lose. (Shield Saved You!)';
                messageType = 'tie';
            }
            break;
          case 'bust':
            message = 'You Bust!';
            messageType = 'lose';
            xpReward = baseXP / 2 * campaignMultiplier * betMultiplier;
            this.playSFX('sfx-lose'); // Play lose sound
            // In Brawl Mode, player HP is now only deducted by explicit attacks, not by losing a hand.
            // The shield logic for HP <= 0 will still be relevant if other damage sources (like dealer special attacks) reduce HP.
            if (this.isBrawl && this.playerHP <= 0) { // If player HP drops to 0 due to other means (e.g., dealer attacks), end the game
                message = 'You were defeated in Brawl Mode!';
                messageType = 'lose';
                this.showGameMessage(message, messageType);
                this.elements.postGameControls.classList.add('hidden');
                setTimeout(() => { this.backToMenu(); }, 3000);
                return;
            } else if (this.isBrawl && this.playerHP <= 0 && this.powerUps.shieldLoss > 0) {
                this.playerHP = 1;
                this.powerUps.shieldLoss--;
                this.showGameMessage('Shield Activated! You survived this round!', 'win');
                this.updatePowerUpButtons();
                message = 'You Bust! (Shield Saved You!)';
                messageType = 'tie';
            }
            break;
          case 'tie':
            message = 'It\'s a Tie!';
            messageType = 'tie';
            creditsWon = this.currentBet; 
            xpReward = baseXP / 4 * campaignMultiplier * betMultiplier; 
            this.playSFX('sfx-tie'); // Play tie sound
            break;
        }

        this.playerCredits += creditsWon;
        this.addXP(xpReward);

        this.showGameMessage(message, messageType);
        this.updateUI(); 

        if (this.isBrawl) {
            this.updateBrawlHUD();
            if (this.dealerHP <= 0) {
                this.showGameMessage('DEALER DEFEATED! You won 300 Credits!', 'win');
                this.playerCredits += 300; 
                this.updateUI(); 
                this.elements.postGameControls.classList.add('hidden'); 
                setTimeout(() => { this.backToMenu(); }, 3000); 
                return; 
            }
            if (this.dealerHP > 0 && Math.random() < 0.3) { 
                this.dealerSpecialAttack();
            }
        }
      },

      startRiskGame: function() {
        if (this.getHandValue(this.playerHand) === 21 && this.playerHand.length === 2) {
            this.elements.riskResult.textContent = 'You already got a Blackjack! No risk game needed.';
            this.elements.riskResult.className = 'message win';
            this.elements.riskResult.classList.remove('hidden');
            return;
        }

        this.showGameMessage('Risk Game: Guess higher or lower than the hidden card!', '');
        this.elements.riskResult.classList.add('hidden');
        this.elements.riskButton.disabled = true; 

        const riskDeck = this.createDeck();
        for (let i = riskDeck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [riskDeck[i], riskDeck[j]] = [riskDeck[j], riskDeck[i]];
        }

        const hiddenCard = riskDeck.pop();
        const playerCard = riskDeck.pop(); 

        this.elements.playerCardsDiv.innerHTML = ''; 
        this.elements.playerCardsDiv.appendChild(this.createCardElement(playerCard));
        this.elements.playerTotalDisplay.textContent = `Your Card: ${playerCard.rank}`;

        const higherBtn = document.createElement('button');
        higherBtn.classList.add('game-button');
        higherBtn.textContent = 'Higher';
        higherBtn.onclick = () => this.resolveRiskGame('higher', playerCard, hiddenCard);

        const lowerBtn = document.createElement('button');
        lowerBtn.classList.add('game-button');
        lowerBtn.textContent = 'Lower';
        lowerBtn.onclick = () => this.resolveRiskGame('lower', playerCard, hiddenCard);

        this.elements.gameControls.innerHTML = ''; 
        this.elements.gameControls.appendChild(higherBtn);
        this.elements.gameControls.appendChild(lowerBtn);
        this.elements.gameControls.classList.remove('hidden');
      },

      resolveRiskGame: function(choice, playerCard, hiddenCard) {
        this.elements.gameControls.classList.add('hidden'); 
        this.elements.riskButton.disabled = false; 
        this.hideGameMessage();

        const getCardNumericValue = (card) => {
            return card.value !== undefined ? card.value : 
                   (card.rank === 'A' ? 11 :
                    (['K', 'Q', 'J'].includes(card.rank) ? 10 : parseInt(card.rank)));
        };

        const playerCardValue = getCardNumericValue(playerCard);
        const hiddenCardValue = getCardNumericValue(hiddenCard);

        this.elements.dealerCardsDiv.innerHTML = ''; 
        this.elements.dealerCardsDiv.appendChild(this.createCardElement(hiddenCard));
        this.elements.dealerTotalDisplay.textContent = `Hidden Card: ${hiddenCard.rank}`;

        let win = false;
        if (choice === 'higher') {
            win = hiddenCardValue > playerCardValue;
        } else { 
            win = hiddenCardValue < playerCardValue;
        }

        if (hiddenCardValue === playerCardValue) {
            this.elements.riskResult.textContent = 'It\'s a Push! Bet returned.';
            this.elements.riskResult.className = 'message tie';
            this.playerCredits += this.currentBet;
            this.playSFX('sfx-tie'); // Play tie sound
        } else if (win) {
            this.elements.riskResult.textContent = 'You Win! Double your credits!';
            this.elements.riskResult.className = 'message win';
            this.playerCredits += this.currentBet * 2; 
            this.playSFX('sfx-win'); // Play win sound
        } else {
            this.elements.riskResult.textContent = 'You Lose! All credits lost.';
            this.elements.riskResult.className = 'message lose';
            this.playSFX('sfx-lose'); // Play lose sound
        }
        this.elements.riskResult.classList.remove('hidden');
        this.updateUI();
        this.saveGameData();
        this.elements.postGameControls.classList.remove('hidden'); 
      },

      // Campaign mode functions
      setupDealers: function() {
        this.elements.dealersGrid.innerHTML = '';
        console.log("Setting up dealers for campaign mode.");

        // Display regular dealers
        this.dealers.forEach(dealer => {
          const dealerCard = document.createElement('div');
          dealerCard.classList.add('dealer-card');
          dealerCard.style.borderColor = dealer.color;
          dealerCard.onclick = () => this.selectCampaignDealer(dealer.id);

          const isLocked = dealer.unlocksAtLevel > this.playerLevel;
          if (isLocked) {
            dealerCard.classList.add('locked');
            dealerCard.innerHTML = `
              <div class="locked-overlay">
                <span>LOCKED</span>
                <span>Level ${dealer.unlocksAtLevel} Required</span>
                <span>Wins: ${this.campaignProgress.dealerWins[dealer.id] || 0}/${this.REQUIRED_WINS_FOR_ROGUE_MODE}</span>
              </div>
            `;
          } else {
            dealerCard.innerHTML = `
              <div class="dealer-avatar" style="border-color: ${dealer.color};">${dealer.avatar}</div>
              <div class="dealer-name ${dealer.isBoss ? 'boss-dealer-name' : ''}">${dealer.name}</div>
              <div class="dealer-type">${dealer.type}</div>
              <div class="dealer-description">${dealer.description}</div>
              <div class="dealer-stats">
                <div class="dealer-stat">
                  <span class="dealer-stat-label">XP Multiplier:</span>
                  <span class="dealer-stat-value">${dealer.xpMultiplier}x</span>
                </div>
                <div class="dealer-stat">
                  <span class="dealer-stat-label">Bet Multiplier:</span>
                  <span class="dealer-stat-value">${dealer.betMultiplier}x</span>
                </div>
              </div>
              ${dealer.uniqueAbility ? `<div class="dealer-ability-info" style="font-size: 0.75rem; color: #88ffff; margin-top: 10px;">${dealer.uniqueAbility.name}: ${dealer.uniqueAbility.description}</div>` : ''}
              <div style="font-size: 0.85rem; margin-top: 10px; color: #00ff88;">Wins: ${this.campaignProgress.dealerWins[dealer.id] || 0}/${this.REQUIRED_WINS_FOR_ROGUE_MODE}</div>
            `;
          }
          this.elements.dealersGrid.appendChild(dealerCard);
        });

        // Add Rogue Dealers button if unlocked
        this.setupRogueModeButton();
      },

      // NEW: Rogue Mode Functionality
      checkRogueModeUnlockConditions: function() {
        let allDealersUnlocked = true;
        let allDealersBeaten = true;

        this.dealers.forEach(dealer => {
            if (this.playerLevel < dealer.unlocksAtLevel) {
                allDealersUnlocked = false;
            }
            if ((this.campaignProgress.dealerWins[dealer.id] || 0) < this.REQUIRED_WINS_FOR_ROGUE_MODE) {
                allDealersBeaten = false;
            }
        });

        if (allDealersUnlocked && allDealersBeaten && !this.campaignProgress.rogueModeUnlocked) {
            this.campaignProgress.rogueModeUnlocked = true;
            this.saveGameData();
            this.showGameMessage('ROGUE DEALER MODE UNLOCKED! Prepare for the ultimate challenge!', 'win');
            this.setupRogueModeButton(); // Update button visibility
        }
      },

      setupRogueModeButton: function() {
        // Remove existing rogue mode button if it was there (for re-rendering)
        const existingRogueCard = this.elements.dealersGrid.querySelector('.rogue-mode-card');
        if (existingRogueCard) {
            existingRogueCard.remove();
        }

        const rogueCard = document.createElement('div');
        rogueCard.classList.add('dealer-card', 'rogue-mode-card');
        
        if (this.campaignProgress.rogueModeUnlocked) {
            rogueCard.onclick = () => this.enterRogueMode();
            rogueCard.innerHTML = `
                <div class="dealer-avatar" style="border-color: #FF00FF;">ðŸ”€</div>
                <div class="dealer-name boss-dealer-name">ROGUE DEALERS</div>
                <div class="dealer-type">Procedural Challenge</div>
                <div class="dealer-description">Face 7 unpredictable AI with randomized strategies and abilities. Endless challenge!</div>
                <div class="dealer-stats">
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Difficulty:</span>
                        <span class="dealer-stat-value">UNBEATABLE</span>
                    </div>
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Rewards:</span>
                        <span class="dealer-stat-value">HIGHEST</span>
                    </div>
                </div>
            `;
            // Add it at the end of the grid
            this.elements.dealersGrid.appendChild(rogueCard);
        } else {
            rogueCard.classList.add('locked');
            let unlockMessage = '';
            let allDealersUnlocked = true;
            let allDealersBeaten = true;

            this.dealers.forEach(dealer => {
                if (this.playerLevel < dealer.unlocksAtLevel) {
                    allDealersUnlocked = false;
                }
                if ((this.campaignProgress.dealerWins[dealer.id] || 0) < this.REQUIRED_WINS_FOR_ROGUE_MODE) {
                    allDealersBeaten = false;
                }
            });

            if (!allDealersUnlocked) {
                const highestLevelNeeded = Math.max(...this.dealers.map(d => d.unlocksAtLevel));
                unlockMessage = `Unlock all dealers (Reach Level ${highestLevelNeeded}+)`;
            } else if (!allDealersBeaten) {
                let remainingWins = 0;
                this.dealers.forEach(dealer => {
                    remainingWins += Math.max(0, this.REQUIRED_WINS_FOR_ROGUE_MODE - (this.campaignProgress.dealerWins[dealer.id] || 0));
                });
                unlockMessage = `Beat each dealer ${this.REQUIRED_WINS_FOR_ROGUE_MODE} times (Need ${remainingWins} more wins)`;
            }

            rogueCard.innerHTML = `
              <div class="locked-overlay">
                <span>LOCKED: ROGUE MODE</span>
                <span>${unlockMessage}</span>
              </div>
            `;
             // Add it at the end of the grid
            this.elements.dealersGrid.appendChild(rogueCard);
        }
      },

      enterRogueMode: function() {
        if (!this.campaignProgress.rogueModeUnlocked) {
            this.showGameMessage('Rogue Dealer mode is locked!', 'lose');
            return;
        }

        this.isRogueModeActive = true;
        this.rogueDealers = []; // Clear previous rogue dealers
        for (let i = 0; i < 7; i++) { // Generate 7 rogue dealers
            this.rogueDealers.push(this.generateRogueDealer(i));
        }
        this.displayRogueDealers(); // Display the generated dealers
      },

      displayRogueDealers: function() {
        this.elements.dealersGrid.innerHTML = ''; // Clear existing dealers
        this.rogueDealers.forEach(dealer => {
            const dealerCard = document.createElement('div');
            dealerCard.classList.add('dealer-card', 'rogue-dealer-instance'); // Add a class for rogue instances
            dealerCard.style.borderColor = dealer.color;
            dealerCard.onclick = () => this.selectCampaignDealer(dealer.id); // Re-use selectCampaignDealer

            dealerCard.innerHTML = `
                <div class="dealer-avatar" style="border-color: ${dealer.color};">${dealer.avatar}</div>
                <div class="dealer-name">${dealer.name}</div>
                <div class="dealer-type">${dealer.type}</div>
                <div class="dealer-description">${dealer.description}</div>
                <div class="dealer-stats">
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Strategy:</span>
                        <span class="dealer-stat-value">${dealer.strategy}</span>
                    </div>
                    <div class="dealer-stat">
                        <span class="dealer-stat-label">Ability:</span>
                        <span class="dealer-stat-value">${dealer.uniqueAbility.name}</span>
                    </div>
                </div>
                 <div class="dealer-ability-info" style="font-size: 0.75rem; color: #88ffff; margin-top: 10px;">${dealer.uniqueAbility.description}</div>
            `;
            this.elements.dealersGrid.appendChild(dealerCard);
        });
        // Optionally add a "Back to Campaign" button here if desired when viewing rogue dealers
        let backButton = document.createElement('button');
        backButton.classList.add('back-button');
        backButton.textContent = 'Back to Campaign Selection';
        backButton.onclick = () => this.showCampaign(); // Go back to original campaign screen
        this.elements.dealersGrid.appendChild(backButton);
      },

      // NEW: Populate available rogue abilities once on init
      populateAvailableRogueAbilities: function() {
        this.availableRogueAbilities = [];
        this.dealers.forEach(dealer => {
            if (dealer.uniqueAbility) {
                // Deep copy the unique ability object to ensure `usedThisGame` is independent
                this.availableRogueAbilities.push(JSON.parse(JSON.stringify(dealer.uniqueAbility)));
            }
        });
      },

      generateRogueDealer: function(index) {
        const adjectives = ['Cyber', 'Neon', 'Quantum', 'Shadow', 'Void', 'Synth', 'Chrono', 'Data', 'Ghost', 'Echo'];
        const nouns = ['Reaper', 'Specter', 'Viper', 'Assassin', 'Warden', 'Jester', 'Phantom', 'Knight', 'Guardian', 'Outlaw'];
        const types = ['Unbeatable', 'Legendary', 'Mythic', 'Apex'];
        const avatars = ['ðŸ’€', 'ðŸ¤–', 'ðŸ‘¾', 'ðŸ˜ˆ', 'ðŸ‘½', 'ðŸ‰', 'âœ¨', 'ðŸ”¥', 'ðŸŒ€', 'ðŸ”®', 'ðŸƒ', 'ðŸ§©'];
        const colors = ['#FF00FF', '#00FFFF', '#FFFF00', '#FF4500', '#32CD32', '#8A2BE2', '#FF69B4', '#00BFFF'];
        const strategies = ['conservative', 'aggressive', 'advanced', 'optimal', 'unpredictable', 'erratic', 'perfect'];
        // New array for unique rogue room images
        const rogueRoomImages = [
            'https://placehold.co/1920x1080/4B0082/FF00FF?text=ROGUE+SANCTUM',
            'https://placehold.co/1920x1080/004d40/00ffff?text=GLITCHED+REALITY',
            'https://placehold.co/1920x1080/8B0000/FFFF00?text=CORRUPTED+ZONE',
            'https://placehold.co/1920x1080/2F4F4F/32CD32?text=ANOMALY+CHAMBER',
            'https://placehold.co/1920x1080/4682B4/FF69B4?text=NEBULA+ARENA',
            'https://placehold.co/1920x1080/00008B/8A2BE2?text=VOID+CONVERGENCE',
            'https://placehold.co/1920x1080/6A5ACD/00BFFF?text=QUANTUM+RIFT'
        ];

        const randomName = `${adjectives[Math.floor(Math.random() * adjectives.length)]} ${nouns[Math.floor(Math.random() * nouns.length)]}`;
        const randomAvatar = avatars[Math.floor(Math.random() * avatars.length)];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        const randomStrategy = strategies[Math.floor(Math.random() * strategies.length)];
        // Assign a unique rogue room image
        const randomRoomImage = rogueRoomImages[index % rogueRoomImages.length]; 
        
        // Pick a random unique ability from the pre-populated pool
        const randomAbility = JSON.parse(JSON.stringify(this.availableRogueAbilities[Math.floor(Math.random() * this.availableRogueAbilities.length)]));
        randomAbility.usedThisGame = false; // Ensure it's reset for the new dealer instance

        return {
            id: `rogue-${index}-${Date.now() + Math.random()}`, // Unique ID for each rogue dealer instance
            name: randomName,
            type: types[Math.floor(Math.random() * types.length)],
            description: 'A rogue AI with unpredictable traits. Approach with caution!',
            avatar: randomAvatar,
            color: randomColor,
            music: 'assets/music/omega_theme.mp3', // Always use a high-difficulty music
            unlocksAtLevel: 1, // Already unlocked by entering the mode
            betMultiplier: 2.5, // Always highest multiplier
            xpMultiplier: 2.5, // Always highest multiplier
            strategy: randomStrategy,
            hp: 250, // Always highest HP
            isBoss: true, // Treat rogue dealers as bosses for visual effects
            uniqueAbility: randomAbility,
            roomImage: randomRoomImage // Assign the generated room image
        };
      },

      // Shop functions
      setupShop: function() {
        this.elements.shopCredits.textContent = this.playerCredits;

        // Render Weekly Pass
        this.elements.weeklyPassGrid.innerHTML = '';
        const passDetails = this.cyberNexusPassDetails;
        const passItem = document.createElement('button');
        passItem.classList.add('shop-item');
        passItem.style.borderColor = '#ffd700'; // Gold border for premium feel
        passItem.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.7)';

        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            passItem.classList.add('pass-active');
            passItem.innerHTML = `
                ${passDetails.name} (Active)<br>
                <span>Benefits active for: <span id="pass-shop-time-remaining"></span></span><br>
                <span>Renews for $${passDetails.priceUSD.toFixed(2)} USD</span><br>
                <span>Daily Bonus: ${passDetails.dailyCreditBonus} Credits</span>
            `;
            passItem.disabled = true; // Cannot buy if already active
            this.updateCyberNexusPassUI(); // Ensure header UI is updated
        } else {
            passItem.innerHTML = `
                ${passDetails.name}<br>
                <span>Access all weekly benefits!</span><br>
                <span>Price: $${passDetails.priceUSD.toFixed(2)} USD</span><br>
                <span>Worth: $${passDetails.worthUSD.toFixed(2)} USD</span><br>
                <span style="color: #00ff00;">(Save $${(passDetails.worthUSD - passDetails.priceUSD).toFixed(2)}!)</span>
            `;
            passItem.onclick = () => this.buyCyberNexusPass();
        }
        this.elements.weeklyPassGrid.appendChild(passItem);


        // Card Skins
        this.elements.cardSkinsGrid.innerHTML = '';
        this.cardSkins.forEach(skin => {
          const skinItem = document.createElement('button');
          skinItem.classList.add('shop-item');
          if (this.purchasedSkins.includes(skin.id)) {
            skinItem.classList.add('purchased');
            if (this.activeCardSkin === skin.id) {
                skinItem.classList.add('active-skin');
                skinItem.textContent = `${skin.name} (Active)`;
            } else {
                skinItem.textContent = `${skin.name} (Owned)`;
                skinItem.onclick = () => this.activateCardSkin(skin.id);
            }
          } else {
            // Apply shop discount if pass is active (NEW)
            let displayPrice = skin.price;
            if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
                displayPrice = Math.round(skin.price * (1 - this.cyberNexusPassDetails.shopDiscount));
                skinItem.innerHTML = `${skin.name}<br><span>${displayPrice} Credits <span style="text-decoration: line-through; color: #888;">${skin.price}</span></span>`;
            } else {
                skinItem.textContent = `${skin.name}\n${skin.price} Credits`;
            }
            skinItem.onclick = () => this.buyCardSkin(skin.id, displayPrice);
            if (this.playerCredits < displayPrice) {
                skinItem.disabled = true;
            }
          }
          this.elements.cardSkinsGrid.appendChild(skinItem);
        });

        // Power-up Packs - apply discount if pass is active (NEW)
        const smallPackButton = this.elements.powerUpsGrid.querySelector('button:nth-child(1)');
        const mediumPackButton = this.elements.powerUpsGrid.querySelector('button:nth-child(2)');

        const smallPackPrice = 300;
        const mediumPackPrice = 750;

        let displaySmallPackPrice = smallPackPrice;
        let displayMediumPackPrice = mediumPackPrice;

        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            displaySmallPackPrice = Math.round(smallPackPrice * (1 - this.cyberNexusPassDetails.shopDiscount));
            displayMediumPackPrice = Math.round(mediumPackPrice * (1 - this.cyberNexusPassDetails.shopDiscount));
            
            smallPackButton.innerHTML = `Small Pack<br><span>(1 Random Power-up)</span><br><span>${displaySmallPackPrice} Credits <span style="text-decoration: line-through; color: #888;">${smallPackPrice}</span></span>`;
            mediumPackButton.innerHTML = `Medium Pack<br><span>(3 Random Power-ups)</span><br><span>${displayMediumPackPrice} Credits <span style="text-decoration: line-through; color: #888;">${mediumPackPrice}</span></span>`;
        } else {
            smallPackButton.innerHTML = `Small Pack<br><span>(1 Random Power-up)</span><br><span>${smallPackPrice} Credits</span>`;
            mediumPackButton.innerHTML = `Medium Pack<br><span>(3 Random Power-ups)</span><br><span>${mediumPackPrice} Credits</span>`;
        }

        smallPackButton.onclick = () => this.buyPowerPack(1, displaySmallPackPrice);
        mediumPackButton.onclick = () => this.buyPowerPack(3, displayMediumPackPrice);

        smallPackButton.disabled = this.playerCredits < displaySmallPackPrice;
        mediumPackButton.disabled = this.playerCredits < displayMediumPackPrice;
      },

      buyCardSkin: function(skinId, price) {
        if (this.playerCredits >= price) {
          this.playerCredits -= price;
          this.purchasedSkins.push(skinId);
          this.activeCardSkin = skinId; 
          this.showGameMessage(`${this.cardSkins.find(s => s.id === skinId).name} skin purchased and activated!`, 'win');
          this.playSFX('sfx-purchase'); // Play purchase sound
          this.saveGameData();
          this.updateUI();
          this.setupShop(); 
        } else {
          this.showGameMessage('Not enough credits to buy this skin!', 'lose');
        }
      },

      activateCardSkin: function(skinId) {
        if (this.purchasedSkins.includes(skinId)) {
          this.activeCardSkin = skinId;
          this.showGameMessage(`${this.cardSkins.find(s => s.id === skinId).name} skin activated!`, 'win');
          this.playSFX('sfx-purchase'); // Play activate sound (can be same as purchase)
          this.saveGameData();
          this.updateUI();
          this.setupShop(); 
        }
      },

      buyPowerPack: function(packSize, price) { // Price now passed as argument
        if (this.playerCredits >= price) {
            this.playerCredits -= price;
            let purchasedCount = 0;
            for (let i = 0; i < packSize; i++) {
                const powerUpIds = Object.keys(this.powerUps);
                const randomPowerUpId = powerUpIds[Math.floor(Math.random() * powerUpIds.length)];
                this.powerUps[randomPowerUpId]++;
                purchasedCount++;
            }
            this.showGameMessage(`Purchased ${purchasedCount} power-up(s)!`, 'win');
            this.playSFX('sfx-purchase'); // Play purchase sound
            this.saveGameData();
            this.updateUI();
            this.updatePowerUpButtons();
            this.elements.shopCredits.textContent = this.playerCredits; 
        } else {
            this.showGameMessage('Not enough credits to buy this power-up pack!', 'lose');
        }
      },

      // NEW: Cyber Nexus Pass purchase logic
      buyCyberNexusPass: function() {
        // In a real application, this would trigger a payment gateway (e.g., Stripe, Google Play, Apple Pay)
        // For this simulation, we'll assume a successful purchase
        this.showGameMessage(`Connecting to payment system for $${this.cyberNexusPassDetails.priceUSD.toFixed(2)} USD...`, 'tie');
        
        setTimeout(() => {
            const purchaseSuccessful = Math.random() > 0.1; // 90% chance of success for demo

            if (purchaseSuccessful) {
                const now = new Date();
                this.cyberNexusPass.active = true;
                this.cyberNexusPass.expiryDate = new Date(now.getTime() + (7 * 24 * 60 * 60 * 1000)); // 7 days from now
                
                // Grant immediate bonus
                this.playerCredits += this.cyberNexusPassDetails.dailyCreditBonus * 2; // Double daily bonus as immediate perk
                this.showGameMessage('Cyber Nexus Pass Activated! Enjoy your benefits!', 'win');
                this.playSFX('sfx-purchase'); // Play purchase sound

                // Handle consecutive weeks bonus (if applicable for next purchase)
                // This logic would ideally check the *previous* pass expiry
                // For simplicity, we'll increment on purchase for now, assuming renewal.
                // A more robust system would check if it's a direct renewal.
                this.cyberNexusPass.consecutiveWeeks++;

                // Assign this week's exclusive cosmetic (or a random one for demo)
                this.cyberNexusPass.currentWeeklyCosmetic = this.weeklyCosmeticsPool[Math.floor(Math.random() * this.weeklyCosmeticsPool.length)];
                this.cyberNexusPass.weeklyCosmeticClaimed = true; // Mark as claimed for this week

                this.cyberNexusPass.lastLoginDate = now; // Set initial last login for daily bonus

                this.saveGameData();
                this.updateUI(); // Updates everything including shop and pass indicator
                this.setupShop(); // Re-render shop to show pass as active
                this.checkDailyBonus(); // Check for daily bonus right after purchase
            } else {
                this.showGameMessage('Payment failed. Please try again.', 'lose');
            }
        }, 2000); // Simulate payment processing time
      },

      // NEW: Check and grant daily bonus for pass holders
      checkDailyBonus: function() {
        if (!this.cyberNexusPass.active || this.cyberNexusPass.expiryDate <= new Date()) {
            return; // Pass not active or expired
        }

        const today = new Date();
        today.setHours(0, 0, 0, 0); // Normalize today to start of day

        const lastLogin = this.cyberNexusPass.lastLoginDate;
        let lastLoginDay = null;
        if (lastLogin) {
            lastLoginDay = new Date(lastLogin);
            lastLoginDay.setHours(0, 0, 0, 0); // Normalize last login to start of day
        }

        // If no last login, or if last login was before today
        if (!lastLogin || lastLoginDay.getTime() < today.getTime()) {
            this.playerCredits += this.cyberNexusPassDetails.dailyCreditBonus;
            this.showGameMessage(`Daily Cyber Nexus Pass bonus: +${this.cyberNexusPassDetails.dailyCreditBonus} Credits!`, 'win');
            this.cyberNexusPass.lastLoginDate = new Date(); // Update last login to now
            this.saveGameData();
            this.updateUI();
        }
      },

      // NEW: Update Cyber Nexus Pass UI in header
      updateCyberNexusPassUI: function() {
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            this.elements.weeklyPassIndicator.classList.remove('hidden');
            const timeLeft = this.cyberNexusPass.expiryDate.getTime() - new Date().getTime();
            const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
            const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

            this.elements.passTimeRemaining.textContent = 
                `${days}d ${hours}h ${minutes}m ${seconds}s`;

            // Also update the time remaining in the shop if it's open
            const shopPassTimeRemaining = document.getElementById('pass-shop-time-remaining');
            if (shopPassTimeRemaining) {
                shopPassTimeRemaining.textContent = `${days}d ${hours}h ${minutes}m ${seconds}s`;
            }

        } else {
            this.cyberNexusPass.active = false; // Ensure it's marked inactive if time runs out
            this.elements.weeklyPassIndicator.classList.add('hidden');
            this.saveGameData(); // Save status
            this.setupShop(); // Re-render shop to show pass as buyable
        }
      },

      // NEW: Check pass status on game load (or shop open)
      checkCyberNexusPassStatus: function() {
        if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate <= new Date()) {
            this.cyberNexusPass.active = false;
            this.cyberNexusPass.expiryDate = null;
            this.cyberNexusPass.weeklyCosmeticClaimed = false; // Reset for next week
            this.cyberNexusPass.currentWeeklyCosmetic = null;
            this.showGameMessage('Your Cyber Nexus Pass has expired!', 'lose');
            this.saveGameData();
        } else if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
            this.checkDailyBonus(); // Grant daily bonus if due
        }
        this.updateCyberNexusPassUI();
      },

      updatePowerUpButtons: function() {
        for (const powerUpId in this.powerUps) {
          const button = document.getElementById(`use-${powerUpId}`);
          if (button) {
            button.querySelector('span').textContent = this.powerUps[powerUpId];
            // Only enable/disable if not under EMP Burst effect
            if (!this.isBrawl || !this.activeBrawlRule || this.activeBrawlRule.id !== 'empBurst') {
                button.disabled = this.powerUps[powerUpId] === 0;
            } else {
                button.disabled = true; // Force disable under EMP Burst
            }
          }
        }
      },

      usePowerUp: function(powerUpId) {
        // Prevent power-up use if EMP Burst is active
        if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'empBurst') {
            this.showGameMessage('EMP Burst active! Power-ups are disabled!', 'lose');
            return;
        }

        if (this.powerUps[powerUpId] > 0) {
          let powerUpEffectiveness = 1;
          if (this.isBrawl && this.activeBrawlRule && this.activeBrawlRule.id === 'powerSurge') {
            powerUpEffectiveness = 1.5; // 50% more effective
            this.showGameMessage('Power Surge bonus applied!', 'win');
          }
          // Apply Cyber Nexus Pass Power-Up Resonance bonus (NEW)
          if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
              powerUpEffectiveness += this.cyberNexusPassDetails.powerUpEffectivenessBonus; // Add small bonus
          }

          switch (powerUpId) {
            case 'extraCard':
              this.playSFX('sfx-powerup-extraCard');
              let cardValueBias = 0;
              if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date() && Math.random() < this.cyberNexusPassDetails.powerUpEffectivenessBonus) { // Small chance for better card
                  cardValueBias = Math.random() < 0.5 ? 10 : 11; // Bias towards 10 or 11
              }
              const newCard = this.dealCard();
              if (cardValueBias > 0) { // If biased, try to find a card matching bias (for demo purposes)
                  const originalDeckLength = this.deck.length;
                  let foundBiasedCard = false;
                  for (let i = 0; i < originalDeckLength; i++) {
                      if (this.deck[i].value === cardValueBias) {
                          const biasedCard = this.deck.splice(i, 1)[0];
                          this.playerHand.push(biasedCard);
                          foundBiasedCard = true;
                          break;
                      }
                  }
                  if (!foundBiasedCard) { // If no biased card found, just add the new card
                      this.playerHand.push(newCard);
                  }
              } else {
                  this.playerHand.push(newCard);
              }
              this.updateHandsDisplay();
              const playerTotal = this.getHandValue(this.playerHand);
              if (playerTotal > 21) {
                this.endGame('bust');
              } else if (playerTotal === 21) {
                this.stand();
              }
              break;
            case 'peekDealer':
                this.playSFX('sfx-powerup-peekDealer');
                spawnParticles(40 * powerUpEffectiveness, '#ff00ff', 9, 1400, event); 
                const faceDownCard = this.dealerHand.find(card => card.isFaceDown);
                if (faceDownCard) {
                    faceDownCard.isFaceDown = false;
                    this.updateHandsDisplay();
                    this.showGameMessage(`Dealer's hidden card was ${faceDownCard.rank} of ${faceDownCard.suit}!`, 'tie');
                    // Show optimal next move hint (NEW - if pass active)
                    if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
                        const playerCurrentTotal = this.getHandValue(this.playerHand);
                        const dealerCurrentTotal = this.getHandValue(this.dealerHand); // Dealer's full hand is now known
                        let hint = "Consider your options carefully.";
                        if (playerCurrentTotal < 17 && playerCurrentTotal + this.getCardNumericValue(this.deck[this.deck.length - 1]) <= 21) { // Check if hitting with next card is safe
                            hint = "Hint: Hitting might be a good move.";
                        } else if (playerCurrentTotal >= 17 && playerCurrentTotal > dealerCurrentTotal && playerCurrentTotal <= 21) {
                            hint = "Hint: Standing looks strong!";
                        } else if (playerCurrentTotal >= 17 && dealerCurrentTotal > playerCurrentTotal && dealerCurrentTotal <= 21) {
                            hint = "Hint: Standing might not be enough. Consider a power-up!";
                        }
                        this.showGameMessage(`Dealer's card revealed! ${hint}`, 'tie');
                    }

                } else {
                    this.showGameMessage('No hidden card to peek!', 'lose');
                    this.powerUps[powerUpId]++; 
                    this.updatePowerUpButtons();
                    return;
                }
                break;
            case 'shieldLoss':
                this.playSFX('sfx-powerup-shieldLoss');
                let healAmount = 20 * powerUpEffectiveness;
                if (this.cyberNexusPass.active && this.cyberNexusPass.expiryDate > new Date()) {
                    healAmount += 5; // Additional 5 HP for pass holders
                }
                spawnParticles(60 * powerUpEffectiveness, '#00ff00', 12, 1700, event); 
                this.playerHP = Math.min(100, this.playerHP + healAmount); 
                this.updateBrawlHUD();
                this.showGameMessage(`Shield activated! Healed for ${healAmount} HP!`, 'win');
                break;
            case 'bomb':
                if (this.isBrawl) {
                    this.playSFX('sfx-powerup-bomb');
                    triggerScreenShake();
                    spawnParticles(80 * powerUpEffectiveness, '#ff0000', 15, 1800, event); 
                    this.dealerHP -= (20 * powerUpEffectiveness); 
                    this.updateBrawlHUD();
                    this.showGameMessage(`Brawl Bomb deployed! Dealer took ${20 * powerUpEffectiveness} damage!`, 'lose');
                    if (this.dealerHP <= 0) {
                        this.showGameMessage('DEALER DEFEATED! You won 300 Credits!', 'win');
                        this.playerCredits += 300; 
                        this.updateUI();
                        this.elements.postGameControls.classList.add('hidden'); 
                        setTimeout(() => { this.backToMenu(); }, 3000); 
                        return; 
                    }
                } else {
                    this.showGameMessage('Bomb can only be used in Brawl Mode!', 'lose');
                    this.powerUps[powerUpId]++; 
                    this.updatePowerUpButtons();
                    return;
                }
                break;
            case 'freeze':
                this.playSFX('sfx-powerup-freeze');
                spawnParticles(50 * powerUpEffectiveness, '#00aaff', 10, 1600, event); 
                // Freeze effect is handled in dealerTurn
                break;
            case 'doubleXP':
                this.playSFX('sfx-powerup-doubleXP');
                spawnParticles(60 * powerUpEffectiveness, '#ffd700', 12, 1700, event); 
                // Double XP effect is handled in addXP
                break;
          }
          this.powerUps[powerUpId]--;
          this.updatePowerUpButtons();
          this.saveGameData();
        } else {
          this.showGameMessage(`You don't have any ${this.powerUpItems[powerUpId].name}!`, 'lose');
        }
      },

      // Helper for getCardNumericValue for Peek Dealer hint
      getCardNumericValue: function(card) {
        return card.value !== undefined ? card.value : 
               (card.rank === 'A' ? 11 :
                (['K', 'Q', 'J'].includes(card.rank) ? 10 : parseInt(card.rank)));
      },


      // Brawl Mode specific attacks
      useSpecialAttack: function() {
        if (this.isBrawl && this.specialCharge >= 100) {
            this.playSFX('sfx-specialAttack'); // Play special attack sound
            triggerScreenShake();
            spawnParticles(100, '#00aaff', 15, 2000, event); // Increased count, size, duration, neon blue lightning
            this.dealerHP -= 30; 
            this.specialCharge = 0;
            this.updateBrawlHUD();
            this.showGameMessage('Special Attack! Dealer took 30 damage!', 'win');
            if (this.dealerHP <= 0) {
                this.showGameMessage('DEALER DEFEATED! You won 300 Credits!', 'win');
                this.playerCredits += 300; 
                this.updateUI();
                this.elements.postGameControls.classList.add('hidden'); 
                setTimeout(() => { this.backToMenu(); }, 3000); 
                return; 
            }
        } else {
            this.showGameMessage('Special Attack not charged!', 'lose');
        }
      },

      useUltimatePower: function() {
        if (this.isBrawl && this.ultimateCharge >= 100) {
            this.playSFX('sfx-ultimate'); // Play ultimate attack sound
            triggerScreenShake();
            spawnParticles(200, '#ff0000', 20, 2500, event); // Significantly increased count, size, duration, light red neon lightning
            this.dealerHP -= 50; 
            this.playerHP += 20; 
            if (this.playerHP > 100) this.playerHP = 100;
            this.ultimateCharge = 0;
            this.updateBrawlHUD();
            this.showGameMessage('ULTIMATE POWER! Massive damage and self-heal!', 'win');
            if (this.dealerHP <= 0) {
                this.showGameMessage('DEALER DEFEATED! You won 300 Credits!', 'win');
                this.playerCredits += 300; 
                this.updateUI();
                this.elements.postGameControls.classList.add('hidden'); 
                setTimeout(() => { this.backToMenu(); }, 3000); 
                return; 
            }
        } else {
            this.showGameMessage('Ultimate Power not charged!', 'lose');
        }
      },

      dealerSpecialAttack: function() {
        if (this.isBrawl) {
            this.playSFX('sfx-specialAttack'); // Dealer special attack sound (can be same or different)
            triggerScreenShake();
            spawnParticles(80, '#00aaff', 12, 1500); // Dealer's attack particles, more visible
            this.playerHP -= 15; 
            this.updateBrawlHUD();
            this.showGameMessage('Dealer used a special attack! You took 15 damage!', 'lose');
            this.addCharge(20, 20); 
            if (this.playerHP <= 0) {
                this.endGame('lose');
            }
        }
      },

      addCharge: function(specialGain = 0, ultimateGain = 0) {
        if (this.isBrawl) {
            this.specialCharge = Math.min(100, this.specialCharge + specialGain);
            this.ultimateCharge = Math.min(100, this.ultimateCharge + ultimateGain);
            this.updateBrawlHUD();
        }
      },

      // NEW: Glitch in the Matrix helper functions
      applyGlitchEffect: function() {
        const handsToGlitch = [this.playerHand, this.dealerHand];
        handsToGlitch.forEach(hand => {
            if (hand.length > 0) {
                const randomIndex = Math.floor(Math.random() * hand.length);
                const cardToGlitch = hand[randomIndex];
                // Store original value before glitching
                cardToGlitch.originalValue = cardToGlitch.value;
                // Assign a random glitched value (e.g., between 1 and 11)
                cardToGlitch.glitchedValue = Math.floor(Math.random() * 11) + 1;
            }
        });
        this.updateHandsDisplay(); // Update display to show '??' or glitched values
      },

      revertGlitchEffect: function() {
        const handsToGlitch = [this.playerHand, this.dealerHand];
        handsToGlitch.forEach(hand => {
            hand.forEach(card => {
                if (card.originalValue !== undefined) {
                    card.value = card.originalValue; // Revert to original value
                    delete card.glitchedValue; // Remove glitched property
                    delete card.originalValue; // Remove originalValue
                }
            });
        });
        this.updateHandsDisplay(); // Update display to show original values
      },

      // NEW: System Overload hazard functions
      applySystemOverload: function() {
        const damage = Math.floor(Math.random() * 6) + 5; // 5-10 damage
        this.playerHP = Math.max(0, this.playerHP - damage);
        this.dealerHP = Math.max(0, this.dealerHP - damage);
        this.updateBrawlHUD();
        triggerScreenShake();
        spawnParticles(150, '#ffaa00', 18, 2000); // Orange/yellow particles for overload
        this.showGameMessage(`SYSTEM OVERLOAD! Both took ${damage} damage!`, 'lose');
      },

      // NEW: EMP Burst hazard functions
      applyEmpBurst: function() {
        this.updatePowerUpButtons(); // Force disable all power-up buttons
      },

      revertEmpBurst: function() {
        this.updatePowerUpButtons(); // Re-enable based on current count
      },

      // NEW: Limit Barriers hazard functions
      applyLimitBarriers: function() {
        this.isLimitBarrierActive = true;
        // Buttons are disabled/enabled based on playerHitsThisRound in updateHandsDisplay
        this.updateHandsDisplay(); 
      },

      revertLimitBarriers: function() {
        this.isLimitBarrierActive = false;
        this.playerHitsThisRound = 0;
        this.dealerHitsThisRound = 0;
        this.updateHandsDisplay(); // Re-enable buttons if they were disabled
      },


      // Stats Screen Functions
      updateStatsScreen: function() {
        this.elements.statsGames.textContent = this.games;
        this.elements.statsWins.textContent = this.wins;
        const winRate = this.games > 0 ? ((this.wins / this.games) * 100).toFixed(2) : 0;
        this.elements.statsRate.textContent = `${winRate}%`;
        
        let mostUsedPowerUp = 'N/A';
        let maxUsage = 0;
        for (const powerUpId in this.powerUps) {
            if (this.powerUps[powerUpId] > maxUsage) {
                maxUsage = this.powerUps[powerUpId];
                mostUsedPowerUp = this.powerUpItems[powerUpId] ? this.powerUpItems[powerUpId].name : powerUpId;
            }
        }
        this.elements.statsPowerup.textContent = mostUsedPowerUp;
        this.elements.statsBlackjacks.textContent = this.campaignProgress.totalBlackjacks;
        this.elements.statsBusts.textContent = this.campaignProgress.totalBusts;
      },

      updateLeaderboard: function() {
        this.elements.leaderboard.innerHTML = '';
        const leaderboardData = [
            { name: 'Campaign Streak', value: this.campaignProgress.streaks.campaign },
            { name: 'Best Campaign Streak', value: this.campaignProgress.bestStreak },
            { name: 'Quick Play Streak', value: this.campaignProgress.streaks.quickPlay }
        ];

        leaderboardData.sort((a, b) => b.value - a.value); 

        leaderboardData.forEach((item, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span>${index + 1}. ${item.name}:</span>
                <span>${item.value}</span>
            `;
            this.elements.leaderboard.appendChild(listItem);
        });
      }
    };

    document.addEventListener('DOMContentLoaded', () => {
      game.init();
    });
  </script>
</body>
</html>
